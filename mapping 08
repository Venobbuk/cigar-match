/**
 * KT Cigar Mappings - Advanced Brand and Series Recognition
 * Contains comprehensive mappings and pattern recognition for cigar brands and series
 * Enhanced with more robust pattern matching and intelligent scoring algorithms
 *
 * Version: 5.0.0 - Enhanced Keyword Categorization and Brand-Strict Matching
 */

// Exit if accessed directly
if (!defined('ABSPATH')) {
    exit;
}

// Configurable weights for matching categories - EASILY ADJUSTABLE
define('KT_CIGAR_WEIGHT_BRAND', 45);           // Brand is most important
define('KT_CIGAR_WEIGHT_MODEL', 30);           // Series/Model is second
define('KT_CIGAR_WEIGHT_VITOLA', 20);          // Size/Vitola is third
define('KT_CIGAR_WEIGHT_DIMENSION', 25);       // Dimensions are important
define('KT_CIGAR_WEIGHT_SPECIAL_EDITION', 15); // Special editions
define('KT_CIGAR_WEIGHT_YEAR', 10);            // Year matching
define('KT_CIGAR_WEIGHT_COUNT', 10);           // Count matching
define('KT_CIGAR_WEIGHT_PACKAGING', 5);        // Packaging
define('KT_CIGAR_WEIGHT_KEYWORDS', 25);        // General keywords
define('KT_CIGAR_WEIGHT_REGIONAL', 8);         // Regional/distributor

// Cache settings
define('KT_CIGAR_CACHE_EXPIRY', 3600);         // 1 hour cache
define('KT_CIGAR_BATCH_SIZE', 50);             // Process 50 products at a time

/**
 * KT_Cigar_Debug - Custom debug logging for the cigar matching system
 * Provides detailed logging of matching operations to help troubleshoot issues
 */
class KT_Cigar_Debug {
    // Debug log file path
    private static $log_file = '';
    
    // Debug level
    private static $debug_level = 0; // 0 = off, 1 = errors only, 2 = basic info, 3 = verbose
    
    // Max log file size (2MB)
    private static $max_log_size = 2097152;
    
    // Initialize debug system
    public static function init($log_file = '', $debug_level = 2) {
        // Set log file location (default to plugin directory if not specified)
        if (empty($log_file)) {
            $upload_dir = wp_upload_dir();
            self::$log_file = $upload_dir['basedir'] . '/cigar_matcher_debug.log';
        } else {
            self::$log_file = $log_file;
        }
        
        self::$debug_level = $debug_level;
        
        // Check if log file exists and exceeds size limit
        if (file_exists(self::$log_file) && filesize(self::$log_file) > self::$max_log_size) {
            self::rotate_log();
        }
        
        // Create log file if it doesn't exist
        if (!file_exists(self::$log_file) && self::$debug_level > 0) {
            self::log_header();
        }
        
        // Test log file writability
        if (self::$debug_level > 0) {
            $test_write = @file_put_contents(self::$log_file, "", FILE_APPEND);
            if ($test_write === false) {
                error_log("KT_Cigar_Debug: Unable to write to log file at " . self::$log_file);
                // Try to create log file in system temp directory as fallback
                $temp_dir = sys_get_temp_dir();
                self::$log_file = $temp_dir . '/cigar_matcher_debug.log';
                self::log_header();
            }
        }
    }
    
    // Rotate log file (keep last 100KB of log)
    private static function rotate_log() {
        if (file_exists(self::$log_file)) {
            $content = @file_get_contents(self::$log_file);
            if ($content !== false) {
                // Keep only the last 100KB of the log
                $content = substr($content, -102400);
                @file_put_contents(self::$log_file, "--- LOG ROTATED DUE TO SIZE [" . date('Y-m-d H:i:s') . "] ---\n" . $content);
            }
        }
    }
    
    // Write header to log file
    private static function log_header() {
        $header = "=======================================================\n";
        $header .= "KT Cigar Matcher Debug Log - Started: " . date('Y-m-d H:i:s') . "\n";
        $header .= "PHP Version: " . PHP_VERSION . " | OS: " . PHP_OS . "\n";
        $header .= "=======================================================\n\n";
        @file_put_contents(self::$log_file, $header);
    }
    
    // Log a message with timestamp
    public static function log($message, $level = 2, $context = '') {
        if (self::$debug_level < $level || self::$debug_level == 0) {
            return; // Skip if debug level is lower than message level
        }
        
        // Check file size before logging
        if (file_exists(self::$log_file) && filesize(self::$log_file) > self::$max_log_size) {
            self::rotate_log();
        }
        
        if (!empty($context)) {
            $context = "[$context] ";
        }
        
        $log_entry = date('Y-m-d H:i:s') . " {$context}{$message}\n";
        $result = @file_put_contents(self::$log_file, $log_entry, FILE_APPEND);
        
        // If we couldn't write to the log, try system error log as last resort
        if ($result === false) {
            error_log("KT_Cigar_Matcher: " . $message);
        }
    }
    
    // Enhanced log match details with keyword categorization
    public static function log_match($supplier_title, $internal_title, $score, $match_type, $debug_info) {
        if (self::$debug_level < 2) return;
        
        // Check file size before logging
        if (file_exists(self::$log_file) && filesize(self::$log_file) > self::$max_log_size) {
            self::rotate_log();
        }
        
        // First line: Basic match info
        $log_entry = "MATCH: " . mb_substr($supplier_title, 0, 30) . " => " . 
                     mb_substr($internal_title, 0, 30) . " | " . 
                     round($score, 1) . "% ($match_type)";
        
        // Add categorized keywords if available
        if (isset($debug_info['categorized_keywords'])) {
            $categories = $debug_info['categorized_keywords'];
            $log_entry .= "\n       Keywords: ";
            foreach ($categories as $category => $keywords) {
                if (!empty($keywords)) {
                    $log_entry .= "$category(" . count($keywords) . ") ";
                }
            }
        }
        
        // Add cache info if available
        if (isset($debug_info['cache_status'])) {
            $log_entry .= " | Cache: " . $debug_info['cache_status'];
        }
        
        @file_put_contents(self::$log_file, $log_entry . "\n", FILE_APPEND);
    }
    
    // Clear log file
    public static function clear_log() {
        if (file_exists(self::$log_file)) {
            @unlink(self::$log_file);
            self::log_header();
        }
    }
}

/**
 * KT_Cigar_Mappings - Main class for cigar brand and model mappings
 * Provides comprehensive data structures and helper methods for matching cigars
 */
class KT_Cigar_Mappings {
    // Filter words that don't help in matching
    private static $common_filter_words = array(
        // Basic Chinese filter words
        '盒', '盒装', 'box', '装', '只', '支', '五只', '五支', '三只', '三支', 
        '四只', '四支', 'pcs', '片', '条', '整盒', '整箱', '带盒', '带管', 
        '铝管装', '礼盒', '普通装', '单支', '裸支', '非卖品', '定制', '茄', 
        '雪茄', 'cigar', 'cigars', '烟', '单盒', '高端', '限量', '限定', '特殊', 
        '特制', '精选', '厂家', '正品', '产品', '精美', '小', '大', '中号', '特号', 
        '产地', '古巴', '古代', 'cuba', '全球', '包邮', '正品', '原装', '现货', 
        '新品', '无盒', '年', '年份', '打火机', 
        // Additional Chinese filter words
        '正宗', '进口', '原厂', '手工', '传统', '珍藏', '稀有', '收藏', '经典',
        '香味', '口感', '香气', '味道', '醇厚', '浓郁', '清淡', '顺滑', '复杂',
        '平衡', '均衡', '层次', '丰富', '细腻', '圆润', '柔和', '强烈', '温和',
        '烟丝', '烟叶', '烟草', '烟根', '烟身', '烟头', '烟尾', '烟灰', '烟斗',
        '烟嘴', '烟道', '烟油', '香烟', '雪茄烟', '雪茄店', '雪茄馆', '雪茄吧',
        // English common words
        'the', 'and', 'for', 'with', 'from', 'this', 'that', 'these', 'those', 
        'of', 'in', 'on', 'at', 'by', 'to', 'a', 'an', 'it', 'is', 'are', 'was', 
        // Chinese common words
        '有', '是', '的', '了', '在', '和', '与', '或', '不', '很', '也', '就',
        '我', '你', '他', '她', '它', '我们', '你们', '他们', '她们', '它们',
        '这', '那', '这些', '那些', '这个', '那个', '什么', '为什么', '怎么',
        '如何', '何时', '何地', '何人', '何物', '何事', '何种', '何样', '多少'
    );

    // Pre-indexed keyword cache
    private static $keyword_cache = null;
   
    // Brand mapping cache
    private static $brand_mapping_cache = null;

    /**
     * Get mappings of Cuban cigar brands with their Chinese variations
     */
    public static function get_cuban_brand_mappings() {
        return array(
            // Top Cuban Brands with multiple Chinese naming variations
            'cohiba' => array('高希霸', '科伊巴', '科希巴', '科伊瓦', '科巴', '哥希霸', '哥伊巴', '柯希巴', '可希巴', '寇希巴', 'cohiba'),
            'montecristo' => array('蒙特', '蒙特克里斯托', '蒙特克里斯多', '蒙特西托', '蒙德克里斯多', '蒙特利斯托', '蒙克', '蒙特克里托', '蒙特利多', '蒙泰克里斯托', 'montecristo', 'monte'),
            'romeo y julieta' => array('罗密欧', '罗密欧与朱丽叶', '罗密欧朱丽叶', '罗密欧与茱丽叶', '罗密欧茱丽叶', '罗密欧与朱丽叶', '罗密欧朱丽叶', '罗密欧朱利叶', '罗密欧与朱利叶', '罗朱', 'romeo', 'romeo y julieta', 'r&j'),
            'partagas' => array('帕特加斯', '帕塔加斯', '帕达加斯', '帕塔嘉斯', '帕塔加思', '帕特嘉斯', '巴塔加斯', '帕塔加', '帕达嘉斯', '帕特加', 'partagas'),
            'h. upmann' => array('优佩曼', '乌普曼', '乌帕曼', '邬普曼', '尤普曼', '乌普曼', '哈瓦那优普曼', '优普曼', '诶查厄普曼', '赫乌普曼', 'h. upmann', 'upmann', 'h upmann'),
            'hoyo de monterrey' => array('好友', '霍约蒙特雷', '蒙特雷好友', '何友', '好友蒙特雷', '蒙特雷', '好友德蒙特雷', '霍约德蒙特雷', '好友山景', '豪友', 'hoyo', 'hdm'),
            'bolivar' => array('波利瓦尔', '玻利瓦尔', '博利瓦尔', '玻利瓦', '博利瓦', '波利瓦', '玻利瓦儿', '博利瓦儿', '波利瓦儿', '玻利华尔', 'bolivar'),
            'trinidad' => array('特立尼达', '特立达', '特立尼达德', '特立尼', '特立尼特', '特立尼达得', '特利尼达', '特利尼', '特利尼特', '特丽尼达', 'trinidad'),
            'san cristobal de la habana' => array('圣克里斯托巴尔', '圣克里斯托瓦尔', '圣克里斯托', '圣克', '哈瓦那圣克', '圣克里斯多巴尔', '圣克里斯托', '圣克里', '圣科里斯托瓦尔', '圣克里托巴尔', 'san cristobal', 'scl'),
            'juan lopez' => array('胡安·洛佩兹', '胡安洛佩兹', '胡安·洛佩斯', '胡安洛佩斯', '胡安·洛培兹', '胡安洛培兹', '胡安·洛培斯', '胡安洛培斯', '璜·洛佩兹', '璜洛佩兹', 'juan lopez'),
            'el rey del mundo' => array('雷伊世界', '世界之王', '雷德蒙多', '雷伊德尔蒙多', '雷伊德尔蒙度', '雷伊德尔蒙道', '雷伊', '世界雷伊', '雷伊世界王', '世界之王雷伊', 'rey del mundo', 'erdm'),
            'quai d\'orsay' => array('奥赛码头', '多尔塞码头', '多赛码头', '奥尔赛码头', '多赛', '奥赛', '多尔赛', '奥尔塞', '多塞', '奥塞', 'quai dorsay', 'dorsay'),
            'diplomaticos' => array('外交官', '迪普洛马蒂克斯', '迪普洛马蒂科斯', '迪普洛马蒂', '迪普', '外交', '迪普洛', '迪普洛马', '迪普洛马蒂', '迪普洛马特', 'diplomaticos'),
            'rafael gonzalez' => array('拉斐尔·冈萨雷斯', '拉菲尔·冈萨雷斯', '拉斐尔冈萨雷斯', '拉菲尔冈萨雷斯', '拉法尔·贡萨勒斯', '拉法尔贡萨勒斯', '拉斐尔·贡萨雷斯', '拉斐尔贡萨雷斯', '拉菲尔', '拉斐尔', 'rafael gonzalez'),
            'fonseca' => array('丰塞卡', '方塞卡', '丰塞克', '封塞卡', '方塞克', '丰赛卡', '封赛卡', '封世家', '封斯卡', '豐塞卡', 'fonseca'),
            'sancho panza' => array('桑丘·潘沙', '桑丘潘沙', '桑乔·潘萨', '桑乔潘萨', '桑丘·潘查', '桑丘潘查', '桑乔·潘扎', '桑乔潘扎', '桑丘', '潘沙', 'sancho panza'),
            'la gloria cubana' => array('古巴荣耀', '古巴光荣', '古巴荣光', '古巴格洛瑞亚', '古巴拉格洛瑞亚', '古巴格洛丽亚', '荣耀古巴', '荣光古巴', '光荣古巴', '拉格洛瑞亚', 'la gloria cubana', 'lgc'),
            'por larranaga' => array('保拉拉纳加', '波拉拉纳加', '波尔拉纳加', '波尔拉拉那加', '波拉腊那加', '保拉拉那加', '保拉腊那加', '波尔拉腊那加', '拉纳加', '保拉', 'por larranaga'),
            'quintero' => array('昆特罗', '金特罗', '琴特罗', '坤特罗', '群特罗', '坤特洛', '坤特罗斯', '群塔罗', '昆塔罗', '金塔罗', 'quintero'),
            'jose l. piedra' => array('何塞·皮德拉', '何塞皮德拉', '霍塞·皮埃德拉', '霍塞皮埃德拉', '何塞·彼德拉', '何塞彼德拉', '霍塞·彼埃德拉', '霍塞彼埃德拉', '皮德拉', '彼德拉', 'jose l piedra', 'jlp'),
            'vegueros' => array('韦格罗斯', '维格罗斯', '韦格洛斯', '维格洛斯', '韦格', '维格', '韦古罗斯', '维古罗斯', '韦古洛斯', '维古洛斯', 'vegueros'),
            'punch' => array('潘趣', '潘虚', '潘切', '邦切', '邦趣', '邦虚', '盘趣', '盘虚', '盘切', '潘什', 'punch'),
            'saint luis rey' => array('圣路易斯雷伊', '圣路易王', '圣路易斯·雷伊', '圣路易斯王', '圣路易王', '圣雷伊', '圣路易士雷伊', '圣路易士王', '圣路易斯', '圣路易', 'saint luis rey', 'slr'),
            'ramon allones' => array('雷蒙·阿隆尼斯', '雷蒙阿隆尼斯', '莱蒙·阿罗尼斯', '莱蒙阿罗尼斯', '拉蒙·阿隆内斯', '拉蒙阿隆内斯', '雷蒙·阿洛尼斯', '雷蒙阿洛尼斯', '阿隆尼斯', '雷蒙', 'ramon allones'),
            'cuaba' => array('库阿巴', '古巴巴', '库巴巴', '酷阿巴', '库瓦巴', '酷瓦巴', '库巴', '卡巴', '库阿瓦', '库瓦', 'cuaba'),
            'vegafina' => array('维加菲纳', '韦加菲纳', '维佳菲娜', '韦佳菲娜', '维加芬娜', '维嘉菲娜', '维佳芬娜', '维嘉芬娜', '菲纳', '维加', 'vegafina')
        );
    }

    /**
     * Get mappings of top non-Cuban cigar brands with their Chinese variations
     */
    public static function get_non_cuban_brand_mappings() {
        return array(
            // Top non-Cuban brands (Nicaraguan, Dominican, etc.)
            'padron' => array('帕德龙', '帕德隆', '帕德朗', '帕特龙', '帕特隆', '帕德罗', '帕特罗', '帕德隆', '帕多隆', '帕多龙', '巴德龙', '巴德隆', '巴德朗', '巴特龙', '帕迪龙', '帕迪隆', 'padron', 'padrón'),
            
            'arturo fuente' => array('阿图罗·富恩特', '阿图罗富恩特', '阿图罗·符恩特', '阿图罗符恩特', '富恩特', '符恩特', '阿图罗', '阿杜罗·富恩特', '阿杜罗富恩特', '富恩特家族', '阿杜罗富恩特', '亚图罗富恩特', '亚图罗·富恩特', '富安特', '福恩特', '福安特', '富恩德', '富恩蒂', '阿图罗福恩特', 'arturo fuente', 'fuente'),
            
            'my father' => array('我的父亲', '麦法瑟', '麦法泽', '麦法哲', '麦法德', '麦法蒂', '迈法瑟', '迈法泽', '迈法哲', '父亲', '我父亲', '吾父', '我爸爸', '加西亚', '加西亚我的父亲', '何塞加西亚', '唐佩平', '唐·佩平', '佩平加西亚', '佩平', 'my father', 'my father cigars'),
            
            'oliva' => array('奥利瓦', '奥利娃', '奥丽瓦', '奥丽娃', '欧利瓦', '欧利娃', '欧丽瓦', '欧丽娃', '奥利', '欧利', '奥利华', '欧利华', '奥力瓦', '欧力瓦', '奥利弗', '欧利弗', '奥里瓦', '欧里瓦', '奥立瓦', '欧立瓦', 'oliva'),
            
            'davidoff' => array('大卫杜夫', '大卫·杜夫', '大为杜夫', '大为·杜夫', '达维多夫', '达维·多夫', '达维·杜夫', '大卫多夫', '大卫·多夫', '杜夫', '大卫度夫', '大威杜夫', '戴维多夫', '戴维杜夫', '戴维·杜夫', '达维杜夫', '达维都夫', '達維多夫', '大維杜夫', '達維杜夫', 'davidoff'),
            
            'drew estate' => array('杜鲁庄园', '德鲁庄园', '杜鲁农庄', '德鲁农庄', '德鲁产业', '杜鲁产业', '德鲁地产', '杜鲁地产', '德鲁', '杜鲁', '杜鲁雪茄', '德鲁雪茄', '德鲁艾斯特', '杜鲁艾斯特', '德鲁庄园公司', '杜鲁庄园公司', '德鲁地产公司', '杜鲁地产公司', 'drew estate'),
            
            'alec bradley' => array('亚历克·布拉德利', '亚历克布拉德利', '阿列克·布拉德利', '阿列克布拉德利', '艾力克·布莱德利', '艾力克布莱德利', '亚力克·布莱德利', '亚力克布莱德利', '布拉德利', '亚历克', '亚历克·布莱德利', '阿力克布拉德利', '艾利克布拉德利', '亚列克布拉德利', '亚力布拉德利', '艾立克布莱德利', '阿立克布拉德利', 'alec bradley', 'ab'),
            
            'rocky patel' => array('洛基·帕特尔', '洛基帕特尔', '罗基·帕特尔', '罗基帕特尔', '洛基·帕特', '洛基帕特', '罗基·帕特', '罗基帕特', '帕特尔', '洛基', '洛奇帕特尔', '罗奇帕特尔', '洛基巴特尔', '罗基巴特尔', '洛基派特尔', '罗基派特尔', '洛基帕泰尔', '罗基帕泰尔', '岩石帕特尔', '石头帕特尔', 'rocky patel', 'rp'),
            
            'perdomo' => array('佩多莫', '帕多莫', '佩尔多莫', '帕尔多莫', '佩多摩', '帕多摩', '佩尔多摩', '帕尔多摩', '多莫', '佩多', '珀多莫', '珀尔多莫', '佩都莫', '帕都莫', '佩朵莫', '帕朵莫', '佩多谟', '帕多谟', '佩多墨', '帕多墨', 'perdomo'),
            
            'e.p. carrillo' => array('E.P.卡里洛', 'E.P.·卡里洛', 'E.P.卡利略', 'E.P.·卡利略', 'E.P.卡里约', 'E.P.·卡里约', 'E.P.卡里罗', 'E.P.·卡里罗', '卡里洛', '卡利略', '卡里约', '卡里罗', '卡利洛', '卡利约', '卡利罗', '卡理洛', '卡理略', '卡理约', '卡理罗', '厄内斯托·佩雷斯·卡里洛', '厄内斯托卡里洛', '佩雷斯卡里洛', '埃内斯托卡里洛', 'e.p. carrillo', 'ep carrillo', 'carrillo'),
            
            'la flor dominicana' => array('多米尼加之花', '多米尼加花', '多米尼加的花', '多明尼加之花', '多明尼加花', '多明尼加的花', '拉弗罗多米尼加纳', '拉弗洛多米尼加纳', '拉芙罗多米尼加纳', '拉芙洛多米尼加纳', '拉弗洛多米尼加', '拉芙洛多米尼加', '拉·弗洛尔·多米尼加纳', '拉弗洛尔多米尼加纳', '多米尼加的花朵', '多明尼加的花朵', '多米尼加之花雪茄', 'la flor dominicana', 'lfd'),
            
            'ashton' => array('阿什顿', '艾什顿', '亚什顿', '艾许顿', '亚许顿', '阿什敦', '艾什敦', '亚什敦', '艾许敦', '亚许敦', '爱诗顿', '爱士顿', '阿诗顿', '艾诗顿', '阿士顿', '艾士顿', '亚诗顿', '亚士顿', '阿什敦', '艾什敦', 'ashton'),
            
           'macanudo' => array('马卡努多', '麦卡努多', '马卡努铎', '麦卡努铎', '马克努多', '麦克努多', '马克努铎', '麦克努铎', '卡努多', '马卡', '麦卡', '麦卡鲁多', '马卡鲁多', '麦克鲁多', '马克鲁多', '玛卡努多', '玛克努多', '麦卡纽多', '马卡纽多', 'macanudo'),
           
           'camacho' => array('卡马乔', '卡玛乔', '卡马丘', '卡玛丘', '卡马肖', '卡玛肖', '喀马乔', '喀玛乔', '喀马丘', '喀玛丘', '卡玛丘', '卡马秋', '卡玛秋', '卡马茶', '卡玛茶', '卡马周', '卡玛周', '卡吗乔', '咖玛乔', '咖马乔', 'camacho'),
           
           'cao' => array('CAO', '希爱欧', '希爱傲', '希艾欧', '希艾傲', '西爱欧', '西爱傲', '西艾欧', '西艾傲', '希爱欧雪茄', '卡奥', '高', '曹', '草', '考', '靠', '希欧', '希傲', '西欧', '西傲', 'cao'),
           
           'joya de nicaragua' => array('尼加拉瓜的宝石', '尼加拉瓜宝石', '尼加拉瓜珠宝', '尼加拉瓜之宝', '何亚尼加拉瓜', '乔亚尼加拉瓜', '霍亚尼加拉瓜', '豪亚尼加拉瓜', '尼加拉瓜', '何亚', '乔亚', '霍亚', '豪亚', '荷亚尼加拉瓜', '胡亚尼加拉瓜', '侯亚尼加拉瓜', '和亚尼加拉瓜', '尼加拉瓜乔亚', '尼加拉瓜霍亚', 'joya de nicaragua', 'jdn'),
           
           'aj fernandez' => array('AJ·费尔南德斯', 'AJ费尔南德斯', 'AJ·费南德斯', 'AJ费南德斯', 'AJ·费尔南多斯', 'AJ费尔南多斯', 'AJ·费南多斯', 'AJ费南多斯', '费尔南德斯', 'AJ', 'AJ·费尔南迪斯', 'AJ费尔南迪斯', 'AJ·费南迪斯', 'AJ费南迪斯', '艾杰费尔南德斯', '艾杰费南德斯', '埃杰费尔南德斯', '埃杰费南德斯', '阿杰费尔南德斯', '阿杰费南德斯', 'aj fernandez', 'ajf'),
           
           'la aurora' => array('拉奥罗拉', '拉欧若拉', '拉奥若拉', '拉欧罗拉', '拉·奥罗拉', '拉·欧若拉', '拉·奥若拉', '拉·欧罗拉', '奥罗拉', '欧若拉', '拉奥洛拉', '拉欧洛拉', '拉阿罗拉', '拉啊罗拉', '拉澳罗拉', '拉澳若拉', '曙光', '极光', '黎明', '拉黎明', 'la aurora', 'aurora'),
           
           'plasencia' => array('普拉森西亚', '普拉森西娅', '普拉森希亚', '普拉森希娅', '普拉申西亚', '普拉申西娅', '普拉申希亚', '普拉申希娅', '普拉森', '普拉申', '普拉森夏', '普拉申夏', '普拉森霞', '普拉申霞', '普拉圣西亚', '普拉圣夏', '普拉森斯亚', '普拉申斯亚', '普拉先西亚', '普拉先夏', 'plasencia'),
           
           // Additional non-Cuban brands
           'tatuaje' => array('塔图阿赫', '塔图哈耶', '纹身', '塔图亚耶', '塔图阿杰', '塔图哈杰', '达图阿赫', '达图哈耶', '塔图艾', '塔图耶', '塔图杰', '塔图埃', '塔图阿埃', '塔图哈埃', '刺青', '文身', 'tatuaje'),
           
           'liga privada' => array('私人联盟', '私人同盟', '利加私人', '利加', '私藏联盟', '私藏同盟', '秘密联盟', '秘密同盟', '里加私人', '里加', '利嘉私人', '利嘉', '私人利加', '私人里加', '私人利嘉', 'liga privada', 'liga'),
           
           'undercrown' => array('地下皇冠', '恩都罗', '下冠', '暗冠', '皇冠下', '地下冠', '安德皇冠', '安德冠', '恩德皇冠', '恩德冠', '底冠', '低冠', '次皇冠', '次冠', 'undercrown', 'uc'),
           
           'kristoff' => array('克里斯托夫', '克里斯托弗', '克里斯多夫', '克里斯多弗', '克里斯朵夫', '克里斯朵弗', '基里斯托夫', '基里斯托弗', '克里斯托福', '克里斯多福', '克里斯朵福', '基里斯托福', '克里斯托', '克里斯多', 'kristoff'),
           
           'crowned heads' => array('加冕之首', '皇冠之首', '冠首', '皇冠之头', '加冕之头', '冠头', '王冠之首', '王冠之头', '皇冠头', '加冕头', '王冠头', '冠军之首', '冠军之头', '冠军头', 'crowned heads', 'ch'),
           
           'viaje' => array('维亚赫', '维阿赫', '维亚杰', '维阿杰', '旅行', '旅程', '航程', '征程', '威亚赫', '威阿赫', '威亚杰', '威阿杰', '维亚热', '维阿热', '威亚热', '威阿热', 'viaje'),
           
           'l\'atelier' => array('工作室', '工坊', '拉特利尔', '拉特利埃', '拉特利耶', '拉特丽尔', '拉特丽埃', '拉特丽耶', '拉泰利尔', '拉泰利埃', '拉泰利耶', '拉泰丽尔', '拉泰丽埃', '拉泰丽耶', '工匠', '匠人', 'l\'atelier', 'latelier', 'l atelier'),
           
           'southern draw' => array('南方绘画', '南方抽签', '南部绘画', '南部抽签', '南方画', '南部画', '南方德劳', '南部德劳', '索瑟恩德劳', '索瑟恩德洛', '南方德洛', '南部德洛', '南方拉', '南部拉', 'southern draw', 'sd'),
           
           'herrera esteli' => array('埃雷拉埃斯特利', '埃雷拉埃斯特里', '赫雷拉埃斯特利', '赫雷拉埃斯特里', '艾雷拉埃斯特利', '艾雷拉埃斯特里', '埃雷拉', '赫雷拉', '艾雷拉', '埃斯特利', '埃斯特里', '埃雷拉艾斯特利', '赫雷拉艾斯特利', '艾雷拉艾斯特利', 'herrera esteli', 'he'),
           
           'foundation' => array('基础', '基金会', '基金', '创基', '创立', '奠基', '根基', '基石', '佛恩达深', '方德深', '方德森', '丰德深', '丰德森', '富恩达深', '富恩达森', 'foundation', 'foundation cigars'),
           
           'warped' => array('翘曲', '弯曲', '华普德', '瓦普德', '沃普德', '华普特', '瓦普特', '沃普特', '华普', '瓦普', '沃普', '变形', '扭曲', '歪曲', '华博德', '瓦博德', '沃博德', 'warped', 'warped cigars'),
           
           'dunbarton tobacco & trust' => array('邓巴顿烟草信托', '邓巴顿', '邓巴敦烟草信托', '邓巴敦', '登巴顿烟草信托', '登巴顿', '登巴敦烟草信托', '登巴敦', '敦巴顿烟草信托', '敦巴顿', '敦巴敦烟草信托', '敦巴敦', '邓巴顿烟草', '邓巴敦烟草', '登巴顿烟草', '登巴敦烟草', 'dunbarton tobacco & trust', 'dunbarton', 'dt&t'),
           
           'illusione' => array('幻影', '幻象', '幻觉', '错觉', '伊鲁西奥内', '伊鲁西奥尼', '伊露西奥内', '伊露西奥尼', '伊路西奥内', '伊路西奥尼', '伊卢西奥内', '伊卢西奥尼', '伊陆西奥内', '伊陆西奥尼', '幻境', '错觉', 'illusione'),
           
           'roma craft' => array('罗马工艺', '罗马工坊', '罗马手工', '罗马技艺', '罗马克拉夫特', '罗马克拉夫', '罗马克莱夫特', '罗马克莱夫', '罗玛工艺', '罗玛工坊', '罗玛手工', '罗玛技艺', '罗玛克拉夫特', '罗玛克拉夫', 'roma craft', 'romacraft'),
           
           'leaf by oscar' => array('奥斯卡之叶', '奥斯卡叶子', '奥斯卡烟叶', '叶子奥斯卡', '烟叶奥斯卡', '奥斯卡的叶', '奥斯卡的烟叶', '奥斯卡的叶子', '奥斯卡之页', '奥斯卡页', '欧斯卡之叶', '欧斯卡叶子', '欧斯卡烟叶', 'leaf by oscar', 'leaf'),
           
           'espinosa' => array('埃斯皮诺萨', '埃斯皮诺莎', '艾斯皮诺萨', '艾斯皮诺莎', '埃斯宾诺萨', '埃斯宾诺莎', '艾斯宾诺萨', '艾斯宾诺莎', '埃斯比诺萨', '埃斯比诺莎', '艾斯比诺萨', '艾斯比诺莎', '埃斯匹诺萨', '埃斯匹诺莎', '艾斯匹诺萨', '艾斯匹诺莎', 'espinosa', 'espinosa cigars'),
           
           'room101' => array('101房间', '房间101', '101室', '室101', '101号房', '房号101', '101号室', '室号101', '一零一房间', '房间一零一', '一零一室', '室一零一', '壹零壹房间', '房间壹零壹', '壹零壹室', '室壹零壹', 'room101', 'room 101'),
           
           'avo' => array('阿沃', '爱沃', '艾沃', '阿伏', '爱伏', '艾伏', '阿佛', '爱佛', '艾佛', '阿窝', '爱窝', '艾窝', '阿握', '爱握', '艾握', '阿夫', '爱夫', '艾夫', 'avo', 'avo cigars'),
           
           'mbombay' => array('孟买', '蒙贝', '蒙拜', '孟贝', '孟拜', '蒙买', '姆贝', '姆拜', '姆孟买', '姆蒙贝', '姆蒙拜', '姆孟贝', '姆孟拜', '姆蒙买', '母贝', '母拜', 'mbombay', 'm bombay'),
           
           // Additional premium brands
           'hammer + sickle' => array('锤子镰刀', '锤与镰', '铁锤镰刀', '铁锤与镰刀', '锤镰', '锤和镰刀', '锤加镰刀', '锤子加镰刀', '铁锤加镰刀', '哈默与镰刀', '哈默加镰刀', '汉默与镰刀', '汉默加镰刀', 'hammer + sickle', 'hammer and sickle', 'hammer & sickle'),
           
           'quesada' => array('克萨达', '奎萨达', '凯萨达', '盖萨达', '格萨达', '克塞达', '奎塞达', '凯塞达', '盖塞达', '格塞达', '克赛达', '奎赛达', '凯赛达', '盖赛达', '格赛达', '奎沙达', '凯沙达', '克沙达', 'quesada'),
           
           'asylum' => array('疯人院', '精神病院', '避难所', '庇护所', '收容所', '阿塞勒姆', '阿赛勒姆', '阿塞伦', '阿赛伦', '阿西勒姆', '阿西伦', '艾塞勒姆', '艾赛勒姆', '艾塞伦', '艾赛伦', 'asylum', 'asylum cigars'),
           
           'fratello' => array('兄弟', '弗拉特洛', '富拉特洛', '夫拉特洛', '弗拉泰洛', '富拉泰洛', '夫拉泰洛', '弗拉特罗', '富拉特罗', '夫拉特罗', '弗拉泰罗', '富拉泰罗', '夫拉泰罗', '兄弟雪茄', '法拉特洛', 'fratello', 'fratello cigars')
       );
   }
   
   /**
    * Enhanced size terms (vitolas) mapping
    * Expanded with more international variations and patterns, including small sizes
    */
   public static function get_size_mappings() {
       return array(
           // English terms - common vitolas with expanded Chinese equivalents
           'robusto' => array('罗布图', '罗伯图', '罗拔图', '罗布斯托', '罗布托', '罗布', '劳伯图', '罗布图斯', '罗伯图斯', '罗普图'),
           'toro' => array('托罗', '公牛', '多罗', '托洛', '多洛', '托鲁', '多鲁', '特罗', '特洛', '特鲁'),
           'torpedo' => array('鱼雷', '托皮多', '鱼型', '雷', '托比多', '托皮铎', '托比铎', '鱼形', '鱼雷型', '雷形'),
           'churchill' => array('丘吉尔', '丘', '邱吉尔', '丘切尔', '丘丘', '邱丘', '丘丘尔', '丘尔切', '丘奇尔', '邱切尔'),
           'corona' => array('皇冠', '科罗那', '皇', '冠', '科罗娜', '克罗那', '可罗那', '科罗', '克罗娜', '可罗娜'),
           'petit corona' => array('小皇冠', '小科罗那', '小皇', '小冠', '迷你皇冠', '小克罗那', '迷你科罗那', '小科罗娜', '迷你科罗娜', '小型皇冠'),
           'lancero' => array('长矛', '兰塞罗', '长', '矛', '兰赛罗', '长矛型', '细长', '长形', '兰彻罗', '兰切罗'),
           'belicoso' => array('比利高', '彪丽高', '比利高斯', '鱼雷', '比利', '贝利高', '比利克', '比丽高', '比利科', '比利克斯'),
           'pyramid' => array('金字塔', '金塔', '塔型', '比拉米德', '比拉米', '比拉米特', '金塔型', '塔', '金字型', '比拉密德'),
           'piramides' => array('金字塔', '皮拉米德', '塔', '金塔', '皮拉密', '皮拉密德', '皮拉米', '皮拉米德斯', '金字塔型', '金塔形'),
           'gran toro' => array('大托罗', '大公牛', '巨型托罗', '格兰托罗', '大型托罗', '格兰托鲁', '巨托罗', '大托鲁', '特大托罗', '特大公牛'),
           'perfecto' => array('完美', '珀费托', '双头', '双头锥', '双头雪茄', '双头型', '完美型', '双锥', '珀费克托', '完善'),
           'double corona' => array('双皇冠', '双科罗那', '双皇', '双冠', '双克罗那', '双科罗娜', '双克罗娜', '双重皇冠', '双重科罗那', '双重科罗娜'),
           'culebra' => array('盘蛇', '麻花雪茄', '库莱伯拉', '三头雪茄', '曲线', '蛇型', '盘绕', '库列布拉', '麻花', '蛇形'),
           'panetela' => array('帕内特拉', '长宾丽', '宾丽', '细长型', '帕尼特拉', '帕尼丽', '帕内特', '帕尼特', '宾利', '长宾利'),
           'gran panetela' => array('巨型宾丽', '大帕内特拉', '大宾丽', '格兰帕尼特拉', '巨宾丽', '大帕尼特拉', '大宾利', '格兰帕内特拉', '大型帕内特拉', '大型宾丽'),
           'lonsdale' => array('朗斯代尔', '长秀丽', '隆斯代尔', '朗', '朗思代尔', '朗斯台尔', '隆斯台尔', '朗斯达尔', '隆斯达尔', '朗斯戴尔'),
           'rothschild' => array('罗斯柴尔德', '洛芝', '罗斯切尔德', '罗斯', '罗子', '罗斯查尔德', '罗斯彻尔德', '洛芝尔德', '罗斯柴', '罗斯切'),
           'petit' => array('小型', '小号', '小', '迷你', '贝蒂', '佩蒂', '迷你型', '微型', '佩提', '贝提'),
           'short' => array('短', '矮', '短号', '短款', '肖特', '短型', '短小', '矮型', '矮小', '短体'),
           'gordo' => array('胖皇冠', '胖皇', '戈尔多', '胖', '戈多', '胖型', '肥', '宽', '厚', '胖款'),
           'presidente' => array('总统', '普雷西登特', '总裁', '主席', '总', '普雷', '总统型', '总裁型', '主席型', '普雷西'),
           'corona gorda' => array('皇冠戈达', '胖皇冠', '科罗娜戈达', '胖科罗那', '科达', '胖冠', '皇冠胖', '科罗那胖', '戈达冠', '戈达科罗那'),
           'hermoso' => array('美丽', '埃尔莫索', '赫莫索', '秀丽', '漂亮', '艾尔莫索', '赫尔莫索', '赫莫', '艾莫索', '赫莫'),
           'demi tasse' => array('小杯', '半杯', '德米塔斯', '小咖啡', '迷你杯', '德米', '半咖啡', '小塔斯', '德米塔', '塔斯'),
           'julieta' => array('朱丽叶', '胡丽塔', '朱丽', '胡莉亚', '如利特', '朱利叶', '尤利特', '尤莉特', '裘利塔', '朱利'),
           'gran corona' => array('大皇冠', '格兰科罗那', '大科罗那', '大克罗那', '大冠', '大皇', '格兰冠', '特大皇冠', '特大科罗那', '特大冠'),
           'magnum' => array('大皇冠', '麦格纳姆', '麦格纽姆', '马格南', '麦格龙', '马格农', '麦格南', '大口径', '马格侬', '麦格尼姆'),
           'cazadores' => array('猎人', '卡萨多雷斯', '卡扎多雷斯', '猎手', '猎者', '卡萨', '卡扎', '猎人型', '卡萨多', '卡扎多'),
           'exquisitos' => array('精品', '吉士图', '吉时途', '埃克斯奎西托斯', '精致', '极品', '吉士', '精美', '埃克斯奎', '埃斯奎'),
           'secretos' => array('秘密', '奥秘', '塞克雷托斯', '秘', '隐秘', '塞克雷', '塞克', '秘藏', '隐', '奥'),
           'genios' => array('天才', '杰尼奥斯', '吉尼奥斯', '天资', '精灵', '天赋', '天分', '杰尼', '吉尼', '天才型'),
           'nobles' => array('贵族', '诺布雷斯', '贵', '高尚', '尊贵', '诺布', '诺布尔', '贵人', '贵胄', '贵族型'),
           'dianas' => array('戴安娜', '黛安娜', '戴', '黛', '狄安娜', '戴安', '黛安', '狄安', '戴安那', '黛安那'),
           'siglo' => array('世纪', '西格鲁', '西格洛', '世纪', 'sig', '西格', '西格罗', '世', '西', '纪'),
           'behike' => array('贝希克', '贝依可', '比海客', 'BHK', '贝黑克', '贝海克', '比依克', '贝克', '贝依克', '比黑克'),
           'edmundo' => array('艾德蒙多', '爱德蒙多', '埃德蒙多', '艾蒙多', '爱蒙多', '埃蒙多', '艾德蒙', '爱德蒙', '埃德蒙', '艾德'),
           'petit edmundo' => array('小艾德蒙多', '小爱德蒙多', '迷你艾德蒙多', '小埃德蒙多', '迷你爱德蒙多', '迷你埃德蒙多', '小艾蒙多', '小爱蒙多', '小埃蒙多', '小型艾德蒙多'),
           'double' => array('双', '双倍', '双重', '两倍', '两个', '双份', '两份', '成双', '加倍', '双份'),
           'miniatures' => array('迷你', '小型', '微型', '小小', '最小', '迷你型', '微型版', '小型版', '小巧', '小款'),
           'perla' => array('珍珠', '帕拉', '佩尔拉', '宝珠', '明珠', '珠', '小珠', '帕尔', '佩尔', '珍'),
           'dalia' => array('大丽花', '达利亚', '达丽亚', '大莉亚', '达利花', '达丽花', '达花', '达莉亚', '大利亚', '大利花'),
           'mareva' => array('马里瓦', '玛莱瓦', '马雷瓦', '玛丽瓦', '马丽瓦', '玛雷瓦', '马雷娃', '玛莱娃', '马里娃', '玛丽娃'),
           'gran edmundo' => array('大埃德蒙多', '大艾德蒙多', '格兰艾德蒙多', '大爱德蒙多', '格兰埃德蒙多', '格兰爱德蒙多', '大型艾德蒙多', '大型埃德蒙多', '大型爱德蒙多', '特大艾德蒙多'),
           'duke' => array('公爵', '杜克', '爵士', '公', '爵', '杜', '杜克爵士', '杜克公爵', '公爵型', '爵士型'),
           'prominente' => array('突出', '杰出', '普罗米内特', '卓越', '显著', '突显', '卓著', '特出', '出众', '杰超'),
           'petit pyramid' => array('小金字塔', '迷你金字塔', '小塔', '迷你塔', '小金塔', '迷你金塔', '小型金字塔', '迷你型金字塔', '小型塔', '迷你型塔'),
           'half corona' => array('半皇冠', '半科罗那', '半冠', '半皇', '半科', '半克罗那', '半科罗娜', '半克罗娜', '半型皇冠', '半型科罗那'),
           'petit belicoso' => array('小比利高', '小彪丽高', '迷你鱼雷', '小鱼雷', '迷你比利高', '迷你彪丽高', '小比利', '小贝利高', '迷你比利', '迷你贝利高'),
          'gran belicoso' => array('大比利高', '大彪丽高', '大鱼雷', '大型比利高', '大型彪丽高', '大型鱼雷', '格兰比利高', '格兰彪丽高', '格兰鱼雷', '特大比利高'),
            'club' => array('俱乐部', '会所', '团体', '小会', '俱乐', '会所型', '俱乐部型', '会', '会员', '团'),
            'minuto' => array('分钟', '米努托', '迷你托', '分', '米努', '微托', '迷你', '迷', '分钟型', '米型'),
            'media corona' => array('中皇冠', '中科罗那', '中冠', '中皇', '中科', '中克罗那', '中科罗娜', '中克罗娜', '中型皇冠', '中型科罗那'),
            'super corona' => array('超级皇冠', '超级科罗那', '超级冠', '超皇冠', '超科罗那', '超冠', '超皇', '超科', '超克罗那', '超科罗娜'),
            'wide churchill' => array('宽丘吉尔', '宽丘', '胖丘吉尔', '宽邱吉尔', '胖邱吉尔', '宽丘切尔', '胖丘切尔', '宽型丘吉尔', '胖型丘吉尔', '宽大丘吉尔'),
            'petit churchill' => array('小丘吉尔', '小丘', '迷你丘吉尔', '小邱吉尔', '迷你邱吉尔', '小丘切尔', '迷你丘切尔', '小型丘吉尔', '迷你型丘吉尔', '小巧丘吉尔'),
            'robustos extra' => array('特级罗布图', '额外罗布托', '特罗布图', '特级罗布托', '额外罗布图', '特罗布托', '特级罗伯图', '额外罗伯图', '特罗伯图', '特级罗拔图'),
            'short robusto' => array('短罗布图', '短罗布托', '短罗布', '短型罗布图', '短型罗布托', '短型罗布', '矮罗布图', '矮罗布托', '矮罗布', '短式罗布图'),
            'robusto supremo' => array('至尊罗布图', '至上罗布图', '罗布图至尊', '至尊罗布托', '至上罗布托', '罗布托至尊', '至尊罗伯图', '至上罗伯图', '罗伯图至尊', '至尊罗拔图'),
            'double toro' => array('双托罗', '双公牛', '双托', '双重托罗', '双重公牛', '双重托', '双份托罗', '双份公牛', '双份托', '双式托罗'),
            'churchill tubos' => array('丘吉尔管装', '丘吉尔铝管', '管装丘吉尔', '丘管装', '丘铝管', '管装丘', '邱吉尔管装', '邱吉尔铝管', '管装邱吉尔', '丘切尔管装'),
            'gordito' => array('小胖子', '小戈多', '戈迪托', '小胖', '小厚', '小宽', '小肥', '小戈多型', '戈迪型', '小胖型'),
            'corona extra' => array('特级皇冠', '皇冠特级', '额外皇冠', '特制皇冠', '皇冠特制', '额外科罗那', '特级科罗那', '科罗那特级', '额外冠', '特级冠'),
            'grand corona' => array('超大皇冠', '特大冠', '巨皇冠', '超级皇冠', '特大皇冠', '巨大皇冠', '超大科罗那', '特大科罗那', '巨科罗那', '超级科罗那'),
            'double perfecto' => array('双完美', '双珀费托', '双双头', '双重完美', '双重珀费托', '双重双头', '双份完美', '双份珀费托', '双份双头', '双式完美'),
            'short torpedo' => array('短鱼雷', '短雷', '短托比多', '短型鱼雷', '短型雷', '短型托比多', '矮鱼雷', '矮雷', '矮托比多', '短式鱼雷'),
            'long corona' => array('长皇冠', '长科罗那', '长冠', '长型皇冠', '长型科罗那', '长型冠', '细长皇冠', '细长科罗那', '细长冠', '长式皇冠'),
            'torpedo tubos' => array('鱼雷管装', '托皮多管', '鱼雷铝管', '管装鱼雷', '托皮多铝管', '管装托皮多', '雷管装', '雷铝管', '管装雷', '托比多管装'),
            'toro gordo' => array('胖公牛', '胖托罗', '戈多托罗', '胖型公牛', '胖型托罗', '戈多型托罗', '肥托罗', '肥公牛', '宽托罗', '宽公牛'),
            'gran piramide' => array('大金字塔', '大塔', '大金塔', '大型金字塔', '大型塔', '大型金塔', '格兰金字塔', '格兰塔', '格兰金塔', '特大金字塔'),
            'petit lancero' => array('小长矛', '小兰塞罗', '迷你长矛', '小型长矛', '小型兰塞罗', '迷你型长矛', '迷你兰塞罗', '短长矛', '短兰塞罗', '小矛'),
            'gran toro tubos' => array('大托罗管装', '大公牛铝管', '托罗特级管', '大托罗铝管', '大公牛管装', '托罗特级铝管', '管装大托罗', '管装大公牛', '铝管大托罗', '铝管大公牛'),
            'figurado' => array('异形', '非标准形', '菲古拉多', '变形', '造型', '非典型', '特殊形', '非常规', '不规则', '造型型'),
            'petit perfecto' => array('小完美', '小双头', '迷你完美', '小型完美', '小型双头', '迷你型完美', '迷你双头', '小珀费托', '迷你珀费托', '小型珀费托'),
            'robusto gordo' => array('胖罗布图', '厚罗布图', '戈多罗布图', '胖型罗布图', '厚型罗布图', '戈多型罗布图', '胖罗布托', '厚罗布托', '戈多罗布托', '肥罗布图'),
            'fuma' => array('福玛', '短小型', '芙玛', '呋玛', '福', '芙', '呋', '福马', '芙马', '呋马'),
            'gran churchill' => array('大丘吉尔', '特大丘', '丘吉尔特大', '大型丘吉尔', '特大型丘', '丘吉尔特大型', '格兰丘吉尔', '格兰丘', '丘吉尔格兰', '巨丘吉尔'),
            'salomon' => array('所罗门', '萨洛蒙', '所罗门王', '所罗', '萨洛', '所罗王', '所王', '萨王', '所罗门型', '萨洛蒙型'),
            'petit salomon' => array('小所罗门', '迷你所罗门', '小萨洛蒙', '小型所罗门', '迷你型所罗门', '小型萨洛蒙', '迷你萨洛蒙', '小所罗', '迷你所罗', '小萨洛'),
            'diademas' => array('皇冠珠', '戴德玛', '钢盔', '皇冠', '戴德', '钢', '戴德玛斯', '皇冠珠型', '戴德玛型', '钢盔型'),
            
            // Additional small vitolas (ring gauge under 40)
            'mille fleurs' => array('千花', '米勒弗勒', '米勒福勒', '千朵花', '米尔福罗雷', '米勒福洛尔', '米尔弗勒尔', '千花型', '米勒', '千朵'),
            'demi tasse' => array('小杯', '半杯', '德米塔斯', '小咖啡', '迷你杯', '德米', '塔塞', '半塔斯', '小塔斯', '德米塔'),
            'tres petit corona' => array('极小皇冠', '超小科罗那', '三小冠', '特小皇冠', '特小科罗那', '极小科罗那', '三小皇冠', '超小皇冠', '极小冠', '特小冠'),
            'entreacto' => array('幕间', '幕中', '场间', '场中', '幕间曲', '场间曲', '曲间', '曲中', '中场', '间幕'),
            'purito' => array('小纯', '普里托', '纯小', '纯粹型', '小而纯', '纯型', '小纯型', '迷你纯', '普型', '迷你普里托'),
            'cigarillo' => array('小雪茄', '迷你雪茄', '小型雪茄', '小烟', '迷你烟', '小型烟', '小雪', '迷你雪', '小型雪', '微型雪茄'),
            'pequeño' => array('佩奎尼奥', '佩克尼奥', '小型', '极小', '超小', '迷你', '微型', '小巧', '迷你型', '小款'),
            'demitasse' => array('半杯', '小杯', '德米塔斯', '德米', '半咖啡', '小咖啡', '半塔', '小塔', '德米半', '塔斯'),
            'palmas' => array('棕榈', '帕尔玛斯', '棕叶', '帕尔马', '棕榈型', '帕尔玛型', '棕榈形', '帕尔玛形', '棕叶型', '帕尔马型'),
            'marevas' => array('马雷瓦斯', '马雷瓦', '玛莱瓦斯', '玛莱瓦', '玛蕾瓦', '马蕾瓦', '玛雷瓦', '玛雷瓦斯', '马丽瓦', '马丽瓦斯'),
            'panatelas' => array('帕纳特拉斯', '帕内特拉斯', '长宾丽', '宾丽', '细长型', '帕尼特拉斯', '帕尼丽', '帕纳特', '帕内特', '帕尼特'),
            'small club' => array('小俱乐部', '小会所', '小团体', '小小会', '小俱乐', '小会所型', '小俱乐部型', '小会', '小会员', '小团'),
            
            // Additional popular non-Cuban formats
            'sixty' => array('六十', '60号', '六零', '陆零', '陆拾', '六拾', '60环', '六十号', '六十环', '60'),
            'gordo extra' => array('特级胖', '额外胖', '特胖', '特级戈尔多', '额外戈尔多', '特戈尔多', '特级肥', '额外肥', '特肥', '特级宽'),
            'presidente tubos' => array('总统管装', '总裁铝管', '主席特级管', '总统铝管', '总裁管装', '主席特级铝管', '管装总统', '管装总裁', '铝管总统', '铝管总裁'),
            'box-pressed' => array('方压', '盒压', '压盒', '方形压制', '盒状压制', '压制盒状', '方型', '盒型', '压方', '方压式'),
            'petit robusto' => array('小罗布图', '小罗布托', '迷你罗布图', '小型罗布图', '小型罗布托', '迷你型罗布图', '迷你罗布托', '小罗伯图', '迷你罗伯图', '小型罗伯图'),
            'mega robusto' => array('巨型罗布图', '超大罗布托', '特大罗布图', '巨型罗布托', '超大罗布图', '特大罗布托', '巨罗布图', '超罗布托', '特罗布图', '巨罗布托'),
            'churchill maduro' => array('丘吉尔马杜罗', '丘马杜罗', '邱吉尔马杜罗', '丘切尔马杜罗', '丘丘马杜罗', '邱丘马杜罗', '丘丘尔马杜罗', '丘尔切马杜罗', '丘奇尔马杜罗', '邱切尔马杜罗'),
            'robusto maduro' => array('罗布图马杜罗', '罗伯图马杜罗', '罗拔图马杜罗', '罗布斯托马杜罗', '罗布托马杜罗', '罗布马杜罗', '劳伯图马杜罗', '罗布图斯马杜罗', '罗伯图斯马杜罗', '罗普图马杜罗'),
            'toro maduro' => array('托罗马杜罗', '公牛马杜罗', '多罗马杜罗', '托洛马杜罗', '多洛马杜罗', '托鲁马杜罗', '多鲁马杜罗', '特罗马杜罗', '特洛马杜罗', '特鲁马杜罗'),
            'torpedo maduro' => array('鱼雷马杜罗', '托皮多马杜罗', '鱼型马杜罗', '雷马杜罗', '托比多马杜罗', '托皮铎马杜罗', '托比铎马杜罗', '鱼形马杜罗', '鱼雷型马杜罗', '雷形马杜罗'),
            'robusto claros' => array('罗布图光', '罗伯图光', '罗拔图光', '罗布斯托光', '罗布托光', '罗布光', '劳伯图光', '罗布图斯光', '罗伯图斯光', '罗普图光'),
            'nub' => array('纳布', '短粗', '短宽', '纳伯', '小粗', '粗短', '宽短', 'nab', '纳', '小肥'),
            'petit toro' => array('小托罗', '小公牛', '迷你托罗', '小型托罗', '小型公牛', '迷你型托罗', '迷你公牛', '小多罗', '迷你多罗', '小型多罗'),
            'long toro' => array('长托罗', '长公牛', '长托', '长型托罗', '长型公牛', '长型托', '细长托罗', '细长公牛', '细长托', '长式托罗'),
            'extra toro' => array('特级托罗', '额外托罗', '特托罗', '特级公牛', '额外公牛', '特公牛', '特级托', '额外托', '特托', '特级多罗'),
            'gran corona tubos' => array('大皇冠管装', '格兰科罗那铝管', '大科罗那特级管', '大皇冠铝管', '格兰科罗那管装', '大科罗那特级铝管', '管装大皇冠', '管装格兰科罗那', '铝管大皇冠', '铝管格兰科罗那')
        );
    }
    
    /**
     * Enhanced special edition terms and series mapping
     */
    public static function get_special_mappings() {
        return array(
            // Model patterns with specific regex for series identification
            'model_patterns' => array(
                // Siglo patterns for Cohiba
                '世纪[一1](?:号)?|西格鲁[一1](?:号)?|Siglo\s*[iI]' => 'Siglo I',
                '世纪[二2](?:号)?|西格鲁[二2](?:号)?|Siglo\s*[iI][iI]' => 'Siglo II',
                '世纪[三3](?:号)?|西格鲁[三3](?:号)?|Siglo\s*[iI][iI][iI]' => 'Siglo III',
                '世纪[四4](?:号)?|西格鲁[四4](?:号)?|Siglo\s*[iI][vV]' => 'Siglo IV',
                '世纪[五5](?:号)?|西格鲁[五5](?:号)?|Siglo\s*[vV]' => 'Siglo V',
                '世纪[六6](?:号)?|西格鲁[六6](?:号)?|Siglo\s*[vV][iI]' => 'Siglo VI',
                '半世纪|Medio\s*Siglo' => 'Medio Siglo',
                
                // Churchill variants
                '(?:长|短|小|宽)[\s]*丘吉尔' => '$1 Churchill',
                '长[\s]*丘[^吉]' => 'Churchill',
                '短[\s]*丘[^吉]' => 'Short Churchill',
                '小[\s]*丘[^吉]' => 'Petit Churchill',
                '宽[\s]*丘[^吉]' => 'Wide Churchill',
                
                // Edmundo variants
                '小[\s]*艾德蒙多|小[\s]*爱德蒙多|小[\s]*埃德蒙多' => 'Petit Edmundo',
                '大[\s]*艾德蒙多|大[\s]*爱德蒙多|大[\s]*埃德蒙多' => 'Gran Edmundo',
                '双[\s]*艾德蒙多|双[\s]*爱德蒙多|双[\s]*埃德蒙多' => 'Double Edmundo',
                
                // Roman numerals and series designations
                'No\.\s*([1-9])|#([1-9])|([1-9])号' => 'No. $1$2$3',
                '#([1-9])号?' => 'No. $1',
                
                // Series letters
                'Serie\s*([DPE])\s*No\.\s*([1-9])' => 'Serie $1 No.$2',
                '([DPE])系列\s*([1-9])(?:号)?' => 'Serie $1 No.$2',
                '([DPE])\s*([1-9])' => 'Serie $1 No.$2',
                
                // Brand-specific patterns - Cohiba Behike
                'BHK\s*#?\s*(\d+)' => 'Behike $1',
                '贝希克\s*(\d+)' => 'Behike $1',
                '贝依可\s*(\d+)' => 'Behike $1',
                '比海客\s*(\d+)' => 'Behike $1',
                '贝黑克\s*(\d+)' => 'Behike $1',
                '贝海克\s*(\d+)' => 'Behike $1',
                '比依克\s*(\d+)' => 'Behike $1',
                
                // Common number designations
                'VF\s*(\d+)' => 'VF$1',
                'D\s*(?:No\.)?\s*(\d+)' => 'D$1',
                '([1-9])\s*号' => 'No. $1',
                
                // Anniversary patterns
                '(\d{1,3})[\s]*周年|(\d{1,3})[\s]*週年|(\d{1,3})[\s]*年(?:周年)?' => '$1$2$3th Anniversary',
                '(\d{1,3})[\s]*Anniversary' => '$1th Anniversary',
                
                // Specific series identification
                '小鱼雷' => 'Petit Belicosos',
                '短鱼雷' => 'Short Piramides',
                '大天才' => 'Genios',
                '中天才' => 'Magicos',
                '小天才' => 'Secretos',
                '特级鱼雷' => 'Piramides Extra',
                '黄金系列' => 'Linea Oro',
                '金系列' => 'Linea Oro',
                '1935[\s]*传奇' => '1935 Leyenda',
                '1935[\s]*杜马' => '1935 Dumas',
                '1935[\s]*马尔特斯' => '1935 Maltes',
                
                // Year and edition matching
                '(19|20)(\d{2})[\s]*限量版?' => '$1$2 Limited Edition',
                
                // Chinese zodiac years
                '虎年[\s]*限量版?' => 'Year Of The Tiger',
                '龙年[\s]*限量版?' => 'Year Of The Dragon',
                '兔年[\s]*限量版?' => 'Year Of The Rabbit',
                '蛇年[\s]*限量版?' => 'Year Of The Snake',
                '马年[\s]*限量版?' => 'Year Of The Horse',
                '羊年[\s]*限量版?' => 'Year Of The Sheep',
                '猴年[\s]*限量版?' => 'Year Of The Monkey',
                '鸡年[\s]*限量版?' => 'Year Of The Rooster',
                '狗年[\s]*限量版?' => 'Year Of The Dog',
                '猪年[\s]*限量版?' => 'Year Of The Pig',
                '鼠年[\s]*限量版?' => 'Year Of The Rat',
                '牛年[\s]*限量版?' => 'Year Of The Ox',
                
                // Davidoff patterns with complete Chinese series names
                '大卫杜夫[\s]*([白黑黄金银])(?:色|牌)' => 'Davidoff $1 Band',
                '大卫杜夫[\s]*白牌' => 'Davidoff White Label',
                '大卫杜夫[\s]*黑牌' => 'Davidoff Black Label',
                '大卫杜夫[\s]*金牌' => 'Davidoff Gold Label',
                '大卫杜夫[\s]*银牌' => 'Davidoff Silver Label',
                '大卫杜夫[\s]*尼加拉瓜' => 'Davidoff Nicaragua',
                '大卫杜夫[\s]*尼加拉瓜[\s]*10[\s]*周年' => 'Davidoff Nicaragua 10th Anniversary',
                '大卫杜夫[\s]*亚玛撒' => 'Davidoff Yamasa',
                '大卫杜夫[\s]*雅玛莎' => 'Davidoff Yamasa',
                '大卫杜夫[\s]*亚玛撒系列' => 'Davidoff Yamasa Series',
                '大卫杜夫[\s]*艾斯库里奥' => 'Davidoff Escurio',
                '大卫杜夫[\s]*艾斯库里奥系列' => 'Davidoff Escurio Series',
                '大卫杜夫[\s]*温斯顿丘吉尔' => 'Davidoff Winston Churchill',
                '大卫杜夫[\s]*温斯顿·丘吉尔' => 'Davidoff Winston Churchill',
                '大卫杜夫[\s]*丘吉尔' => 'Davidoff Churchill',
                '大卫杜夫[\s]*温斯顿丘吉尔[\s]*经典系列' => 'Davidoff Winston Churchill Original',
                '大卫杜夫[\s]*温斯顿·丘吉尔[\s]*经典系列' => 'Davidoff Winston Churchill Original',
                '大卫杜夫[\s]*至暗时刻' => 'Davidoff The Late Hour',
                '大卫杜夫[\s]*温斯顿丘吉尔[\s]*至暗时刻' => 'Davidoff Winston Churchill The Late Hour',
                '大卫杜夫[\s]*温斯顿·丘吉尔[\s]*至暗时刻' => 'Davidoff Winston Churchill The Late Hour',
                '大卫杜夫[\s]*皇室' => 'Davidoff Royal',
                '大卫杜夫[\s]*皇家系列' => 'Davidoff Royal Series',
                '大卫杜夫[\s]*702[\s]*系列' => 'Davidoff 702 Series',
                '大卫杜夫[\s]*702[\s]*署名' => 'Davidoff 702 Signature',
                '大卫杜夫[\s]*702[\s]*系列[\s]*署名[\s]*2000' => 'Davidoff 702 Series Signature 2000',
                '大卫杜夫[\s]*702[\s]*系列[\s]*特制[\s]*硬汉' => 'Davidoff 702 Series Special R',
                '大卫杜夫[\s]*702[\s]*系列[\s]*特制[\s]*鱼雷' => 'Davidoff 702 Series Special T',
                '大卫杜夫[\s]*702[\s]*系列[\s]*双[\s]*硬汉' => 'Davidoff 702 Series Double R',
                '大卫杜夫[\s]*702[\s]*系列[\s]*3[\s]*号' => 'Davidoff 702 Series No. 3',
                '大卫杜夫[\s]*经典系列' => 'Davidoff Signature Series',
                '大卫杜夫[\s]*白茄标系列' => 'Davidoff White Label Series',
                '大卫杜夫[\s]*经典[\s]*2000' => 'Davidoff Signature 2000',
                '大卫杜夫[\s]*格兰高' => 'Davidoff Grand Cru',
                '大卫杜夫[\s]*格兰高系列' => 'Davidoff Grand Cru Series',
                '大卫杜夫[\s]*千禧' => 'Davidoff Millennium',
                '大卫杜夫[\s]*千禧系列' => 'Davidoff Millennium Series',
                '大卫杜夫[\s]*黑茄标系列' => 'Davidoff Black Label Series',
                '大卫杜夫[\s]*片刻享受' => 'Davidoff Primeros',
                '大卫杜夫[\s]*普利曼罗系列' => 'Davidoff Primeros Series',
                '大卫杜夫[\s]*小雪茄' => 'Davidoff Mini Cigarillos',
                '大卫杜夫[\s]*迷你雪茄' => 'Davidoff Mini Cigarillos',
                '大卫杜夫[\s]*马杜罗系列' => 'Davidoff Maduro Series',
               '大卫杜夫[\s]*周年庆典' => 'Davidoff Anniversary Series',
                '大卫杜夫[\s]*安妮女士' => 'Davidoff Aniversario',
                '大卫杜夫[\s]*安妮[\s]*特制' => 'Davidoff Aniversario Special R',
                '大卫杜夫[\s]*安妮[\s]*3号' => 'Davidoff Aniversario No. 3',
                '大卫杜夫[\s]*特级珍选' => 'Davidoff Special Selection',
                '大卫杜夫[\s]*特选' => 'Davidoff Special',
            ),
            
            // Special edition phrases
            'special_editions' => array(
                // Limited Editions
                'limited edition', '限量版', '限定版', '限量', '限定', '限制版', '限制', '限量发行', '限定发行', 
                'edición limitada', 'edition limitee', 'edicion limitada', 'limitada', 'limitee',
                
                // Regional Editions
                'regional edition', '区域版', '地区版', '专供', '区域专供', '地区专供', '区域限定', '地区限定',
                'edición regional', 'edition regionale', 'edicion regional', 'regional', 'regionale',
                
                // Travel Retail
                'travel retail', 'duty free', '免税', '旅行零售', '旅游版', '旅行版', '旅游零售', '免税店专供',
                'travel exclusive', '旅行专供', '旅游专供', '飞行员版', '机场版', '免税店版',
                
                // Special releases
                'special release', '特别版', '特殊版', '特制版', '特供', '特别发行', '特殊发行', '特制',
                'special edition', '特别版', '特殊版', '特制版', '特刊', '特别编辑', '特别版本',
                
                // Reserve
                'reserve', 'reserva', 'réserve', '珍藏', '储备', '保留', '珍品', '珍藏版', '典藏版',
                'gran reserva', 'grand reserve', 'reserva especial', '特别珍藏', '特级珍藏', '特珍',
                
                // Vintage and Aged
                'vintage', '年份', '陈年', '老酒', '陈酿', '年代', '年份版', '陈年版', '老酒版',
                'aged', '陈年', '老化', '老熟', '老陈', '陈放', '熟成', '年代', '年份',
                
                // Anniversaries and Celebrations
                'anniversary', '周年', '週年', '周年纪念', '週年纪念', '纪念', '周年庆', '週年庆', '纪念版',
                'jubilee', '禧年', '庆典', '庆祝', '欢庆', '禧庆', '礼盒', '礼品', '礼物',
                
                // Brand-specific editions
                'colección habanos', 'coleccion habanos', '哈瓦那珍藏', '哈瓦那收藏', '哈瓦那系列', '哈瓦那套装',
                'book series', '书本系列', '书籍系列', '书套装', '书本版', '书版', '书型', '书本型',
                'jar', '罐装', '陶罐', '瓶装', '罐子', '陶瓷罐', '瓦罐', '罐', '瓶', '瓷罐',
                
                // Year of productions
                'LE', 'EL', 'RE', 'ER', 'LCDH', 'FDC',
                
                // Chinese Zodiac
                '虎年', '龙年', '兔年', '蛇年', '马年', '羊年', '猴年', '鸡年', '狗年', '猪年', '鼠年', '牛年',
                'year of the tiger', 'year of the dragon', 'year of the rabbit', 'year of the snake',
                'year of the horse', 'year of the sheep', 'year of the goat', 'year of the monkey',
                'year of the rooster', 'year of the dog', 'year of the pig', 'year of the rat',
                'year of the ox',
                
                // Collector's items
                'collector', 'collection', '收藏', '收藏家', '收藏版', '珍藏版', '收藏家版', '典藏',
                'humidor', '雪茄盒', '保湿盒', '雪茄柜', '储藏盒', '雪茄箱', '保湿箱', '储藏箱',
                'book', '书', '书籍', '书本', '典籍', '图书', '书型', '书式', '书状',
                
                // Premium designations
                'premium', 'luxury', 'exclusive', 'elite', 'superior', 'supreme', 'ultimate', 'prestige',
                '高级', '奢华', '独家', '精英', '优质', '至尊', '极致', '威望',
                
                // Commemorative editions
                'commemorative', 'commemorative edition', 'memorial', 'memorial edition',
                '纪念', '纪念版', '纪念品', '纪念册', '纪念盒', '纪念套装', '纪念装', '纪念礼盒',
                
                // Band colors (Davidoff)
                'white label', 'white band', 'gold label', 'gold band', 'black label', 'black band',
                'silver label', 'silver band', 'blue label', 'blue band', 'red label', 'red band',
                '白牌', '白带', '金牌', '金带', '黑牌', '黑带', '银牌', '银带', '蓝牌', '蓝带', '红牌', '红带',
                
                // Partagas specific
                'serie D', 'serie E', 'serie P', 'serie C', 'series D', 'series E', 'series P', 'series C',
                'D系列', 'E系列', 'P系列', 'C系列', 'D号', 'E号', 'P号', 'C号'
            ),
            
            // Packaging terms
            'packaging_terms' => array(
                // Box types
                'wooden box', 'cabinet', 'dress box', 'varnished box', 'slide lid box', 'sbn', 'display cabinet',
                '木盒', '木箱', '礼盒', '原木盒', '漆盒', '推拉盖盒', '展示盒', '实木盒', '原装盒', '木箱',
                
                // Pack sizes and units
                'box of', 'pack of', 'set of', 'bundle of', 'brick of',
                '盒装', '包装', '套装', '捆', '砖',
                
                // Count indicators
                'pcs', 'count', 'cigars', 'sticks', 'pieces',
                '支', '只', '枝', '个', '根', '条', '片', '块',
                
                // Tube specifications
                'tubed', 'tubos', 'aluminum tube', 'metal tube', 'at',
                '管装', '铝管', '管装版', '金属管', '铝管装', '管包装',
                
                // Packaging styles
                'dress box', 'sbn', 'semi boite nature', 'boite nature', 'bn',
                '礼盒', '自然盒', '半自然盒', '自然木盒', '自然木箱',
                
                // Box patterns
                '8-9-8', '898', '8/9/8', '三层装', '三层', '8-9-8装', '8-9-8盒装',
                
                // Special packaging formats
                'jar', 'ceramic jar', 'book', 'humidor', 'travel humidor', 'acrylic jar',
                '罐', '瓶', '陶罐', '书', '保湿盒', '旅行保湿盒', '亚克力罐',
                
                // Pack specifications
                'single', 'bundle', 'box', 'pack', 'gift pack', 'sampler',
                '单支', '捆', '盒', '包', '礼品包', '样品装'
            ),
            
            // Count patterns
            'count_patterns' => array(
                // English count patterns
                '(\d+)[\s]*(?:ct|count|pcs|cigars|sticks|pieces)',
                'box[\s]*of[\s]*(\d+)',
                'pack[\s]*of[\s]*(\d+)',
                'set[\s]*of[\s]*(\d+)',
                'bundle[\s]*of[\s]*(\d+)',
                '(\d+)[\s]*-?pack',
                '(\d+)[\s]*-?box',
                '(\d+)[\s]*-?stick',
                '(\d+)[\s]*-?cigar',
                '(\d+)[\s]*-?count',
                
                // Chinese count patterns
                '(\d+)[\s]*[支只枝个根条片块]',
                '(\d+)[\s]*支装',
                '(\d+)[\s]*只装',
                '(\d+)[\s]*支盒装',
                '(\d+)[\s]*只盒装',
                '盒[\s]*(\d+)[\s]*支',
                '盒[\s]*(\d+)[\s]*只',
                '装[\s]*(\d+)[\s]*支',
                '装[\s]*(\d+)[\s]*只',
                '(\d+)[\s]*支[\s]*盒',
                '(\d+)[\s]*只[\s]*盒',
                '(\d+)[\s]*支[\s]*装',
                '(\d+)[\s]*只[\s]*装',
                '(\d+)[\s]*支[\s]*雪茄',
                '(\d+)[\s]*只[\s]*雪茄',
                '(\d+)[\s]*条装',
                '(\d+)[\s]*片装',
                '(\d+)[\s]*块装'
            ),
            
            // Size dimension patterns
            'dimension_patterns' => array(
                // Ring gauge patterns
                '(\d{2})[\s]*(?:环|环规|环号|环径|ring|ring\s*gauge|rg)',
                '(?:环|环规|环号|环径|ring|ring\s*gauge|rg)[\s]*(\d{2})',
                
                // Length patterns
                '(\d{1,3})[\s]*(?:mm|毫米|厘米|公分|cm)',
                '(?:mm|毫米|厘米|公分|cm)[\s]*(\d{1,3})',
                
                // Combined dimension patterns (length x ring gauge)
                '(\d{1,3})[\s]*[xX×][\s]*(\d{1,3})',
                '(\d{1,3})[\s]*[xX×][\s]*(\d{1,2})[\s]*(?:环|环规|环号|环径|ring|ring\s*gauge|rg)',
                '(\d{1,3})[\s]*(?:mm|毫米)[\s]*[xX×][\s]*(\d{1,2})[\s]*(?:环|环规|环号|环径|ring|ring\s*gauge|rg)',
                
                // Inch patterns
                '(\d+)[\s]?(?:\.|,)[\s]?(\d+)[\s]*(?:inches|inch|英寸|英吋|吋|寸)',
                
                // Numeric only patterns (when followed by known size identifiers)
                '(\d{1,3})[\s]*[xX×][\s]*(\d{1,2})[\s]+(?:robusto|toro|churchill|corona|torpedo|lancero|belicoso|pyramid|perfecto)',
                '(\d{1,3})[\s]*(?:mm|毫米)[\s]*[xX×][\s]*(\d{1,2})[\s]+(?:罗布图|罗布托|丘吉尔|皇冠|鱼雷|长矛|比利高|金字塔|完美)'
            ),
            
            // Common year patterns to match
            'year_patterns' => array(
                // Standard year formats
                '(?:year|yr|año)[\s]*(?:of)?[\s]*(?:production)?[\s]*(19\d{2}|20\d{2})',
                '(19\d{2}|20\d{2})[\s]*(?:year|yr|año)',
                
                // Chinese year patterns
                '(19\d{2}|20\d{2})[\s]*年[\s]*(?:份|产|制)?',
                '年[\s]*(?:份|产|制)?[\s]*(19\d{2}|20\d{2})',
                
                // Age statements
                '(\d{1,2})[\s]*(?:years|yrs|yr|年)[\s]*(?:old|aged)',
                '(?:aged|陈年)[\s]*(\d{1,2})[\s]*(?:years|yrs|yr|年)',
                
                // Special vintage indicators
                'vintage[\s]*(19\d{2}|20\d{2})',
                '(19\d{2}|20\d{2})[\s]*vintage',
                '陈年[\s]*(19\d{2}|20\d{2})',
                '(19\d{2}|20\d{2})[\s]*陈年',
                
                // Year ranges
                '(19\d{2}|20\d{2})[\s]*-[\s]*(19\d{2}|20\d{2})',
                
                // Anniversary editions
                '(\d{1,3})[\s]*(?:th|周年|週年|周年纪念|週年纪念|纪念|anniversary)',
                '(\d{1,3})[\s]*(?:th)?[\s]*(?:周年|週年|anniversary)'
            ),
            
            // Regional indicators and patterns
            'regional_mappings' => array(
                // Asia Pacific
                'asia pacific' => 'APAC',
                'asia' => 'Asia',
                'pacific' => 'Pacific',
                '亚太' => 'APAC',
                '亚洲' => 'Asia',
                '太平洋' => 'Pacific',
                
                // China and regions
                'china' => 'China',
                'chinese' => 'China',
                'hong kong' => 'Hong Kong',
                'macau' => 'Macau',
                'taiwan' => 'Taiwan',
                '中国' => 'China',
                '香港' => 'Hong Kong',
                '澳门' => 'Macau',
                '台湾' => 'Taiwan',
                
                // Europe
                'europe' => 'Europe',
                'european' => 'Europe',
                '欧洲' => 'Europe',
                
                // Specific European countries
                'uk' => 'UK',
                'england' => 'UK',
                'great britain' => 'UK',
                'united kingdom' => 'UK',
                'switzerland' => 'Switzerland',
                'swiss' => 'Switzerland',
                'france' => 'France',
                'french' => 'France',
                'germany' => 'Germany',
                'german' => 'Germany',
                'spain' => 'Spain',
                'spanish' => 'Spain',
                'italy' => 'Italy',
                'italian' => 'Italy',
                '英国' => 'UK',
                '瑞士' => 'Switzerland',
                '法国' => 'France',
                '德国' => 'Germany',
                '西班牙' => 'Spain',
                '意大利' => 'Italy',
                
                // Americas
                'americas' => 'Americas',
                'america' => 'Americas',
                'north america' => 'North America',
                'south america' => 'South America',
                'usa' => 'USA',
                'united states' => 'USA',
                'canada' => 'Canada',
                'mexico' => 'Mexico',
                'caribbean' => 'Caribbean',
                'cuba' => 'Cuba',
                '美洲' => 'Americas',
                '北美' => 'North America',
                '南美' => 'South America',
                '美国' => 'USA',
                '加拿大' => 'Canada',
                '墨西哥' => 'Mexico',
                '加勒比' => 'Caribbean',
                '古巴' => 'Cuba',
                
                // Middle East
                'middle east' => 'Middle East',
                'beirut' => 'Lebanon',
                'lebanon' => 'Lebanon',
                'uae' => 'UAE',
                'united arab emirates' => 'UAE',
                'dubai' => 'UAE',
                '中东' => 'Middle East',
                '贝鲁特' => 'Lebanon',
                '黎巴嫩' => 'Lebanon',
                '阿联酋' => 'UAE',
                '迪拜' => 'UAE',
                
                // La Casa del Habano
                'la casa del habano' => 'LCDH',
                'lcdh' => 'LCDH',
                'casa del habano' => 'LCDH',
                'casa habano' => 'LCDH',
                '哈瓦那之家' => 'LCDH',
                '哈瓦那雪茄店' => 'LCDH',
                
                // Duty Free
                'duty free' => 'Duty Free',
                'travel retail' => 'Duty Free',
                'airport' => 'Duty Free',
                '免税' => 'Duty Free',
                '免税店' => 'Duty Free',
                '机场' => 'Duty Free',
                '旅行零售' => 'Duty Free'
            )
        );
    }

    /**
     * Get categorized keywords for matching
     * Enhanced with smart categorization and normalized scoring
     */
    public static function get_categorized_keywords($product_name, $filter_common = true) {
        // Ensure we're working with a clean string
        $product_name = trim($product_name);
        
        if (empty($product_name)) {
            return array();
        }
        
        // Initialize categories
        $keywords = array(
            'brand' => array(),
            'model' => array(),
            'vitola' => array(),
            'dimensions' => array(),
            'special_edition' => array(),
            'year' => array(),
            'count' => array(),
            'packaging' => array(),
            'general' => array(),
            'regional' => array()
        );
        
        // Convert to lowercase for better matching
        $lowercase_name = mb_strtolower($product_name);
        
        // Extract brand keywords
        self::extract_brand_keywords($lowercase_name, $keywords);
        
        // Extract vitola (size) keywords
        self::extract_vitola_keywords($lowercase_name, $keywords);
        
        // Extract special edition keywords
        self::extract_special_edition_keywords($lowercase_name, $keywords);
        
        // Extract dimension patterns
        self::extract_dimension_patterns($lowercase_name, $keywords);
        
        // Extract year patterns
        self::extract_year_patterns($lowercase_name, $keywords);
        
        // Extract count patterns
        self::extract_count_patterns($lowercase_name, $keywords);
        
        // Extract packaging terms
        self::extract_packaging_terms($lowercase_name, $keywords);
        
        // Extract regional indicators
        self::extract_regional_indicators($lowercase_name, $keywords);
        
        // Extract remaining general keywords, filtering out common words
        self::extract_general_keywords($lowercase_name, $keywords, $filter_common);
        
        return $keywords;
    }

    /**
     * Extract brand keywords from product name
     */
    private static function extract_brand_keywords($product_name, &$keywords) {
        // Get all brand mappings
        $brand_mappings = array_merge(
            self::get_cuban_brand_mappings(),
            self::get_non_cuban_brand_mappings()
        );
        
        // Check each brand and its variations
        foreach ($brand_mappings as $brand => $variations) {
            // Check original brand name
            if (mb_stripos($product_name, $brand) !== false) {
                $keywords['brand'][] = strtolower($brand);
            }
            
            // Check each variation
            foreach ($variations as $variation) {
                if (mb_stripos($product_name, $variation) !== false) {
                    $keywords['brand'][] = strtolower($brand); // Store canonical brand name
                    break; // Found a match, no need to check more variations
                }
            }
        }
        
        // Remove duplicates
        $keywords['brand'] = array_unique($keywords['brand']);
    }

    /**
     * Extract vitola (size) keywords from product name
     */
    private static function extract_vitola_keywords($product_name, &$keywords) {
        // Get size mappings
        $size_mappings = self::get_size_mappings();
        
        // Check each size and its variations
        foreach ($size_mappings as $size => $variations) {
            // Check original size name
            if (mb_stripos($product_name, $size) !== false) {
                $keywords['vitola'][] = strtolower($size);
            }
            
            // Check each variation
            foreach ($variations as $variation) {
                if (mb_stripos($product_name, $variation) !== false) {
                    $keywords['vitola'][] = strtolower($size); // Store canonical size name
                    break; // Found a match, no need to check more variations
                }
            }
        }
        
        // Detect model patterns (special series designations)
        $model_patterns = self::get_special_mappings()['model_patterns'];
        foreach ($model_patterns as $pattern => $replacement) {
            if (preg_match('/' . $pattern . '/i', $product_name, $matches)) {
                // Use the pattern's canonical name
                $keywords['model'][] = strtolower(preg_replace('/' . $pattern . '/i', $replacement, $matches[0]));
            }
        }
        
        // Remove duplicates
        $keywords['vitola'] = array_unique($keywords['vitola']);
        $keywords['model'] = array_unique($keywords['model']);
    }
/**
 * Process supplier product for matching
 * Extracts and normalizes product data for better matching
 * 
 * @param string $product_title Product title or description
 * @param string $dimensions Optional dimension string
 * @return array Processed product data
 */
public static function process_supplier_product($product_title, $dimensions = '') {
    // Normalize title
    $normalized_title = self::normalize_product_name($product_title);
    
    // Extract brand
    $brand = self::extract_brand($normalized_title);
    
    // Get categorized keywords
    $keywords = self::get_categorized_keywords($normalized_title);
    
    // Add dimensions if provided
    if (!empty($dimensions) && empty($keywords['dimensions'])) {
        $keywords['dimensions'][] = $dimensions;
    }
    
    // Extract model/series if available
    $model = '';
    if (!empty($keywords['model'])) {
        $model = reset($keywords['model']);
    }
    
    // Extract vitola/size if available
    $vitola = '';
    if (!empty($keywords['vitola'])) {
        $vitola = reset($keywords['vitola']);
    }
    
    // Dimension information
    $dimension_info = array(
        'ring_gauge' => '',
        'length' => ''
    );
    
    // Try to extract ring gauge and length from dimensions
    if (!empty($keywords['dimensions'])) {
        $dim = reset($keywords['dimensions']);
        if (preg_match('/(\d+)[xX×](\d+)/', $dim, $matches)) {
            $dimension_info['length'] = $matches[1];
            $dimension_info['ring_gauge'] = $matches[2];
        }
    }
    
    // Return processed supplier product data
    return array(
        'title' => $product_title,
        'normalized_title' => $normalized_title,
        'brand' => $brand,
        'model' => $model,
        'vitola' => $vitola,
        'dimension_info' => $dimension_info,
        'keywords' => $keywords
    );
}

/**
 * Find best matches for a supplier product among internal products
 * 
 * @param array $processed_supplier Processed supplier product
 * @param array $transformed_internal Array of processed internal products
 * @param int $limit Maximum number of matches to return
 * @param bool $include_debug Whether to include debug info in the results
 * @return array Array of matches with scores
 */
public static function find_best_matches($processed_supplier, $transformed_internal, $limit = 3, $include_debug = false) {
    $matches = array();
    
    // Get supplier keywords
    $supplier_keywords = $processed_supplier['keywords'];
    
    // Process each internal product
    foreach ($transformed_internal as $internal_product) {
        // Get internal keywords
        $internal_keywords = isset($internal_product['keywords']) ? $internal_product['keywords'] : array();
        
        // Calculate match score
        $match_result = self::calculate_match_score($supplier_keywords, $internal_keywords);
        $score = $match_result['score'];
        
        // Determine match type based on score
        $match_type = 'No Match';
        if ($score >= 90) {
            $match_type = 'Exact Match';
        } else if ($score >= 75) {
            $match_type = 'Close Match';
        } else if ($score >= 60) {
            $match_type = 'Possible Match';
        }
        
        // Add to matches if it's not "No Match" or if we're including all matches
        if ($match_type != 'No Match') {
            $matches[] = array(
                'product' => $internal_product,
                'score' => $score,
                'match_type' => $match_type,
                'matched_terms' => $match_result['matched_keywords'],
                'debug_info' => $include_debug ? $match_result : null
            );
        }
    }
    
    // Sort matches by score (descending)
    usort($matches, function($a, $b) {
        return $b['score'] <=> $a['score'];
    });
    
    // Limit results
    return array_slice($matches, 0, $limit);
}

/**
 * Extract keywords from product name
 * This is a simpler version of get_categorized_keywords for direct keyword extraction
 * 
 * @param string $product_name Product name
 * @return array Array of extracted keywords
 */
public static function extract_keywords($product_name) {
    $keywords = array();
    
    // Normalize product name
    $normalized_name = self::normalize_product_name($product_name);
    
    // Split into words
    $words = preg_split('/\s+/', $normalized_name);
    
    // Filter out common words and very short words
    foreach ($words as $word) {
        $word = trim($word);
        
        // Skip very short words
        if (mb_strlen($word) < 2) {
            continue;
        }
        
        // Skip common filter words
        if (in_array($word, self::$common_filter_words)) {
            continue;
        }
        
        $keywords[] = $word;
    }
    
    // Remove duplicates
    return array_unique($keywords);
}
	
	
public static function process_internal_product($product_data) {
    // Initialize result structure
    $result = array(
        'title' => '',
        'product_code' => '',
        'normalized_title' => '',
        'brand' => '',
        'model' => '',
        'vitola' => '',
        'dimension_info' => array(
            'ring_gauge' => '',
            'length' => ''
        ),
        'keywords' => array()
    );
    
    // Handle object or array input
    if (is_object($product_data)) {
        // Convert object to array
        $product_data = (array)$product_data;
    } else if (!is_array($product_data)) {
        // Return empty result for invalid input
        return $result;
    }
    
    // Extract product title
    $title = '';
    if (isset($product_data['title'])) {
        $title = $product_data['title'];
    } else if (isset($product_data['product_title'])) {
        $title = $product_data['product_title'];
    } else if (isset($product_data['post_title'])) {
        $title = $product_data['post_title'];
    }
    
    // Set title and product code
    $result['title'] = $title;
    $result['product_code'] = isset($product_data['sku']) ? $product_data['sku'] : '';
    
    // Normalize title
    $result['normalized_title'] = self::normalize_product_name($title);
    
    // Extract brand
    $result['brand'] = isset($product_data['brand']) ? $product_data['brand'] : '';
    if (empty($result['brand'])) {
        $result['brand'] = self::extract_brand($result['normalized_title']);
    }
    
    // Get categorized keywords
    $result['keywords'] = self::get_categorized_keywords($result['normalized_title']);
    
    // Extract model/series if available
    if (!empty($result['keywords']['model'])) {
        $result['model'] = reset($result['keywords']['model']);
    }
    
    // Extract vitola/size if available
    if (!empty($result['keywords']['vitola'])) {
        $result['vitola'] = reset($result['keywords']['vitola']);
    }
    
    // Process dimensions
    $dimensions = '';
    if (isset($product_data['seat_row']) && isset($product_data['seat_number'])) {
        $dimensions = $product_data['seat_row'] . '/' . $product_data['seat_number'];
        
        // Add to dimension info
        $result['dimension_info']['ring_gauge'] = $product_data['seat_row'];
        $result['dimension_info']['length'] = $product_data['seat_number'];
        
        // Add to keywords if not already present
        if (empty($result['keywords']['dimensions'])) {
            $result['keywords']['dimensions'][] = $dimensions;
        }
    }
    
    return $result;
}
	
	
	
	
	
/**
 * Extract brand from a product name
 * Returns the most likely brand or empty string if no brand detected
 */
public static function extract_brand($product_name) {
    if (empty($product_name)) {
        return '';
    }
    
    // Normalize the product name
    $normalized_name = self::normalize_product_name($product_name);
    
    // Get brand mappings
    $brand_mappings = array_merge(
        self::get_cuban_brand_mappings(),
        self::get_non_cuban_brand_mappings()
    );
    
    // Try to find a brand match
    foreach ($brand_mappings as $brand => $variations) {
        // Check the main brand name
        if (mb_stripos($normalized_name, $brand) !== false) {
            return $brand;
        }
        
        // Check the variations
        foreach ($variations as $variation) {
            if (mb_stripos($normalized_name, $variation) !== false) {
                return $brand; // Return the canonical brand name
            }
        }
    }
    
    // No brand found
    return '';
}
	
	
	
	
    /**
     * Extract special edition keywords from product name
     */
    private static function extract_special_edition_keywords($product_name, &$keywords) {
        // Get special edition terms
        $special_editions = self::get_special_mappings()['special_editions'];
        
        // Check each special edition term
        foreach ($special_editions as $term) {
            if (mb_stripos($product_name, $term) !== false) {
                $keywords['special_edition'][] = strtolower($term);
            }
        }
        
        // Remove duplicates
        $keywords['special_edition'] = array_unique($keywords['special_edition']);
    }

    /**
     * Extract dimension patterns from product name
     */
    private static function extract_dimension_patterns($product_name, &$keywords) {
        // Get dimension patterns
        $dimension_patterns = self::get_special_mappings()['dimension_patterns'];
        
        // Check each dimension pattern
        foreach ($dimension_patterns as $pattern) {
            if (preg_match('/' . $pattern . '/i', $product_name, $matches)) {
                // Store the full match as a dimension
                if (count($matches) > 1) {
                    // For combined patterns, store as length x ring
                    if (isset($matches[1]) && isset($matches[2])) {
                        $keywords['dimensions'][] = $matches[1] . 'x' . $matches[2];
                    } else {
                        $keywords['dimensions'][] = $matches[0];
                    }
                } else {
                    $keywords['dimensions'][] = $matches[0];
                }
            }
        }
        
        // Remove duplicates
        $keywords['dimensions'] = array_unique($keywords['dimensions']);
    }

    /**
     * Extract year patterns from product name
     */
    private static function extract_year_patterns($product_name, &$keywords) {
        // Get year patterns
        $year_patterns = self::get_special_mappings()['year_patterns'];
        
        // Check each year pattern
        foreach ($year_patterns as $pattern) {
            if (preg_match('/' . $pattern . '/i', $product_name, $matches)) {
                // Store the year value (usually in capture group 1)
                if (isset($matches[1])) {
                    $keywords['year'][] = $matches[1];
                } else {
                    $keywords['year'][] = $matches[0];
                }
            }
        }
        
        // Remove duplicates
        $keywords['year'] = array_unique($keywords['year']);
    }

    /**
     * Extract count patterns from product name
     */
    private static function extract_count_patterns($product_name, &$keywords) {
        // Get count patterns
        $count_patterns = self::get_special_mappings()['count_patterns'];
        
        // Check each count pattern
        foreach ($count_patterns as $pattern) {
            if (preg_match('/' . $pattern . '/i', $product_name, $matches)) {
                // Store the count value (usually in capture group 1)
                if (isset($matches[1])) {
                    $keywords['count'][] = $matches[1];
                } else {
                    $keywords['count'][] = $matches[0];
                }
            }
        }
        
        // Remove duplicates
        $keywords['count'] = array_unique($keywords['count']);
    }

    /**
     * Extract packaging terms from product name
     */
    private static function extract_packaging_terms($product_name, &$keywords) {
        // Get packaging terms
        $packaging_terms = self::get_special_mappings()['packaging_terms'];
        
        // Check each packaging term
        foreach ($packaging_terms as $term) {
            if (mb_stripos($product_name, $term) !== false) {
                $keywords['packaging'][] = strtolower($term);
            }
        }
        
        // Remove duplicates
        $keywords['packaging'] = array_unique($keywords['packaging']);
    }

    /**
     * Extract regional indicators from product name
     */
    private static function extract_regional_indicators($product_name, &$keywords) {
        // Get regional mappings
        $regional_mappings = self::get_special_mappings()['regional_mappings'];
        
        // Check each regional term and its canonical equivalent
        foreach ($regional_mappings as $term => $canonical) {
            if (mb_stripos($product_name, $term) !== false) {
                $keywords['regional'][] = strtolower($canonical);
            }
        }
        
        // Remove duplicates
        $keywords['regional'] = array_unique($keywords['regional']);
    }

    /**
     * Extract general keywords from product name, filtering out common words
     */
    private static function extract_general_keywords($product_name, &$keywords, $filter_common) {
        // Split the product name into words
        $words = preg_split('/\s+/', $product_name);
        
        // Get common filter words to exclude
        $filter_words = $filter_common ? self::$common_filter_words : array();
        
        // Process each word
        foreach ($words as $word) {
            $word = trim($word);
            
            // Skip empty words or single letters/numbers
            if (empty($word) || mb_strlen($word) < 2) {
                continue;
            }
            
            // Skip words already categorized
            $skip = false;
            foreach ($keywords as $category => $terms) {
                if ($category == 'general') {
                    continue;
                }
                if (in_array(strtolower($word), array_map('strtolower', $terms))) {
                    $skip = true;
                    break;
                }
            }
            
            // Skip common filter words
            if (!$skip && !in_array(strtolower($word), array_map('strtolower', $filter_words))) {
                $keywords['general'][] = strtolower($word);
            }
        }
        
        // Remove duplicates
        $keywords['general'] = array_unique($keywords['general']);
    }

    /**
     * Calculate match score between supplier product and internal catalog item
     * Enhanced with smarter categorized keyword matching and scoring
     */
    public static function calculate_match_score($supplier_keywords, $internal_keywords) {
        // Initialize score and debug info
        $score = 0;
        $matched_keywords = array();
        $category_scores = array();
        
        // Define weights for different keyword categories
        $weights = array(
            'brand' => KT_CIGAR_WEIGHT_BRAND,           // Brand is most important
            'model' => KT_CIGAR_WEIGHT_MODEL,           // Series/Model is second
            'vitola' => KT_CIGAR_WEIGHT_VITOLA,         // Size/Vitola is third
            'dimensions' => KT_CIGAR_WEIGHT_DIMENSION,  // Dimensions are important
            'special_edition' => KT_CIGAR_WEIGHT_SPECIAL_EDITION, // Special editions
            'year' => KT_CIGAR_WEIGHT_YEAR,             // Year matching
            'count' => KT_CIGAR_WEIGHT_COUNT,           // Count matching
            'packaging' => KT_CIGAR_WEIGHT_PACKAGING,   // Packaging
            'general' => KT_CIGAR_WEIGHT_KEYWORDS,      // General keywords
            'regional' => KT_CIGAR_WEIGHT_REGIONAL      // Regional/distributor
        );
        
        // Total possible score (sum of weights)
        $max_score = array_sum($weights);
        
        // Process each category
        foreach ($weights as $category => $weight) {
            // Skip if either product has no keywords in this category
            if (empty($supplier_keywords[$category]) && empty($internal_keywords[$category])) {
                continue;
            }
            
            // Calculate category score based on keyword matches
            $category_score = self::calculate_category_score(
                $supplier_keywords[$category], 
                $internal_keywords[$category],
                $matched_keywords,
                $category
            );
            
            // Apply category weight
            $weighted_score = ($category_score * $weight);
            $score += $weighted_score;
// Store category score for debugging
            $category_scores[$category] = array(
                'raw_score' => $category_score,
                'weighted_score' => $weighted_score,
                'weight' => $weight
            );
        }
        
        // Calculate final percentage score (normalize to 0-100)
        $final_score = ($score / $max_score) * 100;
        
        // Return score and debug info
        return array(
            'score' => min(100, $final_score), // Cap at 100%
            'matched_keywords' => $matched_keywords,
            'category_scores' => $category_scores
        );
    }
    
    /**
     * Calculate match score for a specific keyword category
     */
    private static function calculate_category_score($supplier_keywords, $internal_keywords, &$matched_keywords, $category) {
        // Handle empty arrays
        if (empty($supplier_keywords) || empty($internal_keywords)) {
            return 0;
        }
        
        $matches = 0;
        $supplier_total = count($supplier_keywords);
        $internal_total = count($internal_keywords);
        
        // Check each supplier keyword against internal keywords
        foreach ($supplier_keywords as $supplier_keyword) {
            $found = false;
            
            // Direct match
            if (in_array($supplier_keyword, $internal_keywords)) {
                $matches++;
                $found = true;
                $matched_keywords[$category][] = $supplier_keyword;
            } 
            // Partial match (for longer keywords, like model names)
            else if ($category == 'model' || $category == 'general' || $category == 'special_edition') {
                foreach ($internal_keywords as $internal_keyword) {
                    // Check if supplier keyword contains internal keyword or vice versa
                    if (mb_strlen($supplier_keyword) > 3 && mb_strlen($internal_keyword) > 3) {
                        if (mb_stripos($supplier_keyword, $internal_keyword) !== false || 
                            mb_stripos($internal_keyword, $supplier_keyword) !== false) {
                            $matches += 0.7; // Partial match
                            $found = true;
                            $matched_keywords[$category][] = $supplier_keyword . ' ≈ ' . $internal_keyword;
                            break;
                        }
                    }
                }
            }
            
            // Special logic for dimensions - allow approximate matches
            if (!$found && $category == 'dimensions') {
                foreach ($internal_keywords as $internal_dimension) {
                    // Extract numeric values for comparison
                    if (preg_match('/(\d+)[\s]*[xX×][\s]*(\d+)/', $supplier_keyword, $supplier_parts) &&
                        preg_match('/(\d+)[\s]*[xX×][\s]*(\d+)/', $internal_dimension, $internal_parts)) {
                        
                        // Allow for small differences in dimensions (±2mm, ±1 ring gauge)
                        $length_diff = abs((int)$supplier_parts[1] - (int)$internal_parts[1]);
                        $gauge_diff = abs((int)$supplier_parts[2] - (int)$internal_parts[2]);
                        
                        if ($length_diff <= 2 && $gauge_diff <= 1) {
                            $matches += 0.8; // Close dimension match
                            $found = true;
                            $matched_keywords[$category][] = $supplier_keyword . ' ≈ ' . $internal_dimension;
                            break;
                        }
                    }
                }
            }
            
            // Special logic for count - allow exact matches only
            if (!$found && $category == 'count') {
                foreach ($internal_keywords as $internal_count) {
                    if ($supplier_keyword == $internal_count) {
                        $matches++;
                        $matched_keywords[$category][] = $supplier_keyword;
                        break;
                    }
                }
            }
        }
        
        // Calculate score based on matches relative to total keywords
        $max_count = max($supplier_total, $internal_total);
        $normalized_score = $max_count > 0 ? $matches / $max_count : 0;
        
        // Enhanced scoring for brand matches (if exact match, score higher)
        if ($category == 'brand' && $matches > 0) {
            // If all brand keywords match exactly, give perfect score
            if ($matches == $supplier_total && $matches == $internal_total) {
                $normalized_score = 1.0;
            } 
            // If at least one brand keyword matches, give at least 0.6
            else {
                $normalized_score = max($normalized_score, 0.6);
            }
        }
        
        return $normalized_score;
    }
    
    /**
     * Normalize product name for better matching
     * Cleans up special characters and standardizes format
     */
    public static function normalize_product_name($name) {
        if (empty($name)) {
            return '';
        }
        
        // Convert to lowercase
        $name = mb_strtolower(trim($name));
        
        // Replace common abbreviations
        $name = str_replace(
            array('ltd.', 'ltd', 'inc.', 'inc', 'co.', 'co', 'corp.', 'corp', '&amp;', '&nbsp;'),
            array('limited', 'limited', 'incorporated', 'incorporated', 'company', 'company', 'corporation', 'corporation', '&', ' '),
            $name
        );
        
        // Normalize spaces and punctuation
        $name = preg_replace('/\s+/', ' ', $name);
        $name = str_replace(
            array('_', '/', '\\', '|', '+', '*', '@', '#', '$', '%', '^', '(r)', '(tm)', '®', '™'),
            array(' ', ' ', ' ', ' ', ' plus ', ' ', ' at ', ' ', ' ', ' percent ', ' ', '', '', '', ''),
            $name
        );
        
        // Replace multiple spaces with a single space
        $name = preg_replace('/\s+/', ' ', $name);
        
        // Remove unnecessary parentheses content that relates to merchants/stock, preserve format identifiers
        $name = preg_replace('/\([^)]*(?:stock|quantity|left|remaining|avail|sold\s*out)[^)]*\)/i', '', $name);
        
        // Standardize common cigar keywords
        $replacements = array(
            // Brand standardization
            'Montecristo' => 'monte cristo',
            'Monte-Cristo' => 'monte cristo',
            'Romeo Y Julieta' => 'romeo y julieta',
            'Romeo&Julieta' => 'romeo y julieta',
            'Romeo and Julieta' => 'romeo y julieta',
            'R y J' => 'romeo y julieta',
            'R&J' => 'romeo y julieta',
            'H. Upmann' => 'h upmann',
            'H&Upmann' => 'h upmann',
            'H Upmann' => 'h upmann',
            'Hoyo De Monterrey' => 'hoyo de monterrey',
            'HDM' => 'hoyo de monterrey',
            'Hoyo' => 'hoyo de monterrey',
            
            // Size standardization
            'Robusto' => 'robusto',
            'Robustos' => 'robusto',
            'Toro' => 'toro',
            'Toros' => 'toro',
            'Churchill' => 'churchill',
            'Churchills' => 'churchill',
            'Corona' => 'corona',
            'Coronas' => 'corona',
            'Torpedo' => 'torpedo',
            'Torpedos' => 'torpedo',
            'Belicoso' => 'belicoso',
            'Belicosos' => 'belicoso',
            'Presidente' => 'presidente',
            'Presidentes' => 'presidente',
            'Lancero' => 'lancero',
            'Lanceros' => 'lancero',
            'Gordo' => 'gordo',
            'Gordos' => 'gordo',
            'Petit Corona' => 'petit corona',
            'Petit Coronas' => 'petit corona',
            
            // Packaging standardization
            'Box of' => '',
            'Pack of' => '',
            'Set of' => '',
            'Count:' => '',
            'Count of' => '',
            'Wooden Box' => 'box',
            'Wood Box' => 'box',
            'Cabinet' => 'cab',
            'Box-Pressed' => 'box pressed',
            
            // Other common normalizations
            'Limited Edition' => 'limited edition',
            'Limited Ed' => 'limited edition',
            'Ltd Ed' => 'limited edition',
            'Ltd. Ed.' => 'limited edition',
            'Edición Limitada' => 'limited edition',
            'Edicion Limitada' => 'limited edition',
            'Regional Edition' => 'regional edition',
            'Regional Ed' => 'regional edition',
            'Reg Ed' => 'regional edition',
            'Reg. Ed.' => 'regional edition',
            'Edición Regional' => 'regional edition',
            'Edicion Regional' => 'regional edition'
        );
        
        foreach ($replacements as $search => $replace) {
            $name = str_ireplace($search, $replace, $name);
        }
        
        // Standardize vital size and count patterns
        // Convert X count formats to standardized format
        $name = preg_replace('/(\d+)\s*ct\.?/i', '$1 count', $name);
        $name = preg_replace('/(\d+)\s*pc\.?s?/i', '$1 count', $name);
        $name = preg_replace('/(\d+)\s*packs?/i', '$1 count', $name);
        $name = preg_replace('/(\d+)\s*units?/i', '$1 count', $name);
        $name = preg_replace('/(\d+)\s*pieces?/i', '$1 count', $name);
        $name = preg_replace('/(\d+)\s*cigars?/i', '$1 count', $name);
        $name = preg_replace('/(\d+)\s*sticks?/i', '$1 count', $name);
        
        // Standardize Chinese count formats
        $name = preg_replace('/(\d+)\s*[支只枝个根条片块]/u', '$1 count', $name);
        $name = preg_replace('/(\d+)\s*支装/u', '$1 count', $name);
        $name = preg_replace('/(\d+)\s*只装/u', '$1 count', $name);
        
        // Standardize dimension formats
        $name = preg_replace('/(\d+)\s*[xX×]\s*(\d+)\s*ring/i', '$1x$2', $name);
        $name = preg_replace('/(\d+)\s*[xX×]\s*(\d+)\s*rg/i', '$1x$2', $name);
        $name = preg_replace('/(\d+)\s*[xX×]\s*(\d+)/i', '$1x$2', $name);
        
        // Final cleanup of extra whitespace
        $name = trim(preg_replace('/\s+/', ' ', $name));
        
        return $name;
    }
    
    /**
     * Get SKU matches from supplier product name
     * Returns all probable matches with scores
     */
    public static function find_sku_matches($supplier_product_name, $catalog_products, $threshold = 70, $limit = 5) {
        // Normalize supplier product name
        $normalized_name = self::normalize_product_name($supplier_product_name);
        
        // Get supplier product keywords
        $supplier_keywords = self::get_categorized_keywords($normalized_name);
        
        $matches = array();
        
        // Process each catalog product
        foreach ($catalog_products as $sku => $product_data) {
            // Normalize catalog product name
            $normalized_catalog_name = self::normalize_product_name($product_data['title']);
            
            // Get catalog product keywords
            $catalog_keywords = self::get_categorized_keywords($normalized_catalog_name);
            
            // Calculate match score
            $match_result = self::calculate_match_score($supplier_keywords, $catalog_keywords);
            $score = $match_result['score'];
            
            // If score meets threshold, add to matches
            if ($score >= $threshold) {
                $matches[$sku] = array(
                    'score' => $score,
                    'title' => $product_data['title'],
                    'sku' => $sku,
                    'brand' => isset($product_data['brand']) ? $product_data['brand'] : '',
                    'matched_keywords' => $match_result['matched_keywords'],
                    'category_scores' => $match_result['category_scores']
                );
            }
        }
        
        // Sort matches by score (descending)
        uasort($matches, function($a, $b) {
            return $b['score'] <=> $a['score'];
        });
        
        // Limit results
        return array_slice($matches, 0, $limit, true);
    }
    
    /**
     * Enhanced brand-specific matcher for targeted lookups
     * Specialized for cases where we know the brand/series
     */
    public static function find_brand_specific_matches($supplier_product_name, $brand, $catalog_products, $threshold = 60, $limit = 5) {
        // Normalize supplier product name
        $normalized_name = self::normalize_product_name($supplier_product_name);
        
        // Get supplier product keywords
        $supplier_keywords = self::get_categorized_keywords($normalized_name);
        
        // Filter catalog products by brand
        $brand_catalog = array();
        foreach ($catalog_products as $sku => $product_data) {
            if (stripos($product_data['title'], $brand) !== false || 
                (isset($product_data['brand']) && stripos($product_data['brand'], $brand) !== false)) {
                $brand_catalog[$sku] = $product_data;
            }
        }
        
        // Use standard matcher with brand-filtered catalog
        return self::find_sku_matches($supplier_product_name, $brand_catalog, $threshold, $limit);
    }
    
    /**
     * Find matches for a specific size/vitola within a brand
     */
    public static function find_vitola_specific_matches($supplier_product_name, $brand, $vitola, $catalog_products, $threshold = 60, $limit = 5) {
        // Normalize supplier product name
        $normalized_name = self::normalize_product_name($supplier_product_name);
        
        // Get supplier product keywords
        $supplier_keywords = self::get_categorized_keywords($normalized_name);
        
        // Filter catalog products by brand and vitola
        $filtered_catalog = array();
        foreach ($catalog_products as $sku => $product_data) {
            $title = strtolower($product_data['title']);
            if ((stripos($title, $brand) !== false || 
                (isset($product_data['brand']) && stripos($product_data['brand'], $brand) !== false)) && 
                stripos($title, $vitola) !== false) {
                $filtered_catalog[$sku] = $product_data;
            }
        }
        
        // Use standard matcher with filtered catalog
        return self::find_sku_matches($supplier_product_name, $filtered_catalog, $threshold, $limit);
    }
    
    /**
     * Search for products by keyword in the catalog
     */
    public static function search_catalog_by_keyword($keyword, $catalog_products, $limit = 20) {
        $results = array();
        $keyword = strtolower(trim($keyword));
        
        if (empty($keyword) || strlen($keyword) < 2) {
            return $results;
        }
        
        foreach ($catalog_products as $sku => $product_data) {
            $title = strtolower($product_data['title']);
            $brand = isset($product_data['brand']) ? strtolower($product_data['brand']) : '';
            
            // Check if keyword is in title or brand
            if (stripos($title, $keyword) !== false || stripos($brand, $keyword) !== false) {
                $results[$sku] = $product_data;
            }
            
            // Limit results
            if (count($results) >= $limit) {
                break;
            }
        }
        
        return $results;
    }
    
    /**
     * Find the best match for a supplier product
     * Returns the single best match or null if no good matches
     */
    public static function find_best_match($supplier_product_name, $catalog_products, $threshold = 75) {
        $matches = self::find_sku_matches($supplier_product_name, $catalog_products, $threshold, 1);
        
        if (empty($matches)) {
            return null;
        }
        
        return reset($matches); // Return the first (and only) match
    }
    
    /**
     * Process batch of supplier products against catalog
     * Optimized for performance with batch processing
     */
    public static function batch_process_products($supplier_products, $catalog_products, $threshold = 70) {
        $results = array();
        $batch_size = KT_CIGAR_BATCH_SIZE;
        $total = count($supplier_products);
        $processed = 0;
        
        // Process in batches for better performance
        foreach (array_chunk($supplier_products, $batch_size, true) as $batch) {
            foreach ($batch as $supplier_id => $supplier_product) {
                $matches = self::find_sku_matches(
                    $supplier_product['title'], 
                    $catalog_products, 
                    $threshold, 
                    3
                );
                
                $results[$supplier_id] = array(
                    'supplier_data' => $supplier_product,
                    'matches' => $matches
                );
                
                $processed++;
            }
            
            // Log progress
            KT_Cigar_Debug::log("Processed $processed of $total supplier products", 2, 'Batch');
        }
        
        return $results;
    }
    
    /**
     * Cache utility: Get cached mappings or generate new ones
     */
    public static function get_cached_mappings($supplier_products, $catalog_products, $threshold = 70) {
        $cache_key = 'kt_cigar_mappings_' . md5(serialize(array_keys($supplier_products)) . serialize(array_keys($catalog_products)));
        $cached = get_transient($cache_key);
        
        if ($cached !== false) {
            KT_Cigar_Debug::log('Using cached mappings', 2, 'Cache');
            return $cached;
        }
        
        // Generate new mappings
        KT_Cigar_Debug::log('Generating new mappings', 2, 'Cache');
        $mappings = self::batch_process_products($supplier_products, $catalog_products, $threshold);
        
        // Cache for later use
        set_transient($cache_key, $mappings, KT_CIGAR_CACHE_EXPIRY);
        
        return $mappings;
    }
    
    /**
     * Clear mapping caches
     */
    public static function clear_caches() {
        global $wpdb;
        
        $result = $wpdb->query("DELETE FROM $wpdb->options WHERE option_name LIKE '_transient_kt_cigar_mappings_%' OR option_name LIKE '_transient_timeout_kt_cigar_mappings_%'");
        
        KT_Cigar_Debug::log("Cache cleared: $result items removed", 1, 'Cache');
        
        return $result;
    }
}

/**
 * KT_Cigar_Matcher_Enhanced - Advanced matcher using machine learning techniques
 * Provides more sophisticated matching algorithms beyond the basic keyword matching
 */
class KT_Cigar_Matcher_Enhanced {
    // Training data
    private static $training_data = array();
    
    // Model weights
    private static $model_weights = array();
    
    // Enhanced algorithm types
    const ALGO_BASIC = 'basic';
    const ALGO_WEIGHTED = 'weighted';
    const ALGO_HYBRID = 'hybrid';
    const ALGO_LEARNING = 'learning';
    
    /**
     * Initialize the enhanced matcher
     */
    public static function init() {
        // Load saved weights if available
        self::$model_weights = get_option('kt_cigar_matcher_weights', array());
        
        // Initialize training data structure
        self::$training_data = get_option('kt_cigar_matcher_training', array());
        
        if (empty(self::$model_weights)) {
            // Initialize with default weights
            self::$model_weights = array(
                'brand_weight' => 1.5,
                'model_weight' => 1.3,
                'vitola_weight' => 1.2,
                'dimension_weight' => 1.1,
                'special_edition_weight' => 1.0,
                'year_weight' => 0.9,
                'count_weight' => 0.8,
                'packaging_weight' => 0.7,
                'general_weight' => 0.6,
                'regional_weight' => 0.5
            );
            
            // Save default weights
            update_option('kt_cigar_matcher_weights', self::$model_weights);
        }
    }
    
    /**
     * Find matches using enhanced algorithms
     */
    public static function find_enhanced_matches($supplier_product_name, $catalog_products, $algorithm = self::ALGO_WEIGHTED, $threshold = 65, $limit = 5) {
        switch ($algorithm) {
            case self::ALGO_WEIGHTED:
                return self::find_weighted_matches($supplier_product_name, $catalog_products, $threshold, $limit);
            case self::ALGO_HYBRID:
                return self::find_hybrid_matches($supplier_product_name, $catalog_products, $threshold, $limit);
            case self::ALGO_LEARNING:
                return self::find_learning_matches($supplier_product_name, $catalog_products, $threshold, $limit);
            case self::ALGO_BASIC:
            default:
                // Use the standard algorithm from KT_Cigar_Mappings
                return KT_Cigar_Mappings::find_sku_matches($supplier_product_name, $catalog_products, $threshold, $limit);
        }
    }
    
    /**
     * Find matches using weighted algorithm
     * Applies dynamic weights based on product characteristics
     */
    private static function find_weighted_matches($supplier_product_name, $catalog_products, $threshold, $limit) {
        // Normalize supplier product name
        $normalized_name = KT_Cigar_Mappings::normalize_product_name($supplier_product_name);
        
        // Get supplier product keywords
        $supplier_keywords = KT_Cigar_Mappings::get_categorized_keywords($normalized_name);
        
        $matches = array();
        
        // Process each catalog product
        foreach ($catalog_products as $sku => $product_data) {
            // Normalize catalog product name
            $normalized_catalog_name = KT_Cigar_Mappings::normalize_product_name($product_data['title']);
            
            // Get catalog product keywords
            $catalog_keywords = KT_Cigar_Mappings::get_categorized_keywords($normalized_catalog_name);
            
            // Calculate match score with weighted categories
            $score = self::calculate_weighted_score($supplier_keywords, $catalog_keywords);
            
            // If score meets threshold, add to matches
            if ($score >= $threshold) {
                $matches[$sku] = array(
                    'score' => $score,
                    'title' => $product_data['title'],
                    'sku' => $sku,
                    'brand' => isset($product_data['brand']) ? $product_data['brand'] : ''
                );
            }
        }
        
        // Sort matches by score (descending)
        uasort($matches, function($a, $b) {
            return $b['score'] <=> $a['score'];
        });
        
        // Limit results
        return array_slice($matches, 0, $limit, true);
    }
    
    /**
     * Calculate match score with weighted categories
     */
    private static function calculate_weighted_score($supplier_keywords, $catalog_keywords) {
        // Define category weights
        $weights = array(
            'brand' => self::$model_weights['brand_weight'],
            'model' => self::$model_weights['model_weight'],
            'vitola' => self::$model_weights['vitola_weight'],
            'dimensions' => self::$model_weights['dimension_weight'],
            'special_edition' => self::$model_weights['special_edition_weight'],
            'year' => self::$model_weights['year_weight'],
            'count' => self::$model_weights['count_weight'],
            'packaging' => self::$model_weights['packaging_weight'],
            'general' => self::$model_weights['general_weight'],
            'regional' => self::$model_weights['regional_weight']
        );
        
        // Initialize score
        $score = 0;
        $max_score = 0;
        
        // Calculate weighted score for each category
        foreach ($weights as $category => $weight) {
            $supplier_count = count($supplier_keywords[$category]);
            $catalog_count = count($catalog_keywords[$category]);
            
            if ($supplier_count == 0 && $catalog_count == 0) {
                continue; // Skip if both are empty
            }
            
            $category_max = $weight;
            $max_score += $category_max;
            
            // Count matches
            $matches = 0;
            foreach ($supplier_keywords[$category] as $keyword) {
                if (in_array($keyword, $catalog_keywords[$category])) {
                    $matches++;
                } else {
                    // Check for partial matches in certain categories
                    if ($category == 'model' || $category == 'general' || $category == 'special_edition') {
                        foreach ($catalog_keywords[$category] as $catalog_keyword) {
                            if (mb_strlen($keyword) > 3 && mb_strlen($catalog_keyword) > 3) {
                                if (mb_stripos($keyword, $catalog_keyword) !== false || 
                                    mb_stripos($catalog_keyword, $keyword) !== false) {
                                    $matches += 0.7; // Partial match
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            // Calculate category score
            $max_count = max($supplier_count, $catalog_count);
            $category_score = $max_count > 0 ? ($matches / $max_count) * $category_max : 0;
            
            // Boost brand score if there's any match
            if ($category == 'brand' && $matches > 0) {
                $category_score = max($category_score, $category_max * 0.7);
            }
            
            $score += $category_score;
        }
        
        // Calculate percentage score
        $percentage_score = $max_score > 0 ? ($score / $max_score) * 100 : 0;
        
        return min(100, $percentage_score); // Cap at 100%
    }
    
    /**
     * Find matches using hybrid algorithm
     * Combines keyword matching with text similarity analysis
     */
    private static function find_hybrid_matches($supplier_product_name, $catalog_products, $threshold, $limit) {
        // Normalize supplier product name
        $normalized_name = KT_Cigar_Mappings::normalize_product_name($supplier_product_name);
        
        // Get supplier product keywords
        $supplier_keywords = KT_Cigar_Mappings::get_categorized_keywords($normalized_name);
        
        $matches = array();
        
        // Process each catalog product
        foreach ($catalog_products as $sku => $product_data) {
            // Normalize catalog product name
            $normalized_catalog_name = KT_Cigar_Mappings::normalize_product_name($product_data['title']);
            
            // Get catalog product keywords
            $catalog_keywords = KT_Cigar_Mappings::get_categorized_keywords($normalized_catalog_name);
            
            // Calculate keyword match score
            $keyword_score = self::calculate_weighted_score($supplier_keywords, $catalog_keywords);
            
            // Calculate text similarity score
            $similarity_score = self::calculate_text_similarity($normalized_name, $normalized_catalog_name);
            
            // Combine scores (70% keyword, 30% similarity)
            $combined_score = ($keyword_score * 0.7) + ($similarity_score * 0.3);
            
            // If combined score meets threshold, add to matches
            if ($combined_score >= $threshold) {
                $matches[$sku] = array(
                    'score' => $combined_score,
                    'keyword_score' => $keyword_score,
                    'similarity_score' => $similarity_score,
                    'title' => $product_data['title'],
                    'sku' => $sku,
                    'brand' => isset($product_data['brand']) ? $product_data['brand'] : ''
                );
            }
        }
        
        // Sort matches by score (descending)
        uasort($matches, function($a, $b) {
            return $b['score'] <=> $a['score'];
        });
        
        // Limit results
        return array_slice($matches, 0, $limit, true);
    }
    
    /**
     * Calculate text similarity using cosine similarity algorithm
     */
    private static function calculate_text_similarity($text1, $text2) {
        // Convert texts to term frequency vectors
        $vec1 = self::text_to_vector($text1);
        $vec2 = self::text_to_vector($text2);
        
        // Calculate cosine similarity
        $intersection = array_intersect_key($vec1, $vec2);
        $dot_product = 0;
        
        foreach ($intersection as $term => $frequency) {
            $dot_product += $frequency * $vec2[$term];
        }
        
        $mag1 = sqrt(array_sum(array_map(function($val) { return $val * $val; }, $vec1)));
        $mag2 = sqrt(array_sum(array_map(function($val) { return $val * $val; }, $vec2)));
        
        $similarity = ($mag1 * $mag2 > 0) ? $dot_product / ($mag1 * $mag2) : 0;
        
        // Convert to percentage
        return $similarity * 100;
    }
    
    /**
     * Convert text to term frequency vector
     */
    private static function text_to_vector($text) {
        // Split text into words
        $words = preg_split('/\s+/', $text);
        
        // Count term frequencies
        $vector = array();
        foreach ($words as $word) {
            $word = trim($word);
            if (mb_strlen($word) < 2) {
                continue;
            }
            
            if (!isset($vector[$word])) {
                $vector[$word] = 0;
            }
            
            $vector[$word]++;
        }
        
        return $vector;
    }
    
    /**
     * Find matches using learning algorithm
     * Uses past match selections to improve future matching
     */
   private static function find_learning_matches($supplier_product_name, $catalog_products, $threshold, $limit) {
        // Start with hybrid matches
        $hybrid_matches = self::find_hybrid_matches($supplier_product_name, $catalog_products, $threshold, $limit * 2);
        
        // If no matches found, return empty array
        if (empty($hybrid_matches)) {
            return array();
        }
        
        // Adjust scores based on learning data
        $adjusted_matches = array();
        
        foreach ($hybrid_matches as $sku => $match_data) {
            // Calculate learning adjustment
            $adjustment = self::calculate_learning_adjustment($supplier_product_name, $sku);
            
            // Apply adjustment to score
            $adjusted_score = min(100, $match_data['score'] + $adjustment);
            
            // Update match data with adjusted score
            $match_data['score'] = $adjusted_score;
            $match_data['original_score'] = $match_data['score'];
            $match_data['adjustment'] = $adjustment;
            
            // Add to adjusted matches if still meets threshold
            if ($adjusted_score >= $threshold) {
                $adjusted_matches[$sku] = $match_data;
            }
        }
        
        // Sort adjusted matches by score (descending)
        uasort($adjusted_matches, function($a, $b) {
            return $b['score'] <=> $a['score'];
        });
        
        // Limit results
        return array_slice($adjusted_matches, 0, $limit, true);
    }
    
    /**
     * Calculate score adjustment based on learning data
     */
    private static function calculate_learning_adjustment($supplier_product_name, $sku) {
        // Get normalized supplier name
        $normalized_name = KT_Cigar_Mappings::normalize_product_name($supplier_product_name);
        
        // Initialize adjustment
        $adjustment = 0;
        
        // Look for exact matches in training data
        if (isset(self::$training_data[$normalized_name]) && 
            isset(self::$training_data[$normalized_name][$sku])) {
            // Strong positive adjustment for previously selected match
            $adjustment += 15;
        }
        
        // Look for similar supplier names in training data
        foreach (self::$training_data as $training_name => $matches) {
            // Skip exact match (already handled)
            if ($training_name === $normalized_name) {
                continue;
            }
            
            // Calculate similarity between supplier names
            $similarity = self::calculate_text_similarity($normalized_name, $training_name);
            
            // If names are similar enough (>60% similarity)
            if ($similarity > 60) {
                // If this SKU was selected for a similar name
                if (isset($matches[$sku])) {
                    // Apply proportional adjustment based on similarity
                    $adjustment += ($similarity / 100) * 10;
                }
            }
        }
        
        return $adjustment;
    }
    
    /**
     * Record a selected match for learning
     */
    public static function record_match_selection($supplier_product_name, $selected_sku) {
        // Get normalized supplier name
        $normalized_name = KT_Cigar_Mappings::normalize_product_name($supplier_product_name);
        
        // Initialize entry if not exists
        if (!isset(self::$training_data[$normalized_name])) {
            self::$training_data[$normalized_name] = array();
        }
        
        // Record selection with timestamp
        self::$training_data[$normalized_name][$selected_sku] = array(
            'count' => isset(self::$training_data[$normalized_name][$selected_sku]['count']) ? 
                      self::$training_data[$normalized_name][$selected_sku]['count'] + 1 : 1,
            'last_selected' => current_time('timestamp')
        );
        
        // Save updated training data
        update_option('kt_cigar_matcher_training', self::$training_data);
        
        // Periodically update weights based on accumulated data
        self::maybe_update_weights();
        
        return true;
    }
    
    /**
     * Periodically update weights based on learning data
     */
    private static function maybe_update_weights() {
        // Only update weights occasionally (based on training data size)
        $training_count = count(self::$training_data);
        
        // Check if it's time to update (every 100 new training examples)
        if ($training_count % 100 === 0 && $training_count > 0) {
            self::update_model_weights();
        }
    }
    
    /**
     * Update model weights based on learning data
     */
    private static function update_model_weights() {
        // This is a simplified version - in a real implementation, 
        // this would use more sophisticated machine learning techniques
        
        // Analyze training data to extract patterns
        $category_importance = array(
            'brand' => 0,
            'model' => 0,
            'vitola' => 0,
            'dimensions' => 0,
            'special_edition' => 0,
            'year' => 0,
            'count' => 0,
            'packaging' => 0,
            'general' => 0,
            'regional' => 0
        );
        
        $sample_count = 0;
        
        // Analyze each training example
        foreach (self::$training_data as $supplier_name => $matches) {
            // Skip if no matches
            if (empty($matches)) {
                continue;
            }
            
            // Get supplier keywords
            $supplier_keywords = KT_Cigar_Mappings::get_categorized_keywords($supplier_name);
            
            // For each selected SKU, analyze which categories matched
            foreach ($matches as $sku => $match_data) {
                // We need the catalog product data for this SKU
                // In a real implementation, this would be retrieved from the database
                // Here we'll simulate it
                $catalog_product = get_post_meta($sku, '_product_data', true);
                
                if (empty($catalog_product)) {
                    continue;
                }
                
                $catalog_name = isset($catalog_product['title']) ? $catalog_product['title'] : '';
                $catalog_keywords = KT_Cigar_Mappings::get_categorized_keywords($catalog_name);
                
                // Check matches in each category
                foreach ($category_importance as $category => $value) {
                    $supplier_count = count($supplier_keywords[$category]);
                    $catalog_count = count($catalog_keywords[$category]);
                    
                    if ($supplier_count == 0 || $catalog_count == 0) {
                        continue;
                    }
                    
                    $matches = 0;
                    foreach ($supplier_keywords[$category] as $keyword) {
                        if (in_array($keyword, $catalog_keywords[$category])) {
                            $matches++;
                        }
                    }
                    
                    // Calculate match ratio
                    $max_count = max($supplier_count, $catalog_count);
                    $match_ratio = $max_count > 0 ? $matches / $max_count : 0;
                    
                    // Update category importance
                    $category_importance[$category] += $match_ratio * $match_data['count'];
                }
                
                $sample_count += $match_data['count'];
            }
        }
        
        // Normalize category importance and update weights
        if ($sample_count > 0) {
            // Calculate average importance
            foreach ($category_importance as $category => $value) {
                $avg_importance = $value / $sample_count;
                
                // Scale between 0.5 and 2.0
                $new_weight = 0.5 + (1.5 * $avg_importance);
                
                // Update model weight
                self::$model_weights["{$category}_weight"] = $new_weight;
            }
            
            // Save updated weights
            update_option('kt_cigar_matcher_weights', self::$model_weights);
            
            KT_Cigar_Debug::log('Updated model weights based on learning data', 1, 'Learning');
        }
    }
    
    /**
     * Reset learning data and model weights
     */
    public static function reset_learning_data() {
        // Reset training data
        self::$training_data = array();
        update_option('kt_cigar_matcher_training', array());
        
        // Reset weights to defaults
        self::$model_weights = array(
            'brand_weight' => 1.5,
            'model_weight' => 1.3,
            'vitola_weight' => 1.2,
            'dimension_weight' => 1.1,
            'special_edition_weight' => 1.0,
            'year_weight' => 0.9,
            'count_weight' => 0.8,
            'packaging_weight' => 0.7,
            'general_weight' => 0.6,
            'regional_weight' => 0.5
        );
        
        update_option('kt_cigar_matcher_weights', self::$model_weights);
        
        KT_Cigar_Debug::log('Reset learning data and model weights', 1, 'Learning');
        
        return true;
    }
}
