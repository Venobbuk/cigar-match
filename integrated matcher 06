<?php
/**
 * Plugin Name: KT Cigar Enhanced Matcher
 * Description: Match supplier products to KT Cigar catalog SKUs with integrated keyword categorization
 * Version: 2.0.0
 * Author: Claude
 */

// Exit if accessed directly
if (!defined("ABSPATH")) {
    exit;
}

class KT_Cigar_Enhanced_Matcher {
    private $plugin_slug = "ktcigar-enhanced-matcher";
    private $master_table = "master_products";
    private $mapping_table = "cigar_supplier_mapping";
    private $suppliers_table = "cigar_suppliers";
    private $template_table = "cigar_csv_templates";
    private $data_file_path = null;
    private $debug_log = array();
    private $enable_logging = true; // Switch to turn logging on/off
    
    // Keyword categorization system
    private $keyword_categories = array(
        "brand" => array("color" => "#e7f4ff", "label" => "Brand"),
        "model" => array("color" => "#d4edda", "label" => "Series/Model"),
        "vitola" => array("color" => "#fff3cd", "label" => "Vitola/Size"),
        "special_edition" => array("color" => "#f8d7da", "label" => "Special Edition"),
        "year" => array("color" => "#e2e3e5", "label" => "Year"),
        "count" => array("color" => "#d0d0ff", "label" => "Count"),
        "dimensions" => array("color" => "#ffd8b2", "label" => "Dimensions"),
        "packaging" => array("color" => "#ddebf7", "label" => "Packaging"),
        "generic" => array("color" => "#e7e7e7", "label" => "Generic")
    );
    
    // Common filter words
    private $common_filter_words = array(
        "盒", "盒装", "box", "装", "只", "支", "五只", "五支", "三只", "三支", 
        "四只", "四支", "pcs", "片", "条", "整盒", "整箱", "带盒", "带管", 
        "铝管装", "礼盒", "普通装", "单支", "裸支", "非卖品", "定制", "茄", 
        "雪茄", "cigar", "cigars", "烟", "单盒", "高端", "限量", "限定", "特殊", 
        "特制", "精选", "厂家", "正品", "产品", "精美", "小", "大", "中号", "特号", 
        "产地", "古巴", "古代", "cuba", "全球", "包邮", "正品", "原装", "现货", 
        "新品", "无盒", "年", "年份", "打火机"
    );
    
   /**
    * Constructor
    */
    public function __construct() {
        // Set data file path
        $this->data_file_path = WP_CONTENT_DIR . '/cigar-mappings-data.php';
        
        // Initialize KT_Cigar_Mappings if available
        if (class_exists('KT_Cigar_Mappings') && method_exists('KT_Cigar_Mappings', 'init')) {
            KT_Cigar_Mappings::init(true);
        }
        
        // Add admin menu
        add_action("admin_menu", array($this, "add_admin_menu"));
        // Register AJAX handlers
        add_action("wp_ajax_kt_cigar_matcher_upload_csv", array($this, "ajax_upload_supplier_csv"));
        add_action("wp_ajax_kt_cigar_matcher_check_status", array($this, "ajax_check_status"));
        add_action("wp_ajax_kt_cigar_matcher_process_batch", array($this, "ajax_process_batch_products"));
        add_action("wp_ajax_kt_cigar_matcher_save_mapping", array($this, "ajax_save_mapping"));
        add_action("wp_ajax_kt_cigar_matcher_delete_mapping", array($this, "ajax_delete_mapping"));
        add_action("wp_ajax_kt_cigar_matcher_export_mappings", array($this, "ajax_export_mappings"));
        add_action("wp_ajax_kt_cigar_matcher_save_template", array($this, "ajax_save_template"));
        add_action("wp_ajax_kt_cigar_matcher_load_template", array($this, "ajax_load_template"));
        add_action("wp_ajax_kt_cigar_matcher_delete_template", array($this, "ajax_delete_template"));
        add_action("wp_ajax_kt_cigar_matcher_list_templates", array($this, "ajax_list_templates"));
        add_action("wp_ajax_kt_cigar_matcher_search_sku", array($this, "ajax_search_sku"));
        add_action("wp_ajax_kt_cigar_matcher_search_brand", array($this, "ajax_search_by_brand"));
        add_action("wp_ajax_kt_cigar_matcher_quick_map", array($this, "ajax_quick_map"));
        add_action("wp_ajax_kt_cigar_matcher_toggle_logging", array($this, "ajax_toggle_logging"));
        
        // Create tables on activation
        register_activation_hook(__FILE__, array($this, "create_tables"));
        
        // Check if data file exists
        if (!file_exists($this->data_file_path)) {
            add_action('admin_notices', function() {
                echo '<div class="notice notice-error"><p>KT Cigar Matcher: Data file not found at ' . esc_html($this->data_file_path) . '</p></div>';
            });
        }
        
        // Load logging preference from option
        $this->enable_logging = get_option('kt_cigar_matcher_enable_logging', true);
    }
    
    /**
     * Add debug log entry
     */
    private function log_debug($message) {
        if (!$this->enable_logging) {
            return;
        }
        
        $this->debug_log[] = date('Y-m-d H:i:s') . ' - ' . $message;
        
        // Also log to file
        $log_file = WP_CONTENT_DIR . '/cigar-matcher-debug.log';
        file_put_contents($log_file, date('Y-m-d H:i:s') . ' - ' . $message . "\n", FILE_APPEND);
    }
    
    /**
     * Display debug message
     */
    private function display_debug_message($message, $type = 'info') {
        // Log to file if logging is enabled
        if ($this->enable_logging) {
            $this->log_debug($message);
        }
        
        // Return formatted HTML for error/notice
        $class = 'notice';
        switch ($type) {
            case 'error':
                $class = 'notice-error';
                break;
            case 'warning':
                $class = 'notice-warning';
                break;
            case 'success':
                $class = 'notice-success';
                break;
            default:
                $class = 'notice-info';
        }
        
        return '<div class="notice ' . $class . '">' .
               '<p>' . esc_html($message) . '</p>' .
               '</div>';
    }
    
    /**
     * Get any accumulated debug logs for display
     */
    private function get_debug_logs($limit = 10) {
        if (empty($this->debug_log)) {
            return '<p>No debug logs available.</p>';
        }
        
        // Get the most recent logs, limited to $limit entries
        $recent_logs = array_slice($this->debug_log, -$limit);
        
        $output = '';
        foreach ($recent_logs as $log) {
            $output .= '<div class="debug-log-entry">' . esc_html($log) . '</div>';
        }
        
        return $output;
    }
    
    /**
     * Force display all errors and messages
     */
    private function show_all_errors() {
        // Get all WordPress errors
        global $wpdb;
        
        // Log database errors
        if (!empty($wpdb->last_error)) {
            $this->log_debug("Database error: " . $wpdb->last_error);
            return $this->display_debug_message("Database error: " . $wpdb->last_error, 'error');
        }
        
        // Check for PHP errors
        $last_error = error_get_last();
        if (!empty($last_error)) {
            $error_message = "PHP Error: " . $last_error['message'] . " in " . $last_error['file'] . " on line " . $last_error['line'];
            $this->log_debug($error_message);
            return $this->display_debug_message($error_message, 'error');
        }
        
        // Check for table existence
        global $wpdb;
        $master_table = $wpdb->prefix . $this->master_table;
        $mapping_table = $wpdb->prefix . $this->mapping_table;
        $suppliers_table = $wpdb->prefix . $this->suppliers_table;
        
        $errors = [];
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$master_table'") != $master_table) {
            $errors[] = "Master table '$master_table' does not exist!";
        }
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$mapping_table'") != $mapping_table) {
            $errors[] = "Mapping table '$mapping_table' does not exist!";
        }
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$suppliers_table'") != $suppliers_table) {
            $errors[] = "Suppliers table '$suppliers_table' does not exist!";
        }
        
        if (!empty($errors)) {
            $error_message = implode("<br>", $errors);
            $this->log_debug($error_message);
            return $this->display_debug_message($error_message, 'error');
        }
        
        // No errors found
        return '';
    }
    
    /**
     * AJAX handler for toggling logging
     */
    public function ajax_toggle_logging() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        $enable = isset($_POST["enable"]) ? (bool)$_POST["enable"] : false;
        $this->enable_logging = $enable;
        update_option('kt_cigar_matcher_enable_logging', $enable);
        
        wp_send_json_success(array(
            "message" => "Logging " . ($enable ? "enabled" : "disabled"),
            "status" => $enable
        ));
    }
    
    /**
     * Create required tables
     */
    public function create_tables() {
        global $wpdb;
        $charset_collate = $wpdb->get_charset_collate();
        
        // Mapping table
        $mapping_table = $wpdb->prefix . $this->mapping_table;
        
        $sql = "CREATE TABLE IF NOT EXISTS $mapping_table (
            id bigint(20) NOT NULL AUTO_INCREMENT,
            supplier_id varchar(255) NOT NULL,
            supplier_name varchar(255) NOT NULL,
            supplier_title text NOT NULL,
            kt_sku varchar(255) NOT NULL,
            match_confidence varchar(50) NOT NULL,
            matched_terms text,
            created_at datetime DEFAULT CURRENT_TIMESTAMP,
            updated_at datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            PRIMARY KEY  (id),
            KEY supplier_name (supplier_name),
            KEY supplier_id (supplier_id),
            KEY kt_sku (kt_sku),
            KEY match_confidence (match_confidence)
        ) $charset_collate;";
        
        // Suppliers table
        $suppliers_table = $wpdb->prefix . $this->suppliers_table;
        
        $sql .= "CREATE TABLE IF NOT EXISTS $suppliers_table (
            id bigint(20) NOT NULL AUTO_INCREMENT,
            supplier_name varchar(255) NOT NULL,
            supplier_description text,
            mapping_count int(11) DEFAULT '0',
            created_at datetime DEFAULT CURRENT_TIMESTAMP,
            updated_at datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            PRIMARY KEY  (id),
            UNIQUE KEY supplier_name (supplier_name)
        ) $charset_collate;";
        
        // Templates table
        $templates_table = $wpdb->prefix . $this->template_table;
        
        $sql .= "CREATE TABLE IF NOT EXISTS $templates_table (
            id bigint(20) NOT NULL AUTO_INCREMENT,
            template_name varchar(255) NOT NULL,
            supplier_name varchar(255) NOT NULL,
            column_mappings text NOT NULL,
            created_at datetime DEFAULT CURRENT_TIMESTAMP,
            updated_at datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            PRIMARY KEY  (id),
            UNIQUE KEY template_name (template_name)
        ) $charset_collate;";
        
        require_once(ABSPATH . "wp-admin/includes/upgrade.php");
        dbDelta($sql);
    }
    
    /**
     * Add admin menu
     */
    public function add_admin_menu() {
        // Main menu
        add_menu_page(
            "Cigar Supplier Matcher",
            "Cigar Matcher",
            "manage_options",
            $this->plugin_slug,
            array($this, "display_main_page"),
            "dashicons-database-import",
            300000
        );
        
        // Mappings submenu
        add_submenu_page(
            $this->plugin_slug,
            "Supplier Mappings",
            "Mappings",
            "manage_options",
            $this->plugin_slug . "-mappings",
            array($this, "display_mappings_page")
        );
        
        // Templates submenu
        add_submenu_page(
            $this->plugin_slug,
            "CSV Templates",
            "Templates",
            "manage_options",
            $this->plugin_slug . "-templates",
            array($this, "display_templates_page")
        );
        
        // Add new debug page
        add_submenu_page(
            $this->plugin_slug,
            "Keyword Debug",
            "Keyword Debug",
            "manage_options",
            $this->plugin_slug . "-debug",
            array($this, "display_debug_page")
        );
    }
    
    /**
     * Load the data file
     */
    private function load_data_file() {
        static $data_file = null;
        
        if ($data_file === null) {
            // Try to get data file from KT_Cigar_Mappings if available
            if (class_exists('KT_Cigar_Mappings') && property_exists('KT_Cigar_Mappings', 'data_file')) {
                $reflection = new ReflectionClass('KT_Cigar_Mappings');
                $property = $reflection->getProperty('data_file');
                $property->setAccessible(true);
                $data_file = $property->getValue(null);
                
                if (!empty($data_file)) {
                    $this->log_debug("Data file loaded from KT_Cigar_Mappings");
                    return $data_file;
                }
            }
            
            // Fallback to loading file directly
            if (file_exists($this->data_file_path)) {
                try {
                    $data_file = include $this->data_file_path;
                    if (!is_array($data_file)) {
                        $this->log_debug("Data file did not return an array");
                        $data_file = array();
                    }
                } catch (Exception $e) {
                    $this->log_debug("Error loading data file: " . $e->getMessage());
                    $data_file = array();
                }
            } else {
                $error_message = "Data file not found: " . $this->data_file_path;
                $this->log_debug($error_message);
                add_action('admin_notices', function() use ($error_message) {
                    echo $this->display_debug_message($error_message, 'error');
                });
                $data_file = array();
            }
        }
        
        return $data_file;
    }
    
    /**
     * Display main page
     */
    public function display_main_page() {
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
        // Check data file
        $data_file = $this->load_data_file();
        
        // Direct testing of critical plugin components
        try {
            // 1. Test data file access and structure
            if (empty($data_file)) {
                throw new Exception("Data file could not be loaded or is empty");
            } else {
                // Check basic structure expected in data file
                if (!isset($data_file['brands']) || (!isset($data_file['brands']['cuban']) && !isset($data_file['brands']['non_cuban']))) {
                    throw new Exception("Data file structure is invalid - missing brands section");
                }
            }

            // 2. Test direct database table access
            global $wpdb;
            $master_table = $wpdb->prefix . $this->master_table;
            $test_query = "SELECT COUNT(*) FROM $master_table";
            $result = $wpdb->get_var($test_query);
            if ($result === null && $wpdb->last_error) {
                throw new Exception("Database error: " . $wpdb->last_error);
            }

            // 3. Test debug log writing
            $test_log_file = WP_CONTENT_DIR . '/cigar-matcher-debug.log';
            if (!is_writable($test_log_file) && file_exists($test_log_file)) {
                throw new Exception("Debug log file is not writable: " . $test_log_file);
            }

            // 4. Test file system permissions for uploads
            $upload_dir = wp_upload_dir();
            $supplier_dir = $upload_dir["basedir"] . "/cigar-supplier-csv";
            if (!file_exists($supplier_dir)) {
                if (!@mkdir($supplier_dir, 0755, true)) {
                    throw new Exception("Could not create supplier CSV directory: " . $supplier_dir);
                }
            } else if (!is_writable($supplier_dir)) {
                throw new Exception("Supplier CSV directory is not writable: " . $supplier_dir);
            }

        } catch (Exception $e) {
            $error_message = "KT Cigar Matcher diagnostic error: " . $e->getMessage();
            $this->log_debug($error_message);
            echo '<div class="notice notice-error"><p>' . esc_html($error_message) . '</p></div>';
        }
        
        // Check required tables
        global $wpdb;
        $tables_exist = true;
        $master_table = $wpdb->prefix . $this->master_table;
        $mapping_table = $wpdb->prefix . $this->mapping_table;
        $suppliers_table = $wpdb->prefix . $this->suppliers_table;
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$master_table'") != $master_table) {
            $this->log_debug("Master table '$master_table' does not exist!");
            $tables_exist = false;
        }
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$mapping_table'") != $mapping_table) {
            $this->log_debug("Mapping table '$mapping_table' does not exist!");
            $tables_exist = false;
        }
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$suppliers_table'") != $suppliers_table) {
            $this->log_debug("Suppliers table '$suppliers_table' does not exist!");
            $tables_exist = false;
        }
        
        $error_message = '';
        if (!$tables_exist) {
            $error_message = 'One or more required database tables do not exist. Please deactivate and reactivate the plugin.';
            echo '<div class="notice notice-error"><p>KT Cigar Matcher: ' . esc_html($error_message) . '</p></div>';
        }

        // Always try to detect and show errors
        $force_errors = $this->show_all_errors();
        if (!empty($force_errors)) {
            echo $force_errors;
        }
        
        // Get suppliers for dropdown
        $suppliers = $wpdb->get_results("SELECT supplier_name FROM {$wpdb->prefix}{$this->suppliers_table} ORDER BY supplier_name ASC");
        
        ?>
        <div class="wrap">
            <h1>Cigar Supplier Matcher (Enhanced)</h1>
            
            <!-- Logging toggle switch -->
            <div class="logging-toggle">
                <label>
                    Enable Debug Logging:
                    <input type="checkbox" id="logging-toggle-switch" <?php checked($this->enable_logging); ?>>
                </label>
                <p class="description">Toggle debug logging for troubleshooting purposes.</p>
            </div>
            
            <?php if (empty($data_file)): ?>
                <div class="notice notice-error">
                    <p>Error: Data file is missing or invalid. Please check the path: <?php echo esc_html($this->data_file_path); ?></p>
                </div>
            <?php else: ?>
                <div class="notice notice-success">
                    <p>Data file loaded successfully with <?php echo count($data_file['brands']['cuban'] ?? []) + count($data_file['brands']['non_cuban'] ?? []); ?> brands.</p>
                </div>
            <?php endif; ?>
            <?php if (!empty($error_message)): ?>
                <div class="notice notice-error">
                    <p>Error: <?php echo esc_html($error_message); ?></p>
                </div>
            <?php endif; ?>
            
            <div class="kt-cigar-matcher-container">
                <div class="kt-cigar-matcher-upload-section">
                    <h2>Upload Supplier CSV</h2>
                    
                    <form id="kt-cigar-csv-upload-form" enctype="multipart/form-data">
                        <?php wp_nonce_field("kt-cigar-matcher-nonce", "kt_cigar_matcher_nonce"); ?>
                        
                        <table class="form-table">
                            <tr>
                                <th><label for="supplier_name">Supplier Name:</label></th>
                                <td>
                                    <input type="text" id="supplier_name" name="supplier_name" required list="supplier-list">
                                    <datalist id="supplier-list">
                                        <?php foreach ($suppliers as $supplier): ?>
                                            <option value="<?php echo esc_attr($supplier->supplier_name); ?>">
                                        <?php endforeach; ?>
                                    </datalist>
                                    <p class="description">Enter supplier name or choose from existing suppliers</p>
                                </td>
                            </tr>
                            <tr>
                                <th><label for="supplier_csv">CSV File:</label></th>
                                <td>
                                    <input type="file" id="supplier_csv" name="supplier_csv" accept=".csv" required>
                                    <p class="description">Upload a CSV file with supplier product data</p>
                                </td>
                            </tr>
                            <tr>
                                <th><label for="batch_size">Batch Size:</label></th>
                                <td>
                                    <select id="batch_size" name="batch_size">
                                        <option value="5">5 products per batch</option>
                                        <option value="10" selected>10 products per batch</option>
                                        <option value="20">20 products per batch</option>
                                        <option value="50">50 products per batch</option>
                                    </select>
                                    <p class="description">Number of products to process in each batch</p>
                                </td>
                            </tr>
                        </table>
                        
                        <p><button type="submit" class="button button-primary" id="kt-upload-csv-btn">Upload and Process</button></p>
                    </form>
                    
                    <div id="kt-cigar-upload-messages" class="notice" style="display: none;"></div>
                </div>
                
                <!-- Keyword Categorization Legend for visual reference -->
                <div class="keyword-category-legend" style="margin: 15px 0; padding: 10px; background: #fff; border: 1px solid #ddd; border-radius: 4px; display: none;">
                    <h3>Keyword Categories:</h3>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                        <?php foreach ($this->keyword_categories as $category => $details): ?>
                            <div style="display: flex; align-items: center; margin-right: 15px;">
                                <span style="display: inline-block; width: 20px; height: 20px; background-color: <?php echo $details["color"]; ?>; margin-right: 5px; border-radius: 3px;"></span>
                                <span><?php echo $details["label"]; ?></span>
                            </div>
                        <?php endforeach; ?>
                    </div>
                </div>
                
                <!-- Processing section -->
                <div class="kt-cigar-matcher-process-section" style="display: none;">
                    <h2>Processing Supplier Products</h2>
                    
                    <div class="kt-cigar-process-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                        <div class="progress-text">0% complete</div>
                    </div>
                    
                    <div class="kt-cigar-process-stats">
                        <div>
                            <strong>Exact Matches:</strong> <span id="stats-exact">0</span>
                        </div>
                        <div>
                            <strong>Close Matches:</strong> <span id="stats-close">0</span>
                        </div>
                        <div>
                            <strong>Possible Matches:</strong> <span id="stats-possible">0</span>
                        </div>
                        <div>
                            <strong>Manual Matches:</strong> <span id="stats-manual">0</span>
                        </div>
                        <div>
                            <strong>No Matches:</strong> <span id="stats-none">0</span>
                        </div>
                    </div>
                    
                    <div id="kt-cigar-process-messages" class="notice" style="display: none;"></div>
                    
                    <div class="kt-cigar-process-results">
                        <h3>Batch Results</h3>
                        <table class="wp-list-table widefat fixed striped batch-results-table">
                            <thead>
                                <tr>
                                    <th width="10%">Product ID</th>
                                    <th width="25%">Product Title</th>
                                    <th width="15%">Match Status</th>
                                    <th width="30%">Best Match</th>
                                    <th width="20%">Keywords</th>
                                </tr>
                            </thead>
                            <tbody id="batch-results-body">
                                <!-- Results will be loaded here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="kt-cigar-actions">
                        <p>
                            <button type="button" class="button button-primary" id="kt-export-mappings-btn">Export Mappings</button>
                            <button type="button" class="button" id="kt-restart-btn">Start New CSV</button>
                        </p>
                    </div>
                </div>
                
                <!-- Manual mapping section -->
                <div class="kt-cigar-manual-map-section" style="display: none;">
                    <h2>Manual Product Mapping</h2>
                    
                    <div class="manual-map-form">
                        <div class="supplier-product-info">
                            <h3>Supplier Product</h3>
                            <div id="manual-supplier-title" class="supplier-title"></div>
                        </div>
                        
                        <div class="kt-product-search">
                            <h3>Search for KT Product</h3>
                            
                            <div class="search-form">
                                <div class="search-row">
                                    <label>By Brand:</label>
                                    <input type="text" class="search-brand-input" placeholder="Enter brand name">
                                    <button type="button" class="button search-by-brand" disabled>Search</button>
                                </div>
                                
                                <div class="search-row">
                                    <label>By SKU:</label>
                                    <input type="text" class="search-sku-input" placeholder="Enter SKU or title">
                                    <button type="button" class="button search-by-sku" disabled>Search</button>
                                </div>
                            </div>
                            
                            <div class="search-results" style="display: none;">
                                <h4>Matching KT Products</h4>
                                <table class="wp-list-table widefat fixed striped">
                                    <thead>
                                        <tr>
                                            <th width="20%">SKU</th>
                                            <th width="50%">Title</th>
                                            <th width="30%">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody class="search-results-body">
                                        <!-- Search results will be loaded here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <div class="mapping-actions">
                            <button type="button" class="button" id="cancel-manual-map">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Debug log section - for troubleshooting -->
            <?php if ($this->enable_logging && !empty($this->debug_log)): ?>
            <div class="kt-debug-log" style="margin-top: 20px; padding: 10px; background: #f8f8f8; border: 1px solid #ddd; max-height: 300px; overflow-y: auto;">
                <h3>Debug Log</h3>
                <pre><?php echo implode("\n", array_map('esc_html', $this->debug_log)); ?></pre>
            </div>
            <?php endif; ?>
        </div>
        
        <script>
        jQuery(document).ready(function($) {
            // Debug console logger
            function debugLog(message, data) {
                if (typeof console !== 'undefined' && console.debug) {
                    if (data) {
                        console.debug('[KT Cigar Debug] ' + message, data);
                    } else {
                        console.debug('[KT Cigar Debug] ' + message);
						}
                }
            }

            // Add console logging to all AJAX requests
            $(document).ajaxSend(function(event, jqXHR, settings) {
                debugLog('AJAX Request:', settings);
            });

            $(document).ajaxSuccess(function(event, jqXHR, settings, data) {
                debugLog('AJAX Success:', data);
            });

            $(document).ajaxError(function(event, jqXHR, settings, error) {
                debugLog('AJAX Error:', {
                    error: error,
                    status: jqXHR.status,
                    statusText: jqXHR.statusText,
                    responseText: jqXHR.responseText
                });
            });
            
            // Show keyword legend
            $(".keyword-category-legend").show();
            
            // Check for errors on page load
            $.ajax({
                url: ajaxurl,
                type: "POST",
                data: {
                    action: "kt_cigar_matcher_check_status",
                    nonce: $("#kt_cigar_matcher_nonce").val()
                },
                success: function(response) {
                    if (response.success) {
                        if (response.data.has_errors) {
                            // Show error message if any
                            $(".notice.notice-error").html("<p>Error: " + response.data.message + "</p>").show();
                        }
                        // Show debug log if available
                        if (response.data.debug_log && response.data.debug_log.length > 0) {
                            debugLog('Status check debug log:', response.data.debug_log);
                        }
                    }
                }
            });
                
            // Toggle logging
            $("#logging-toggle-switch").on("change", function() {
                const enabled = $(this).is(":checked");
                
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_toggle_logging",
                        nonce: $("#kt_cigar_matcher_nonce").val(),
                        enable: enabled
                    },
                    success: function(response) {
                        if (response.success) {
                            alert(response.data.message);
                            if (!enabled) {
                                $(".kt-debug-log").hide();
                            }
                        }
                    }
                });
            });
                
            // Variables to store state
            let supplierProducts = [];
            let batchSize = 10;
            let processPosition = 0;
            let currentSupplierProduct = null;
            let matchCounts = {
                exact: 0,
                close: 0,
                possible: 0,
                manual: 0,
                none: 0
            };
                
            // Handle CSV upload form submission
            $("#kt-cigar-csv-upload-form").on("submit", function(e) {
                e.preventDefault();
                
                const formData = new FormData(this);
                formData.append("action", "kt_cigar_matcher_upload_csv");
                
                // Update batch size
                batchSize = parseInt($("#batch_size").val(), 10);
                
                // Show loading message
                $("#kt-cigar-upload-messages")
                    .attr("class", "notice notice-info")
                    .html("<p>Uploading and processing CSV file...</p>")
                    .show();
                
                // Reset stats
                matchCounts = {
                    exact: 0,
                    close: 0,
                    possible: 0,
                    manual: 0,
                    none: 0
                };
                
                $("#stats-exact").text("0");
                $("#stats-close").text("0");
                $("#stats-possible").text("0");
                $("#stats-manual").text("0");
                $("#stats-none").text("0");
                
                // Reset progress
                $(".progress-fill").css("width", "0%");
                $(".progress-text").text("0% complete");
                processPosition = 0;
                
                // Submit the form via AJAX
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: formData,
                    contentType: false,
                    processData: false,
                    success: function(response) {
                        if (response.success) {
                            // Show success message
                            $("#kt-cigar-upload-messages")
                                .attr("class", "notice notice-success")
                                .html("<p>" + response.data.message + "</p>")
                                .show();
                            
                            // Switch to processing section
                            $(".kt-cigar-matcher-upload-section").hide();
                            $(".kt-cigar-matcher-process-section").show();
                            
                            // Start batch processing
                            processBatch();
                        } else {
                            // Show error message
                            $("#kt-cigar-upload-messages")
                                .attr("class", "notice notice-error")
                                .html("<p>Error: " + response.data.message + "</p>")
                                .show();
                        }
                    },
                    error: function(xhr, status, error) {
                        // Show error message
                        $("#kt-cigar-upload-messages")
                            .attr("class", "notice notice-error")
                            .html("<p>Error: " + error + "</p>")
                            .show();
                    }
                });
            });
                
            // Process batch of products
            function processBatch() {
                // Show processing message
                $("#kt-cigar-process-messages")
                    .attr("class", "notice notice-info")
                    .html("<p>Processing batch of products...</p>")
                    .show();
                
                // Submit the batch request
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_process_batch",
                        nonce: $("#kt_cigar_matcher_nonce").val(),
                        position: processPosition,
                        batch_size: batchSize
                    },
                    success: function(response) {
                        if (response.success) {
                            // Update progress
                            $(".progress-fill").css("width", response.data.percentage + "%");
                            $(".progress-text").text(response.data.percentage + "% complete");
                            
                            // Update process position
                            processPosition = response.data.position;
                            
                            // Update match counts
                            if (response.data.match_counts) {
                                matchCounts.exact += response.data.match_counts.exact || 0;
                                matchCounts.close += response.data.match_counts.close || 0;
                                matchCounts.possible += response.data.match_counts.possible || 0;
                                matchCounts.manual += response.data.match_counts.manual || 0;
                                matchCounts.none += response.data.match_counts.none || 0;
                                
                                $("#stats-exact").text(matchCounts.exact);
                                $("#stats-close").text(matchCounts.close);
                                $("#stats-possible").text(matchCounts.possible);
                                $("#stats-manual").text(matchCounts.manual);
                                $("#stats-none").text(matchCounts.none);
                            }
                            
                            // Display batch results
                            displayBatchResults(response.data.batch_results);
                            
                            // Check if processing is complete
                            if (response.data.completed) {
                                // Show completion message
                                $("#kt-cigar-process-messages")
                                    .attr("class", "notice notice-success")
                                    .html("<p>Processing complete! " + response.data.total + " products processed.</p>")
                                    .show();
                            } else {
                                // Process next batch
                                processBatch();
                            }
                        } else {
                            // Show error message
                            $("#kt-cigar-process-messages")
                                .attr("class", "notice notice-error")
                                .html("<p>Error: " + response.data.message + "</p>")
                                .show();
                        }
                    },
                    error: function(xhr, status, error) {
                        // Show error message
                        $("#kt-cigar-process-messages")
                            .attr("class", "notice notice-error")
                            .html("<p>Error: " + error + "</p>")
                            .show();
                    }
                });
            }
            
            // Function to create a categorized keyword span with improved categorization
            function createCategorizedKeywordSpan(keyword, productTitle) {
                // Clean up the keyword - remove HTML tags and normalize brackets
                keyword = keyword.replace(/<.*?>/g, '').trim();
                
                // Remove comparison symbols like ≈
                keyword = keyword.replace(/≈.*$/, '').trim();
                
                // Determine category based on keyword prefix
                let category = "generic";
                let keywordText = keyword;
                
                // Parse tagged keywords to get proper categorization
                if (keyword.includes(':')) {
                    const parts = keyword.split(':');
                    const tag = parts[0].toUpperCase();
                    keywordText = parts[1].trim();
                    
                    switch (tag) {
                        case "BRAND": category = "brand"; break;
                        case "SERIES": case "MODEL": category = "model"; break;
                        case "VITOLA": category = "vitola"; break;
                        case "SPECIAL": category = "special_edition"; break;
                        case "YEAR": category = "year"; break;
                        case "COUNT": category = "count"; break;
                        case "DIM": category = "dimensions"; break;
                        case "PACK": category = "packaging"; break;
                        default: category = "generic";
                    }
                } else {
                    // For untagged keywords, use more sophisticated pattern recognition
                    
                    // Check for year pattern (1900-2025)
                    if (/^(19|20)\d{2}$/.test(keywordText)) {
                        category = "year";
                    }
                    // Check for dimension pattern (digits with x/×)
                    else if (/\d+[xX×*\/]\d+/.test(keywordText) || /^\d+\/\d+$/.test(keywordText)) {
                        category = "dimensions";
                    }
                    // Check for counts (digits followed by count identifiers)
                    else if (/^\d+(支|×|x|pcs|个|count|ct|-count)?$/i.test(keywordText)) {
                        category = "count";
                    }
                    // Check for special edition words
                    else if (/limited|edition|special|anniversary|限量|纪念版|周年/.test(keywordText.toLowerCase())) {
                        category = "special_edition";
                    }
                    // Check for packaging
                    else if (/box|pack|tube|jar|humidor|盒|管|装/.test(keywordText.toLowerCase())) {
                        category = "packaging";
                    }
                    // Look for vitola words
                    else if (/robusto|corona|torpedo|churchill|lancero|belicoso|petit|toro|panetela/.test(keywordText.toLowerCase())) {
                        category = "vitola";
                    }
                    // Check for Chinese characters
                    else if (/[\u4e00-\u9fa5]+/.test(keywordText)) {
                        // For Chinese terms, we'll just display them as generic
                        // The server-side code will handle proper categorization with the data file
                        category = "generic";
                    }
                    // For brand context, check if this word is part of product's brand
                    else if (productTitle && keywordText.length > 2) {
                        // Extract likely brand from product title (first 1-2 words)
                        const titleWords = productTitle.split(' ').slice(0, 2).join(' ').toLowerCase();
                        if (titleWords.includes(keywordText.toLowerCase()) || 
                            keywordText.toLowerCase().includes(titleWords)) {
                            category = "brand";
                        }
                    }
                }
                
                // Get color for category
                const colors = {
                    "brand": "#e7f4ff",
                    "model": "#d4edda",
                    "vitola": "#fff3cd",
                    "special_edition": "#f8d7da",
                    "year": "#e2e3e5",
                    "count": "#d0d0ff",
                    "dimensions": "#ffd8b2",
                    "packaging": "#ddebf7",
                    "generic": "#e7e7e7"
                };
                
                const labels = {
                    "brand": "Brand",
                    "model": "Series/Model",
                    "vitola": "Vitola/Size",
                    "special_edition": "Special Edition",
                    "year": "Year",
                    "count": "Count",
                    "dimensions": "Dimensions",
                    "packaging": "Packaging",
                    "generic": "Generic"
                };
                
                // Create span with appropriate styling
                return $("<span>")
                    .addClass("matched-term")
                    .css("background-color", colors[category])
                    .attr("title", labels[category])
                    .text(keywordText);
            }
                        
            // Display batch results in the table
            function displayBatchResults(results) {
                if (!results || !results.length) {
                    return;
                }
                
                // Add new results
                $.each(results, function(i, result) {
                    let statusClass = "";
                    let statusText = "";
                    
                    // Set status class and text
                    switch (result.match_status) {
                        case "exact_match":
                            statusClass = "exact-match";
                            statusText = "Exact Match";
                            break;
                        case "close_match":
                            statusClass = "close-match";
                            statusText = "Close Match";
                            break;
                        case "possible_match":
                            statusClass = "possible-match";
                            statusText = "Possible Match";
                            break;
                        case "manual_match":
                            statusClass = "manual-match";
                            statusText = "Manual Match";
                            break;
                        default:
                            statusClass = "no-match";
                            statusText = "No Match";
                    }
                    
                    // Build row
                    let row = $("<tr>").addClass(statusClass);
                    
                    // Add columns
                    row.append($("<td>").text(result.product_id));
                    
                    // Product title cell with keywords underneath
                    let titleCell = $("<td>").addClass("supplier-title-cell");
                    titleCell.append($("<div>").addClass("supplier-title").text(result.product_title));
                    
                    // Add keywords container under the title
                    if (result.matched_terms && result.matched_terms.length > 0) {
                        let keywordsContainer = $("<div>").addClass("product-keywords-container").css("display", "none");
                        $.each(result.matched_terms, function(j, term) {
                            // Create a keyword span with enhanced categorization
                            let keywordSpan = createCategorizedKeywordSpan(term, result.product_title);
                            keywordsContainer.append(keywordSpan);
                        });
                        titleCell.append(keywordsContainer);
                    }
                    
                    row.append(titleCell);
                    row.append($("<td>").addClass("match-status").text(statusText));
                    
                    // Best match column
                    let bestMatchCell = $("<td>").addClass("best-match");
                    if (result.best_match) {
                        let matchInfoDiv = $("<div>").addClass("match-info");
                        matchInfoDiv.append($("<div>").addClass("match-sku").text(result.best_match.sku));
                        matchInfoDiv.append($("<div>").addClass("match-title").text(result.best_match.title));
                        matchInfoDiv.append($("<div>").addClass("match-score").text("Score: " + result.best_match.score + "%"));
                        
                        bestMatchCell.append(matchInfoDiv);
                    } else {
                        bestMatchCell.text("No match found");
                    }
                    row.append(bestMatchCell);
                    
                    // Add matched terms with categorization
                    let keywordsCell = $("<td>").addClass("matched-terms");
                    if (result.matched_terms && result.matched_terms.length > 0) {
                        let termsDiv = $("<div>").addClass("matched-terms-container");
                        
                        // Add a header for supplier keywords
                        termsDiv.append($("<h5>").text("Supplier Keywords:").css({
                            'margin': '5px 0',
                            'font-weight': 'bold',
                            'border-bottom': '1px solid #ddd'
                        }));
                        
                        // Display supplier keywords
                        $.each(result.matched_terms, function(j, term) {
                            // Create a keyword span with enhanced categorization
                            let keywordSpan = createCategorizedKeywordSpan(term, result.product_title);
                            termsDiv.append(keywordSpan);
                        });
                        
                       // If there are DB product keywords, show them separately
if (result.best_match && result.best_match.db_keywords && result.best_match.db_keywords.length > 0) {
    console.log("Found DB keywords for product " + result.product_id + ":", result.best_match.db_keywords);
    
    // Add a header for DB keywords
    termsDiv.append($("<h5>").text("DB Product Keywords:").css({
        'margin': '10px 0 5px 0',
        'font-weight': 'bold',
        'border-bottom': '1px solid #ddd'
    }));
    
    // Display DB keywords
    $.each(result.best_match.db_keywords, function(j, term) {
        let keywordSpan = createCategorizedKeywordSpan(term, result.best_match.title);
        termsDiv.append(keywordSpan);
    });
} else {
    console.log("No DB keywords found for product " + result.product_id);
    console.log("Best match data:", result.best_match);
}
                        
                        keywordsCell.append(termsDiv);
                    } else {
                        keywordsCell.text("No keywords extracted");
                    }
                    row.append(keywordsCell);
                    
                    // Add manual mapping button for all matches (users should be able to manually map even if exact match)
                    bestMatchCell.append(
                        $("<button>")
                            .attr("type", "button")
                            .addClass("button manual-map-btn")
                            .text("Manual Map")
                            .data("product-id", result.product_id)
                            .data("product-title", result.product_title)
                    );
                    
                    // Add row to table
                    $("#batch-results-body").append(row);
                });
            }
            
            // Handle restart button
            $("#kt-restart-btn").on("click", function() {
                $(".kt-cigar-matcher-process-section").hide();
                $(".kt-cigar-matcher-upload-section").show();
                
                // Clear results
                $("#batch-results-body").empty();
            });
            
            // Handle export mappings button
            $("#kt-export-mappings-btn").on("click", function() {
                const supplier = $("#supplier_name").val();
                
                if (!supplier) {
                    alert("Supplier name is required for export");
                    return;
                }
                
                // Show loading
                $(this).text("Exporting...").prop("disabled", true);
                
                // Submit export request
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_export_mappings",
                        nonce: $("#kt_cigar_matcher_nonce").val(),
                        supplier: supplier
                    },
                    success: function(response) {
                        if (response.success) {
                            // Create download link
                            const blob = new Blob([response.data.csv], { type: "text/csv" });
                            const url = window.URL.createObjectURL(blob);
                            const a = document.createElement("a");
                            a.style.display = "none";
                            a.href = url;
                            a.download = response.data.filename;
                            
                            // Trigger download
                            document.body.appendChild(a);
                            a.click();
                            
                            // Clean up
                            window.URL.revokeObjectURL(url);
                            document.body.removeChild(a);
                            
                            // Reset button
                            $("#kt-export-mappings-btn").text("Export Mappings").prop("disabled", false);
                        } else {
                            alert("Error: " + response.data.message);
                            $("#kt-export-mappings-btn").text("Export Mappings").prop("disabled", false);
                        }
                    },
                    error: function(xhr, status, error) {
                        alert("Error: " + error);
                        $("#kt-export-mappings-btn").text("Export Mappings").prop("disabled", false);
                    }
                });
            });
            
            // Handle manual mapping button click
            $(document).on("click", ".manual-map-btn", function() {
                // Get product ID and title
                const productId = $(this).data("product-id");
                const productTitle = $(this).data("product-title");
                
                // Store current product for mapping
                currentSupplierProduct = {
                    id: productId,
                    title: productTitle
                };
                
                // Display product info
                $("#manual-supplier-title").text(productTitle);
                
                // Show manual mapping section
                $(".kt-cigar-matcher-process-section").hide();
                $(".kt-cigar-manual-map-section").show();
                
                // Clear any previous search results
                $(".search-results").hide();
                $(".search-results-body").empty();
                $(".search-brand-input").val("");
                $(".search-sku-input").val("");
                $(".search-by-brand").prop("disabled", true);
                $(".search-by-sku").prop("disabled", true);
            });
            
            // Enable/disable search buttons based on input
            $(document).on("input", ".search-brand-input", function() {
                const value = $(this).val().trim();
                $(this).siblings(".search-by-brand").prop("disabled", value.length < 2);
            });
            
            $(document).on("input", ".search-sku-input", function() {
                const value = $(this).val().trim();
                $(this).siblings(".search-by-sku").prop("disabled", value.length < 2);
            });
            
            // Handle search by brand button
            $(document).on("click", ".search-by-brand", function() {
                const brand = $(this).siblings(".search-brand-input").val().trim();
                
                if (brand.length < 2) {
                    return;
                }
                
                // Show loading
                $(".search-results-body").html("<tr><td colspan='3'>Searching...</td></tr>");
                $(".search-results").show();
                
                // Submit search request
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_search_brand",
                        nonce: $("#kt_cigar_matcher_nonce").val(),
                        brand: brand
                    },
                    success: function(response) {
                        if (response.success) {
                            displaySearchResults(response.data.products);
                        } else {
                            $(".search-results-body").html("<tr><td colspan='3'>Error: " + response.data.message + "</td></tr>");
                        }
                    },
                    error: function(xhr, status, error) {
                        $(".search-results-body").html("<tr><td colspan='3'>Error: " + error + "</td></tr>");
                    }
                });
            });
            
            // Handle search by SKU button
            $(document).on("click", ".search-by-sku", function() {
                const search = $(this).siblings(".search-sku-input").val().trim();
                
                if (search.length < 2) {
                    return;
                }
                
                // Show loading
                $(".search-results-body").html("<tr><td colspan='3'>Searching...</td></tr>");
                $(".search-results").show();
                
                // Submit search request
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_search_sku",
                        nonce: $("#kt_cigar_matcher_nonce").val(),
                        search: search
                    },
                    success: function(response) {
                        if (response.success) {
                            displaySearchResults(response.data.products);
                        } else {
                            $(".search-results-body").html("<tr><td colspan='3'>Error: " + response.data.message + "</td></tr>");
                        }
                    },
                    error: function(xhr, status, error) {
                        $(".search-results-body").html("<tr><td colspan='3'>Error: " + error + "</td></tr>");
                    }
                });
            });
            
            // Display search results
            function displaySearchResults(products) {
                if (!products || !products.length) {
                    $(".search-results-body").html("<tr><td colspan='3'>No matching products found</td></tr>");
                    return;
                }
                
                // Clear existing results
                $(".search-results-body").empty();
                
                // Add products to results
                $.each(products, function(i, product) {
                    let row = $("<tr>");
                    
                    // Add columns
                    row.append($("<td>").text(product.sku));
                    row.append($("<td>").text(product.title));
                    
                    // Actions column with map button
                    let actionsCell = $("<td>");
                    let mapBtn = $("<button>")
                        .attr("type", "button")
                        .addClass("button button-primary quick-map-btn")
                        .text("Map to This SKU")
                        .data("sku", product.sku);
                    
                    actionsCell.append(mapBtn);
                    row.append(actionsCell);
                    
                    // Add row to table
                    $(".search-results-body").append(row);
                });
            }
            
            // Handle quick map button click
            $(document).on("click", ".quick-map-btn", function() {
                // Get SKU
                const ktSku = $(this).data("sku");
                
                if (!currentSupplierProduct || !ktSku) {
                    alert("Error: Missing product information.");
                    return;
                }
                
                // Show loading
                $(this).text("Mapping...").prop("disabled", true);
                
                // Submit mapping request
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_quick_map",
                        nonce: $("#kt_cigar_matcher_nonce").val(),
                        supplier_id: currentSupplierProduct.id,
                        kt_sku: ktSku
                    },
                    success: function(response) {
                        if (response.success) {
                            // Update match counts
                            matchCounts.manual++;
                            $("#stats-manual").text(matchCounts.manual);
                            
                            // Show success message
                            alert("Product successfully mapped to SKU: " + ktSku);
                            
                            // Return to processing section
                            $(".kt-cigar-manual-map-section").hide();
                            $(".kt-cigar-matcher-process-section").show();
                            
                            // Update the row in the batch results table
                            updateBatchRow(currentSupplierProduct.id, ktSku, response.data.kt_title);
                        } else {
                            alert("Error: " + response.data.message);
                            $(this).text("Map to This SKU").prop("disabled", false);
                        }
                    },
                    error: function(xhr, status, error) {
                        alert("Error: " + error);
                        $(this).text("Map to This SKU").prop("disabled", false);
                    }
                });
            });
            
            // Update batch row after manual mapping
            function updateBatchRow(productId, ktSku, ktTitle) {
                // Find the row by product ID
                const row = $("#batch-results-body tr").filter(function() {
                    return $(this).find("button.manual-map-btn").data("product-id") === productId;
                });
                
                if (row.length) {
                    // Update row class
                    row.removeClass("no-match possible-match close-match exact-match")
                       .addClass("manual-match");
                    
                    // Update status cell
                    row.find(".match-status").text("Manual Match");
                    
                    // Update best match cell
                    row.find(".best-match").html(
                        $("<div>").addClass("match-info").append(
                            $("<div>").addClass("match-sku").text(ktSku),
                            $("<div>").addClass("match-title").text(ktTitle),
                            $("<div>").addClass("match-score").text("Score: Manual")
                        )
                    );
                }
            }
            
            // Handle cancel manual map button
            $("#cancel-manual-map").on("click", function() {
                // Return to processing section
                $(".kt-cigar-manual-map-section").hide();
                $(".kt-cigar-matcher-process-section").show();
            });
            
            // Add error handling for AJAX
            $(document).ajaxError(function(event, jqXHR, ajaxSettings, thrownError) {
                console.error("AJAX Error:", thrownError);
                console.error("Response:", jqXHR.responseText);
                
                try {
                    const response = JSON.parse(jqXHR.responseText);
                    if (response.data && response.data.message) {
                        $("#kt-cigar-upload-messages, #kt-cigar-process-messages")
                            .attr("class", "notice notice-error")
                            .html("<p>Error: " + response.data.message + "</p>")
                            .show();
                    }
                } catch (e) {
                  $("#kt-cigar-upload-messages, #kt-cigar-process-messages")
                        .attr("class", "notice notice-error")
                        .html("<p>Error: " + (jqXHR.responseText || thrownError) + "</p>")
                        .show();
                }
            });
        });
        </script>
        
        <style>
        /* Styles for the matcher interface */
        .kt-cigar-matcher-container {
            margin-top: 20px;
        }
        
        .logging-toggle {
            margin-bottom: 15px;
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .progress-bar {
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 3px;
            margin-bottom: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #2271b1;
            width: 0%;
            transition: width 0.5s ease-in-out;
        }
        
        .kt-cigar-process-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
			margin: 10px 0;
            padding: 10px;
            border: 1px solid #eee;
            background: #f9f9f9;
        }
        
        .batch-results-table th,
        .batch-results-table td {
            padding: 8px;
        }
        
        .supplier-title {
            font-weight: 500;
        }
        
        .match-status {
            font-weight: 500;
        }
        
        .match-info {
            margin-bottom: 10px;
        }
        
        .match-sku {
            font-weight: 600;
            margin-bottom: 3px;
        }
        
        .match-score {
            font-size: 0.9em;
            color: #666;
        }
        
        /* Status colors */
        tr.exact-match .match-status {
            color: #28a745;
            font-weight: bold;
        }
        
        tr.close-match .match-status {
            color: #0d6efd;
            font-weight: bold;
        }
        
        tr.possible-match .match-status {
            color: #ffc107;
        }
        
        tr.manual-match .match-status {
            color: #6610f2;
            font-weight: bold;
        }
        
        tr.no-match .match-status {
            color: #dc3545;
        }
        
        /* Keyword styling */
        .matched-terms-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .matched-term {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            margin: 2px;
            font-size: 0.85em;
            transition: all 0.2s ease;
            color: #333;
        }
        
        .matched-term:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Enhance color contrast for better readability */
        .matched-term[title="Brand"] {
            background-color: #e7f4ff !important; 
            border-bottom: 2px solid #2196F3;
        }
        
        .matched-term[title="Series/Model"] {
            background-color: #d4edda !important;
            border-bottom: 2px solid #28a745;
        }
        
        .matched-term[title="Vitola/Size"] {
            background-color: #fff3cd !important;
            border-bottom: 2px solid #ffc107;
        }
        
        .matched-term[title="Special Edition"] {
            background-color: #f8d7da !important;
            border-bottom: 2px solid #dc3545;
        }
        
        .matched-term[title="Year"] {
            background-color: #e2e3e5 !important;
            border-bottom: 2px solid #6c757d;
        }
        
        .matched-term[title="Count"] {
            background-color: #d0d0ff !important;
            border-bottom: 2px solid #6610f2;
        }
        
        .matched-term[title="Dimensions"] {
            background-color: #ffd8b2 !important;
            border-bottom: 2px solid #fd7e14;
        }
        
        .matched-term[title="Packaging"] {
            background-color: #ddebf7 !important;
            border-bottom: 2px solid #17a2b8;
        }
        
        .matched-term[title="Generic"] {
            background-color: #e7e7e7 !important;
            border-bottom: 2px solid #adb5bd;
        }
        
        /* Manual mapping form */
        .manual-map-form {
            margin-top: 15px;
        }
        
        .supplier-product-info {
            margin-bottom: 20px;
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid #eee;
        }
        
        .search-form {
            margin-bottom: 15px;
        }
        
        .search-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        
        .search-row label {
            min-width: 80px;
        }
        
        .search-row input {
            flex-grow: 1;
            margin-right: 10px;
        }
        
        /* Product keywords container */
        .product-keywords-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
            padding: 3px;
            border-top: 1px dashed #eee;
        }
        </style>
        <?php
    }
    
    /**
     * Display debug page
     */
    public function display_debug_page() {
        // Get page parameters
        $current_page = isset($_GET["paged"]) ? intval($_GET["paged"]) : 1;
        $brand_filter = isset($_GET["brand"]) ? sanitize_text_field($_GET["brand"]) : "";
        $sku_filter = isset($_GET["sku"]) ? sanitize_text_field($_GET["sku"]) : "";
        $title_filter = isset($_GET["title"]) ? sanitize_text_field($_GET["title"]) : "";
        
        // Get products from database
        $per_page = 50;
        $products = $this->get_database_products($current_page, $per_page, $brand_filter, $sku_filter, $title_filter);
        
        // Get brands for filter
        $brands = $this->get_unique_brands();
        
        // Get total pages
        $total_products = $this->count_database_products($brand_filter, $sku_filter, $title_filter);
        $total_pages = ceil($total_products / $per_page);
        
        // Load data file
        $data_file = $this->load_data_file();
        ?>
        <div class="wrap">
            <h1>Cigar Keyword Debug</h1>
            
            <?php if (empty($data_file)): ?>
                <div class="notice notice-error">
                    <p>Error: Data file is missing or invalid. Please check the path: <?php echo esc_html($this->data_file_path); ?></p>
                </div>
            <?php else: ?>
                <div class="notice notice-success">
                    <p>Data file loaded successfully with <?php echo count($data_file['brands']['cuban'] ?? []) + count($data_file['brands']['non_cuban'] ?? []); ?> brands.</p>
                </div>
            <?php endif; ?>
            
            <div class="keyword-category-legend" style="margin: 15px 0; padding: 10px; background: #fff; border: 1px solid #ddd; border-radius: 4px;">
                <h3>Keyword Categories:</h3>
                <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                    <?php foreach ($this->keyword_categories as $category => $details): ?>
                        <div style="display: flex; align-items: center; margin-right: 15px;">
                            <span style="display: inline-block; width: 20px; height: 20px; background-color: <?php echo $details["color"]; ?>; margin-right: 5px; border-radius: 3px;"></span>
                            <span><?php echo $details["label"]; ?></span>
                        </div>
                    <?php endforeach; ?>
                </div>
            </div>
            
            <div class="tablenav top">
                <form method="get">
                    <input type="hidden" name="page" value="<?php echo esc_attr($this->plugin_slug . "-debug"); ?>">
                    
                    <div class="alignleft actions">
                        <select name="brand">
                            <option value="">All Brands</option>
                            <?php foreach ($brands as $brand): ?>
                                <option value="<?php echo esc_attr($brand); ?>" <?php selected($brand_filter, $brand); ?>><?php echo esc_html($brand); ?></option>
                            <?php endforeach; ?>
                        </select>
                        
                        <input type="text" name="sku" placeholder="SKU contains..." value="<?php echo esc_attr($sku_filter); ?>">
                        <input type="text" name="title" placeholder="Title contains..." value="<?php echo esc_attr($title_filter); ?>">
                        
                        <input type="submit" class="button" value="Filter">
                        <?php if (!empty($brand_filter) || !empty($sku_filter) || !empty($title_filter)): ?>
                            <a href="?page=<?php echo esc_attr($this->plugin_slug . "-debug"); ?>" class="button">Reset</a>
                        <?php endif; ?>
                    </div>
                </form>
                
                <div class="tablenav-pages">
                    <span class="displaying-num"><?php echo number_format($total_products); ?> items</span>
                    <span class="pagination-links">
                        <?php if ($current_page > 1): ?>
                            <a class="prev-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-debug"); ?>&paged=<?php echo $current_page - 1; ?>&brand=<?php echo esc_attr($brand_filter); ?>&sku=<?php echo esc_attr($sku_filter); ?>&title=<?php echo esc_attr($title_filter); ?>">‹</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">‹</span>
                        <?php endif; ?>
                        
                        <span class="paging-input">
                            <?php echo $current_page; ?> of <span class="total-pages"><?php echo $total_pages; ?></span>
                        </span>
                        
                        <?php if ($current_page < $total_pages): ?>
                            <a class="next-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-debug"); ?>&paged=<?php echo $current_page + 1; ?>&brand=<?php echo esc_attr($brand_filter); ?>&sku=<?php echo esc_attr($sku_filter); ?>&title=<?php echo esc_attr($title_filter); ?>">›</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">›</span>
                        <?php endif; ?>
                    </span>
                </div>
                <br class="clear">
            </div>
            
            <div class="supplier-debug-tool">
                <h2>Test Product Title Analysis</h2>
                <form method="post" action="">
                    <p>
                        <label for="test_title">Product Title:</label><br>
                        <input type="text" name="test_title" id="test_title" style="width: 50%;" value="<?php echo isset($_POST["test_title"]) ? esc_attr($_POST["test_title"]) : ""; ?>">
                    </p>
                    <p>
                        <label for="test_dimensions">Dimensions (e.g. 50/124):</label><br>
                        <input type="text" name="test_dimensions" id="test_dimensions" value="<?php echo isset($_POST["test_dimensions"]) ? esc_attr($_POST["test_dimensions"]) : ""; ?>">
                    </p>
                    <p>
                        <input type="submit" class="button button-primary" value="Analyze Title">
                    </p>
                </form>
                
                <?php if (isset($_POST["test_title"])): ?>
                    <?php
                    $test_title = sanitize_text_field($_POST["test_title"]);
                    $test_dimensions = isset($_POST["test_dimensions"]) ? sanitize_text_field($_POST["test_dimensions"]) : "";
                    
                    // Use KT_Cigar_Mappings for processing if available
                    if (class_exists('KT_Cigar_Mappings')) {
                        $processed_product = KT_Cigar_Mappings::process_supplier_product($test_title, $test_dimensions);
                    } else {
                        // Fallback to our own method
                        $processed_product = $this->process_product_title_enhanced($test_title, $test_dimensions);
                    }
                    ?>
                    <div class="supplier-results" style="margin-top: 20px; padding: 15px; background: #f9f9f9; border: 1px solid #ddd;">
                        <h3>Title Analysis: <?php echo esc_html($test_title); ?></h3>
                        <table class="wp-list-table widefat fixed">
                            <tr>
                                <th width="200">Property</th>
                                <th>Value</th>
                            </tr>
                            <tr>
                                <td>Brand:</td>
                                <td><?php echo esc_html($processed_product["brand"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Series/Model:</td>
                                <td><?php echo esc_html($processed_product["model"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Vitola:</td>
                                <td><?php echo esc_html($processed_product["vitola"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Year:</td>
                                <td><?php echo esc_html($processed_product["year"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Special Edition:</td>
                                <td><?php echo esc_html($processed_product["special_edition"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Count:</td>
                                <td><?php echo esc_html($processed_product["count"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Ring Gauge:</td>
                                <td><?php echo esc_html($processed_product["dimension_info"]["ring_gauge"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Length:</td>
                                <td><?php echo esc_html($processed_product["dimension_info"]["length"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Extracted Keywords:</td>
                                <td>
                                    <?php if (!empty($processed_product["keywords"])): ?>
                                        <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                                            <?php 
                                            // Display each keyword with its categories
                                            foreach ($processed_product["keywords"] as $keyword): 
                                                echo $this->display_categorized_keyword($keyword, $processed_product, $data_file);
                                            ?>
                                            <?php endforeach; ?>
                                        </div>
                                    <?php else: ?>
                                        No keywords extracted
                                    <?php endif; ?>
                                </td>
                            </tr>
                        </table>
                    </div>
                <?php endif; ?>
            </div>
            
            <h2>Database Products</h2>
            
            <table class="wp-list-table widefat fixed striped">
                <thead>
                    <tr>
                        <th width="15%">SKU</th>
                        <th width="15%">Brand</th>
                        <th width="20%">Title</th>
                        <th width="10%">Dimensions</th>
                        <th width="40%">Extracted Keywords</th>
                    </tr>
                </thead>
                <tbody>
                    <?php if (empty($products)): ?>
                        <tr>
                            <td colspan="5">No products found</td>
                        </tr>
                    <?php else: ?>
                        <?php foreach ($products as $product): 
                            // Extract dimensions
                            $dimensions = "";
                            if (!empty($product->seat_row) || !empty($product->seat_number)) {
                               $dimensions = (!empty($product->seat_row) ? $product->seat_row : "") . "/" . 
                                           (!empty($product->seat_number) ? $product->seat_number : "");
                            }
                            
                            // Process product to extract keywords
                            if (class_exists('KT_Cigar_Mappings')) {
                                $processed_product = KT_Cigar_Mappings::process_internal_product(
                                    $product->sku,
                                    $product->product_title,
                                    $dimensions
                                );
                            } else {
                                $processed_product = $this->process_product_title_enhanced(
                                    $product->product_title,
                                    $dimensions
                                );
                            }
                            $keywords = $processed_product["keywords"] ?? array();
                        ?>
                            <tr>
                                <td><?php echo esc_html($product->sku); ?></td>
                                <td><?php echo esc_html($product->brand); ?></td>
                                <td><?php echo esc_html($product->product_title); ?></td>
                                <td><?php echo esc_html($dimensions); ?></td>
                                <td>
                                    <?php if (!empty($keywords)): ?>
                                        <div style="display: flex; flex-wrap: wrap; gap: 5px; max-height: 100px; overflow-y: auto;">
                                            <?php 
                                            // Display each keyword with its categories
                                            foreach ($keywords as $keyword): 
                                                echo $this->display_categorized_keyword($keyword, $processed_product, $data_file);
                                            ?>
                                            <?php endforeach; ?>
                                        </div>
                                    <?php else: ?>
                                        No keywords extracted
                                    <?php endif; ?>
                                </td>
                            </tr>
                        <?php endforeach; ?>
                    <?php endif; ?>
                </tbody>
            </table>
            
            <div class="tablenav bottom">
                <div class="tablenav-pages">
                    <span class="displaying-num"><?php echo number_format($total_products); ?> items</span>
                    <span class="pagination-links">
                        <?php if ($current_page > 1): ?>
                            <a class="prev-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-debug"); ?>&paged=<?php echo $current_page - 1; ?>&brand=<?php echo esc_attr($brand_filter); ?>&sku=<?php echo esc_attr($sku_filter); ?>&title=<?php echo esc_attr($title_filter); ?>">‹</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">‹</span>
                        <?php endif; ?>
                        
                        <span class="paging-input">
                            <?php echo $current_page; ?> of <span class="total-pages"><?php echo $total_pages; ?></span>
                        </span>
                        
                        <?php if ($current_page < $total_pages): ?>
                            <a class="next-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-debug"); ?>&paged=<?php echo $current_page + 1; ?>&brand=<?php echo esc_attr($brand_filter); ?>&sku=<?php echo esc_attr($sku_filter); ?>&title=<?php echo esc_attr($title_filter); ?>">›</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">›</span>
                        <?php endif; ?>
                    </span>
                </div>
            </div>
        </div>
        <?php
    }
	/**
     * Display mappings page
     */
    public function display_mappings_page() {
        // Get page parameters
        $current_page = isset($_GET["paged"]) ? intval($_GET["paged"]) : 1;
        $supplier_filter = isset($_GET["supplier"]) ? sanitize_text_field($_GET["supplier"]) : "";
        $confidence_filter = isset($_GET["confidence"]) ? sanitize_text_field($_GET["confidence"]) : "";
        $search_filter = isset($_GET["search"]) ? sanitize_text_field($_GET["search"]) : "";
        
        // Get mappings per page
        $per_page = 30;
        
        // Get suppliers for filter
        global $wpdb;
        $suppliers = $wpdb->get_col("SELECT DISTINCT supplier_name FROM {$wpdb->prefix}{$this->mapping_table} ORDER BY supplier_name ASC");
        
        // Get total mappings count
        $total_mappings = $this->count_mappings($supplier_filter, $confidence_filter, $search_filter);
        $total_pages = ceil($total_mappings / $per_page);
        
        // Get mappings for current page
        $mappings = $this->get_mappings($current_page, $per_page, $supplier_filter, $confidence_filter, $search_filter);
        
        ?>
        <div class="wrap">
            <h1>Supplier Mappings</h1>
            
            <div class="tablenav top">
                <form method="get">
                    <input type="hidden" name="page" value="<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>">
                    
                    <div class="alignleft actions">
                        <select name="supplier">
                            <option value="">All Suppliers</option>
                            <?php foreach ($suppliers as $supplier): ?>
                                <option value="<?php echo esc_attr($supplier); ?>" <?php selected($supplier_filter, $supplier); ?>><?php echo esc_html($supplier); ?></option>
                            <?php endforeach; ?>
                        </select>
                        
                        <select name="confidence">
                            <option value="">All Confidence Levels</option>
                            <option value="exact" <?php selected($confidence_filter, "exact"); ?>>Exact Matches</option>
                            <option value="close" <?php selected($confidence_filter, "close"); ?>>Close Matches</option>
                            <option value="possible" <?php selected($confidence_filter, "possible"); ?>>Possible Matches</option>
                            <option value="manual" <?php selected($confidence_filter, "manual"); ?>>Manual Matches</option>
                        </select>
                        
                        <input type="text" name="search" placeholder="Search..." value="<?php echo esc_attr($search_filter); ?>">
                        
                        <input type="submit" class="button" value="Filter">
                        <?php if (!empty($supplier_filter) || !empty($confidence_filter) || !empty($search_filter)): ?>
                            <a href="?page=<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>" class="button">Reset</a>
                        <?php endif; ?>
                    </div>
                </form>
                
                <div class="tablenav-pages">
                    <span class="displaying-num"><?php echo number_format($total_mappings); ?> items</span>
                    <span class="pagination-links">
                        <?php if ($current_page > 1): ?>
                            <a class="prev-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>&paged=<?php echo $current_page - 1; ?>&supplier=<?php echo esc_attr($supplier_filter); ?>&confidence=<?php echo esc_attr($confidence_filter); ?>&search=<?php echo esc_attr($search_filter); ?>">‹</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">‹</span>
                        <?php endif; ?>
                        
                        <span class="paging-input">
                            <?php echo $current_page; ?> of <span class="total-pages"><?php echo $total_pages; ?></span>
                        </span>
                        
                        <?php if ($current_page < $total_pages): ?>
                            <a class="next-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>&paged=<?php echo $current_page + 1; ?>&supplier=<?php echo esc_attr($supplier_filter); ?>&confidence=<?php echo esc_attr($confidence_filter); ?>&search=<?php echo esc_attr($search_filter); ?>">›</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">›</span>
                        <?php endif; ?>
                    </span>
                </div>
                <br class="clear">
            </div>
            
            <table class="wp-list-table widefat fixed striped">
                <thead>
                    <tr>
                        <th width="15%">Supplier</th>
                        <th width="10%">Supplier ID</th>
                        <th width="20%">Supplier Title</th>
                        <th width="10%">KT SKU</th>
                        <th width="10%">Confidence</th>
                        <th width="25%">Matched Terms</th>
                        <th width="10%">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <?php if (empty($mappings)): ?>
                        <tr>
                            <td colspan="7">No mappings found</td>
                        </tr>
                    <?php else: ?>
                        <?php foreach ($mappings as $mapping): ?>
                            <tr>
                                <td><?php echo esc_html($mapping->supplier_name); ?></td>
                                <td><?php echo esc_html($mapping->supplier_id); ?></td>
                                <td><?php echo esc_html($mapping->supplier_title); ?></td>
                                <td><?php echo esc_html($mapping->kt_sku); ?></td>
                                <td>
                                    <?php 
                                    $confidence_class = "";
                                    switch ($mapping->match_confidence) {
                                        case "exact": $confidence_class = "exact-match"; break;
                                        case "close": $confidence_class = "close-match"; break;
                                        case "possible": $confidence_class = "possible-match"; break;
                                        case "manual": $confidence_class = "manual-match"; break;
                                        default: $confidence_class = "no-match";
                                    }
                                    ?>
                                    <span class="<?php echo $confidence_class; ?>-text"><?php echo ucfirst(esc_html($mapping->match_confidence)); ?></span>
                                </td>
                                <td>
                                    <?php if (!empty($mapping->matched_terms)): ?>
                                        <div class="matched-terms-list">
                                            <?php 
                                            $terms = explode(",", $mapping->matched_terms);
                                            $data_file = $this->load_data_file();
                                            
                                            foreach ($terms as $term) {
                                                $term = trim($term);
                                                // Process product to get category info 
                                                $processed_product = array();
                                                if (class_exists('KT_Cigar_Mappings')) {
                                                    // Use KT_Cigar_Mappings for processing
                                                    $processed_product = KT_Cigar_Mappings::process_supplier_product($term);
                                                } else {
                                                    // Use our own method
                                                    $processed_product = $this->process_product_title_enhanced($term);
                                                }
                                                
                                                echo $this->display_categorized_keyword($term, $processed_product, $data_file);
                                            }
                                            ?>
                                        </div>
                                    <?php else: ?>
                                        <em>No matched terms</em>
                                    <?php endif; ?>
                                </td>
                                <td>
                                    <button type="button" class="button delete-mapping-btn" data-id="<?php echo $mapping->id; ?>">Delete</button>
                                </td>
                            </tr>
                        <?php endforeach; ?>
                    <?php endif; ?>
                </tbody>
            </table>
            
            <div class="tablenav bottom">
                <div class="tablenav-pages">
                    <span class="displaying-num"><?php echo number_format($total_mappings); ?> items</span>
                    <span class="pagination-links">
                        <?php if ($current_page > 1): ?>
                            <a class="prev-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>&paged=<?php echo $current_page - 1; ?>&supplier=<?php echo esc_attr($supplier_filter); ?>&confidence=<?php echo esc_attr($confidence_filter); ?>&search=<?php echo esc_attr($search_filter); ?>">‹</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">‹</span>
                        <?php endif; ?>
                        
                        <span class="paging-input">
                            <?php echo $current_page; ?> of <span class="total-pages"><?php echo $total_pages; ?></span>
                        </span>
                        
                        <?php if ($current_page < $total_pages): ?>
                            <a class="next-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>&paged=<?php echo $current_page + 1; ?>&supplier=<?php echo esc_attr($supplier_filter); ?>&confidence=<?php echo esc_attr($confidence_filter); ?>&search=<?php echo esc_attr($search_filter); ?>">›</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">›</span>
                        <?php endif; ?>
                    </span>
                </div>
            </div>
        </div>
        
        <script>
        jQuery(document).ready(function($) {
            // Delete mapping button
            $(".delete-mapping-btn").on("click", function() {
                if (confirm("Are you sure you want to delete this mapping?")) {
                    const mappingId = $(this).data("id");
                    
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_delete_mapping",
                            nonce: "<?php echo wp_create_nonce("kt-cigar-matcher-nonce"); ?>",
                            mapping_id: mappingId
                        },
                        success: function(response) {
                            if (response.success) {
                                alert("Mapping deleted successfully");
                                location.reload();
                            } else {
                                alert("Error: " + response.data.message);
                            }
                        },
                        error: function(xhr, status, error) {
                            alert("Error: " + error);
                        }
                    });
                }
            });
        });
        </script>
        
        <style>
        .matched-terms-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .exact-match-text {
            color: #28a745;
            font-weight: bold;
        }
        
        .close-match-text {
            color: #0d6efd;
            font-weight: bold;
        }
        
        .possible-match-text {
            color: #ffc107;
        }
        
        .manual-match-text {
            color: #6610f2;
            font-weight: bold;
        }
        
        .no-match-text {
            color: #dc3545;
        }
        </style>
        <?php
    }
    
    /**
     * Display templates page
     */
    public function display_templates_page() {
        // Get templates
        global $wpdb;
        $templates = $wpdb->get_results("SELECT * FROM {$wpdb->prefix}{$this->template_table} ORDER BY template_name ASC");
        
        ?>
        <div class="wrap">
            <h1>CSV Templates</h1>
            
            <div class="template-form-container">
                <h2>Create New Template</h2>
                
                <form id="kt-cigar-template-form">
                    <?php wp_nonce_field("kt-cigar-matcher-nonce", "kt_cigar_matcher_nonce"); ?>
                    
                    <input type="hidden" name="template_id" id="template_id" value="">
                    
                    <table class="form-table">
                        <tr>
                            <th><label for="template_name">Template Name:</label></th>
                            <td>
                                <input type="text" id="template_name" name="template_name" required>
                                <p class="description">Enter a unique name for this template</p>
                            </td>
                        </tr>
                        <tr>
                            <th><label for="supplier_name">Supplier Name:</label></th>
                            <td>
                                <input type="text" id="supplier_name" name="supplier_name" required>
                                <p class="description">Enter the supplier name for this template</p>
                            </td>
                        </tr>
                    </table>
                    
                    <h3>Column Mappings</h3>
                    <p class="description">Map supplier CSV columns to KT Cigar fields</p>
                    
                    <table class="wp-list-table widefat fixed" id="column-mappings-table">
                        <thead>
                            <tr>
                                <th width="40%">Supplier CSV Column</th>
                                <th width="40%">KT Cigar Field</th>
                                <th width="20%">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <input type="text" name="csv_columns[]" class="regular-text" required>
                                </td>
                                <td>
                                    <select name="kt_fields[]" required>
                                        <option value="">-- Select Field --</option>
                                        <option value="id">Product ID</option>
                                        <option value="title">Product Title</option>
                                        <option value="brand">Brand</option>
                                        <option value="model">Model/Series</option>
                                        <option value="ring_gauge">Ring Gauge</option>
                                        <option value="length">Length</option>
                                        <option value="price">Price</option>
                                        <option value="description">Description</option>
                                        <option value="stock">Stock</option>
                                        <option value="skip">Skip (Ignore this column)</option>
                                    </select>
                                </td>
                                <td>
                                    <button type="button" class="button remove-mapping-row">Remove</button>
                                </td>
                            </tr>
                        </tbody>
                        <tfoot>
                            <tr>
                                <td colspan="3">
                                    <button type="button" class="button" id="add-mapping-row">Add Column Mapping</button>
                                </td>
                            </tr>
                        </tfoot>
                    </table>
                    
                    <p class="submit">
                        <button type="submit" class="button button-primary" id="save-template-btn">Save Template</button>
                        <button type="button" class="button" id="cancel-edit-btn" style="display: none;">Cancel Edit</button>
                    </p>
                </form>
            </div>
            
            <h2>Saved Templates</h2>
            
            <table class="wp-list-table widefat fixed striped">
                <thead>
                    <tr>
                        <th width="25%">Template Name</th>
                        <th width="20%">Supplier</th>
                        <th width="30%">Column Mappings</th>
                        <th width="15%">Created</th>
                        <th width="10%">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <?php if (empty($templates)): ?>
                        <tr>
                            <td colspan="5">No templates found</td>
                        </tr>
                    <?php else: ?>
                        <?php foreach ($templates as $template): 
                            $column_mappings = json_decode($template->column_mappings, true);
                        ?>
                            <tr>
                                <td><?php echo esc_html($template->template_name); ?></td>
                                <td><?php echo esc_html($template->supplier_name); ?></td>
                                <td>
                                    <?php if (!empty($column_mappings)): ?>
                                        <div class="column-mappings-preview">
                                            <?php 
                                            foreach ($column_mappings as $mapping) {
                                                echo esc_html($mapping["csv_column"] . " → " . $mapping["kt_field"]) . "<br>";
                                            }
                                            ?>
                                        </div>
                                    <?php else: ?>
                                        <em>No mappings defined</em>
                                    <?php endif; ?>
                                </td>
                                <td><?php echo date("Y-m-d", strtotime($template->created_at)); ?></td>
                                <td>
                                    <button type="button" class="button edit-template-btn" data-id="<?php echo $template->id; ?>">Edit</button>
                                    <button type="button" class="button delete-template-btn" data-id="<?php echo $template->id; ?>">Delete</button>
                                </td>
                            </tr>
                        <?php endforeach; ?>
                    <?php endif; ?>
                </tbody>
            </table>
        </div>
        
        <script>
        jQuery(document).ready(function($) {
            // Add mapping row
            $("#add-mapping-row").on("click", function() {
                const row = `
                <tr>
                    <td>
                        <input type="text" name="csv_columns[]" class="regular-text" required>
                    </td>
                    <td>
                        <select name="kt_fields[]" required>
                            <option value="">-- Select Field --</option>
                            <option value="id">Product ID</option>
                            <option value="title">Product Title</option>
                            <option value="brand">Brand</option>
                            <option value="model">Model/Series</option>
                            <option value="ring_gauge">Ring Gauge</option>
                            <option value="length">Length</option>
                            <option value="price">Price</option>
                            <option value="description">Description</option>
                            <option value="stock">Stock</option>
                            <option value="skip">Skip (Ignore this column)</option>
                        </select>
                    </td>
                    <td>
                        <button type="button" class="button remove-mapping-row">Remove</button>
                    </td>
                </tr>
                `;
                
                $("#column-mappings-table tbody").append(row);
            });
            
            // Remove mapping row
            $(document).on("click", ".remove-mapping-row", function() {
                const rowCount = $("#column-mappings-table tbody tr").length;
                
                if (rowCount > 1) {
                    $(this).closest("tr").remove();
                } else {
                    alert("You must have at least one column mapping");
                }
            });
            
            // Save template
            $("#kt-cigar-template-form").on("submit", function(e) {
                e.preventDefault();
                
                // Validate form
                const templateName = $("#template_name").val().trim();
                const supplierName = $("#supplier_name").val().trim();
                
                if (!templateName || !supplierName) {
                    alert("Template name and supplier name are required");
                    return;
                }
                
                // Get column mappings
                const columnMappings = [];
                
                $("#column-mappings-table tbody tr").each(function() {
                    const csvColumn = $(this).find("input[name='csv_columns[]']").val().trim();
                    const ktField = $(this).find("select[name='kt_fields[]']").val();
                    
                    if (csvColumn && ktField) {
                        columnMappings.push({
                            csv_column: csvColumn,
                            kt_field: ktField
                        });
                    }
                });
                
                if (columnMappings.length === 0) {
                    alert("You must define at least one column mapping");
                    return;
                }
                
                // Get template ID (if editing)
                const templateId = $("#template_id").val();
                
                // Show loading
                $("#save-template-btn").text("Saving...").prop("disabled", true);
                
                // Submit request
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_save_template",
                        nonce: $("#kt_cigar_matcher_nonce").val(),
                        template_id: templateId,
                        template_name: templateName,
                        supplier_name: supplierName,
                        column_mappings: JSON.stringify(columnMappings)
                    },
                    success: function(response) {
                        if (response.success) {
                            alert("Template saved successfully");
                            location.reload();
                        } else {
                            alert("Error: " + response.data.message);
                            $("#save-template-btn").text("Save Template").prop("disabled", false);
                        }
                    },
                    error: function(xhr, status, error) {
                        alert("Error: " + error);
                        $("#save-template-btn").text("Save Template").prop("disabled", false);
                    }
                });
            });
            
            // Edit template
            $(".edit-template-btn").on("click", function() {
                const templateId = $(this).data("id");
                
                // Show loading
                $(this).text("Loading...").prop("disabled", true);
                
                // Submit request
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_load_template",
                        nonce: $("#kt_cigar_matcher_nonce").val(),
                        template_id: templateId
                    },
                    success: function(response) {
                        if (response.success) {
                            // Populate form
                            $("#template_id").val(response.data.id);
                            $("#template_name").val(response.data.template_name);
                            $("#supplier_name").val(response.data.supplier_name);
                            
                            // Clear existing rows
                            $("#column-mappings-table tbody").empty();
                            
                            // Add mapping rows
                            const columnMappings = JSON.parse(response.data.column_mappings);
                            
                            columnMappings.forEach(function(mapping) {
                                const row = `
                                <tr>
                                    <td>
                                        <input type="text" name="csv_columns[]" class="regular-text" value="${mapping.csv_column}" required>
                                    </td>
                                    <td>
                                        <select name="kt_fields[]" required>
                                            <option value="">-- Select Field --</option>
                                            <option value="id" ${mapping.kt_field === "id" ? "selected" : ""}>Product ID</option>
                                            <option value="title" ${mapping.kt_field === "title" ? "selected" : ""}>Product Title</option>
                                            <option value="brand" ${mapping.kt_field === "brand" ? "selected" : ""}>Brand</option>
                                            <option value="model" ${mapping.kt_field === "model" ? "selected" : ""}>Model/Series</option>
                                            <option value="ring_gauge" ${mapping.kt_field === "ring_gauge" ? "selected" : ""}>Ring Gauge</option>
                                            <option value="length" ${mapping.kt_field === "length" ? "selected" : ""}>Length</option>
                                            <option value="price" ${mapping.kt_field === "price" ? "selected" : ""}>Price</option>
                                            <option value="description" ${mapping.kt_field === "description" ? "selected" : ""}>Description</option>
                                            <option value="stock" ${mapping.kt_field === "stock" ? "selected" : ""}>Stock</option>
                                            <option value="skip" ${mapping.kt_field === "skip" ? "selected" : ""}>Skip (Ignore this column)</option>
                                        </select>
                                    </td>
                                    <td>
                                        <button type="button" class="button remove-mapping-row">Remove</button>
                                    </td>
                                </tr>
                                `;
                                
                                $("#column-mappings-table tbody").append(row);
                            });
                            
                            // Show cancel button
                            $("#save-template-btn").text("Update Template");
                            $("#cancel-edit-btn").show();
                            
                            // Scroll to form
                            $("html, body").animate({
                                scrollTop: $(".template-form-container").offset().top
                            }, 500);
                            
                            $(".edit-template-btn").text("Edit").prop("disabled", false);
                        } else {
                            alert("Error: " + response.data.message);
                            $(".edit-template-btn").text("Edit").prop("disabled", false);
                        }
                    },
                    error: function(xhr, status, error) {
                        alert("Error: " + error);
                        $(".edit-template-btn").text("Edit").prop("disabled", false);
                    }
                });
            });
            
            // Cancel edit
            $("#cancel-edit-btn").on("click", function() {
                // Clear form
                $("#template_id").val("");
                $("#template_name").val("");
                $("#supplier_name").val("");
                
                // Clear existing rows
                $("#column-mappings-table tbody").empty();
                
                // Add default row
                $("#add-mapping-row").trigger("click");
                
                // Hide cancel button
                $("#save-template-btn").text("Save Template");
                $("#cancel-edit-btn").hide();
            });
            
            // Delete template
            $(".delete-template-btn").on("click", function() {
                if (confirm("Are you sure you want to delete this template?")) {
                    const templateId = $(this).data("id");
                    
                    // Show loading
                    $(this).text("Deleting...").prop("disabled", true);
                    
                    // Submit request
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_delete_template",
                            nonce: $("#kt_cigar_matcher_nonce").val(),
                            template_id: templateId
                        },
                        success: function(response) {
                            if (response.success) {
                                alert("Template deleted successfully");
                                location.reload();
                            } else {
                                alert("Error: " + response.data.message);
                                $(".delete-template-btn").text("Delete").prop("disabled", false);
                            }
                        },
                        error: function(xhr, status, error) {
                            alert("Error: " + error);
                            $(".delete-template-btn").text("Delete").prop("disabled", false);
                        }
                    });
                }
            });
            
            // Initialize with one row
            if ($("#column-mappings-table tbody tr").length === 0) {
                $("#add-mapping-row").trigger("click");
            }
        });
        </script>
        
        <style>
        .template-form-container {
            margin-bottom: 30px;
            padding: 15px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .column-mappings-preview {
            max-height: 100px;
            overflow-y: auto;
        }
        </style>
        <?php
    }
    
    /**
     * Display a categorized keyword with styling
     * 
     * @param string $keyword The keyword to display
     * @param array $product Processed product data
     * @param array $data_file Data file with mappings
     * @return string HTML markup for the categorized keyword
     */
    private function display_categorized_keyword($keyword, $product, $data_file) {
        // Get the categories for this keyword
        $categories = $this->determine_keyword_categories($keyword, $product, $data_file);
        
        // Primary category (first in the array)
        $primary_category = !empty($categories) ? $categories[0] : 'generic';
        $primary_color = $this->keyword_categories[$primary_category]['color'];
        $primary_label = $this->keyword_categories[$primary_category]['label'];
        
        // Format keyword for display
        $display_keyword = $keyword;
        if (preg_match('/^([A-Z_]+):(.+)$/i', $keyword, $matches)) {
            $display_keyword = trim($matches[2]); // Show just the value, not the tag
        }
        
        // If there's only one category, display as before
        if (count($categories) <= 1) {
            $html = '<span style="background: ' . $primary_color . '; padding: 3px 8px; border-radius: 3px; display: inline-block; margin: 2px;" title="' . $primary_label . '">' . esc_html($display_keyword) . '</span>';
        } else {
            // For multiple categories, create a more complex display
            $html = '<span style="';
            
            // Add primary category background
            $html .= 'background: ' . $primary_color . '; ';
            
            // If there are additional categories, add a subtle indicator
            if (count($categories) > 1) {
                // Add a colored border for the secondary category
                $secondary_category = $categories[1];
                $secondary_color = $this->keyword_categories[$secondary_category]['color'];
                $html .= 'border: 2px solid ' . $secondary_color . '; ';
            }
            
            // Complete the styling
            $html .= 'padding: 3px 8px; border-radius: 3px; display: inline-block; margin: 2px; position: relative;" ';
            
            // Add all categories as a title attribute
            $title_parts = [];
            foreach ($categories as $category) {
                $title_parts[] = $this->keyword_categories[$category]['label'];
            }
            $html .= 'title="' . implode(", ", $title_parts) . '">' . esc_html($display_keyword);
            
            // If there are more than two categories, add a small indicator
            if (count($categories) > 2) {
                $html .= ' <sup style="font-size: 8px; position: relative; top: -3px; color: #666;">+' . (count($categories) - 1) . '</sup>';
            }
            
            $html .= '</span>';
        }
        
        return $html;
    }
    
    /**
     * Determine the categories for a keyword
     * 
     * @param string $keyword The keyword to categorize
     * @param array $product The processed product data
     * @param array $data_file The data file with mappings
     * @return array Array of applicable categories
     */
    private function determine_keyword_categories($keyword, $product, $data_file) {
        // First check for tagged keywords which have explicit categorization - this is the most reliable
        if (preg_match('/^([A-Z_]+):(.+)$/i', $keyword, $matches)) {
            $tag = strtoupper($matches[1]);
            $value = $matches[2];
            
            // Direct mapping of tags to categories - prioritize explicit tags
            switch ($tag) {
                case 'BRAND':
                    return ['brand'];
                case 'BRAND_VAR':
                    return ['brand'];
                case 'SERIES':
                    return ['model'];
                case 'VITOLA':
                    return ['vitola'];
                case 'SPECIAL':
                    return ['special_edition'];
                case 'YEAR':
                    return ['year'];
                case 'COUNT':
                    return ['count'];
                case 'DIM':
                    return ['dimensions'];
                case 'PACK':
                    return ['packaging'];
                case 'GENERIC':
                    return ['generic'];
                case 'NUM':
                    // For numbers, look at value to determine if it's count, ring, length, etc.
                    if ((int)$value >= 20 && (int)$value <= 70) {
                        return ['dimensions']; // Likely ring gauge
                    } else if ((int)$value >= 4 && (int)$value <= 9) {
                        return ['dimensions']; // Likely length
                    } else if ((int)$value >= 1900 && (int)$value <= date('Y')) {
                        return ['year']; // Likely year
                    } else if ((int)$value >= 5 && (int)$value <= 50) {
                        return ['count']; // Likely count
                    }
                    return ['generic'];
                case 'FULL':
                    return ['generic']; // The full text is just for reference
                default:
                    // If unknown tag, proceed with normal categorization
                    $keyword = $value; // Use the value part for further processing
                    break;
            }
        }
        
        // For keywords without tags or with unknown tags, perform normal categorization
        // Convert keyword to lowercase for case-insensitive comparison
        $keyword_lower = strtolower(trim($keyword));
        $product_brand = !empty($product["brand"]) ? strtolower(trim($product["brand"])) : '';
        
        // Array to store all matched categories
        $matched_categories = [];
        
        // Step 1: Check for exact structured data matches first
        if (strpos($keyword, 'BRAND:') === 0 || strpos($keyword, 'SPECIAL:') === 0) {
            // This is a directly tagged keyword, return the appropriate category
            $tag_parts = explode(':', $keyword, 2);
            $tag = strtoupper($tag_parts[0]);
            
            switch ($tag) {
                case 'BRAND': return ['brand'];
                case 'SPECIAL': return ['special_edition'];
                case 'VITOLA': return ['vitola'];
                case 'PACK': return ['packaging'];
                case 'COUNT': return ['count'];
                case 'YEAR': return ['year'];
                case 'DIM': return ['dimensions'];
                case 'GENERIC': return ['generic'];
                default: break;
            }
        }
        
        // Step 2: Check for clear dimension patterns (highest confidence)
        if ($this->is_clear_dimension($keyword_lower)) {
            return ['dimensions']; // Definitive dimension pattern
        }
        
        // Step 3: Check for clear count patterns (high confidence)
        if ($this->is_clear_count($keyword_lower)) {
            return ['count']; // Definitive count pattern
        }
        
        // Step 4: CRITICAL - Check if this keyword is another brand (not the product's brand)
        // If it is, skip further categorization to prevent cross-brand contamination
        if ($this->is_any_brand($keyword_lower, $data_file) && !$this->is_exact_brand_match($keyword_lower, $product_brand, $data_file)) {
            return ['generic']; // Force generic category for other brands to prevent contamination
        }
        
        // Step 5: Brand check with strict brand matching
        // Only categorize as brand if it matches the product's brand exactly
        if (!empty($product_brand) && $this->is_exact_brand_match($keyword_lower, $product_brand, $data_file)) {
            return ['brand']; // Early return - if it's a brand match, this is definitive
        }
        
        // Step 6: Series/Model check - only for the product's brand
        if (!empty($product_brand) && $this->is_series_for_brand($keyword_lower, $product_brand, $data_file)) {
            return ['model']; // Early return - if it's a series match, this is definitive
        }
        
        // Step 7: Vitola/Size check
        if ($this->is_vitola($keyword_lower, $data_file)) {
            $matched_categories[] = 'vitola';
        }
        
        // Step 8: Special Edition check
        if ($this->is_special_edition($keyword_lower, $data_file)) {
            $matched_categories[] = 'special_edition';
        }
        
        // Step 9: Year check - more precise year detection
        if ($this->is_year1($keyword_lower, $data_file) || 
            (is_numeric($keyword_lower) && (int)$keyword_lower >= 1900 && (int)$keyword_lower <= date('Y'))) {
            $matched_categories[] = 'year';
        }
        
        // Step 10: Dimension check for numeric values
        if (is_numeric($keyword_lower)) {
            $num = (int)$keyword_lower;
            if ($num >= 20 && $num <= 70) {
                // Likely a ring gauge
                $matched_categories[] = 'dimensions';
            } else if ($num >= 80 && $num <= 210) {
                // Likely a length
                $matched_categories[] = 'dimensions';
            } else if ($this->might_be_dimension($keyword_lower, $product)) {
                // Check product context for dimensions
                $matched_categories[] = 'dimensions';
            }
        }
        
        // Step 11: Count check for numeric values
        if (is_numeric($keyword_lower)) {
            $num = (int)$keyword_lower;
            if ($num >= 1 && $num <= 50 && $this->might_be_count($keyword_lower)) {
                $matched_categories[] = 'count';
            }
        }
        
        // Step 12: Check packaging last
        if ($this->is_packaging($keyword_lower, $data_file)) {
            $matched_categories[] = 'packaging';
        }
        
        // If we found multiple categories, prioritize them
        if (!empty($matched_categories)) {
            return $this->prioritize_categories($matched_categories, $keyword, $product);
        }
        
        // If no category was matched, return generic
        return ['generic'];
    }
    
    /**
     * Check if a keyword matches ANY brand in the data file
     */
    private function is_any_brand($keyword, $data_file) {
        if (empty($keyword) || empty($data_file)) {
            return false;
        }
        
        $keyword = strtolower(trim($keyword));
        
        // Check if it's a direct brand name
        foreach ($data_file['brands']['cuban'] as $brand => $variations) {
            if (strtolower($brand) === $keyword) {
                return true;
            }
            
            // Check variations
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        foreach ($data_file['brands']['non_cuban'] as $brand => $variations) {
            if (strtolower($brand) === $keyword) {
                return true;
            }
            
            // Check variations
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        // Check brand aliases
        if (!empty($data_file['brand_aliases'])) {
            foreach ($data_file['brand_aliases'] as $alias => $brand_name) {
                if (strtolower($alias) === $keyword) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check for exact brand match - much stricter than the regular version
     */
    private function is_exact_brand_match($keyword, $product_brand, $data_file) {
        if (empty($keyword) || empty($product_brand)) {
            return false;
        }
        
        // Only match if keyword is EXACTLY equal to product brand
        if ($keyword === $product_brand) {
            return true;
        }
        
        // Check brand aliases - exact match only
        if (isset($data_file['brand_aliases'][$keyword]) && 
            strtolower($data_file['brand_aliases'][$keyword]) === $product_brand) {
            return true;
        }
        
        // Check brand variations - exact match only
        if (!empty($data_file['brands']['cuban'])) {
            foreach ($data_file['brands']['cuban'] as $brand => $variations) {
                if (strtolower($brand) === $product_brand) {
                    foreach ($variations as $variation) {
                        if (strtolower($variation) === $keyword) {
                            return true;
                        }
                    }
                }
            }
        }
        
        if (!empty($data_file['brands']['non_cuban'])) {
            foreach ($data_file['brands']['non_cuban'] as $brand => $variations) {
                if (strtolower($brand) === $product_brand) {
                    foreach ($variations as $variation) {
                        if (strtolower($variation) === $keyword) {
                            return true;
                        }
                    }
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword contains a clear dimension pattern
     */
    private function is_clear_dimension($keyword) {
        // Handle formats like "5 1/8 x 50" with spaces and fractions
        if (preg_match('/(\d+(?:\s+\d+\/\d+)?)\s*[xX×]\s*(\d+)/', $keyword)) {
            return true;
        }
        
        // Look for bracketed dimension notation (e.g. [140×50])
        if (preg_match('/[\[【](\d+)[×xX](\d+)[\]】]/', $keyword)) {
            return true;
        }
        
        // Length and ring gauge separated by slash (e.g. 124/50)
        if (preg_match('/^(\d+)\/(\d+)$/', $keyword)) {
            return true;
        }
        
        // Handle "Ring: 50" or "Length: 124" formats
        if (preg_match('/^(ring|gauge|length)\s*:?\s*\d+$/i', $keyword)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Check if a keyword contains a clear count pattern
     */
    private function is_clear_count($keyword) {
        // Explicit count patterns
        if (preg_match('/^(\d+)-Count(?:\s+box)?$/i', $keyword) || 
            preg_match('/^Count:\s+(\d+)$/i', $keyword) ||
            preg_match('/^(\d+)支\/盒$/', $keyword) ||
            preg_match('/^(\d+)支装$/', $keyword) ||
            preg_match('/^(\d+)-Count$/', $keyword)) {
            return true;
        }
        
        // Box of X pattern
        if (preg_match('/^Box\s+of\s+(\d+)$/i', $keyword)) {
            return true;
        }
        
        // Count followed by box or ct
        if (preg_match('/^(\d+)-Count box$/', $keyword) ||
            preg_match('/^(\d+)ct$/', $keyword) ||
            preg_match('/^(\d+)-ct$/', $keyword)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Check if a keyword is a series/model for the product's brand
     */
    private function is_series_for_brand($keyword, $product_brand, $data_file) {
        if (empty($keyword) || empty($product_brand)) {
            return false;
        }
        
        // Check if the brand has series data
        if (!isset($data_file['series'][$product_brand])) {
            return false;
        }
        
        // Check against series for this brand
        foreach ($data_file['series'][$product_brand] as $series => $variations) {
            if (strtolower($series) === $keyword) {
                return true;
            }
            
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword is a vitola/size
     */
    private function is_vitola($keyword, $data_file) {
        if (empty($keyword) || empty($data_file['sizes'])) {
            return false;
        }
        
        // Check against size mappings
        foreach ($data_file['sizes'] as $vitola => $variations) {
            if (strtolower($vitola) === $keyword) {
                return true;
            }
            
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        // Check vitola mappings which are more comprehensive
        if (!empty($data_file['vitola_mappings'])) {
            foreach ($data_file['vitola_mappings'] as $vitola => $variations) {
                if (strtolower($vitola) === $keyword) {
                    return true;
                }
                
                foreach ($variations as $variation) {
                    if (strtolower($variation) === $keyword) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword is a special edition
     */
    private function is_special_edition($keyword, $data_file) {
        if (empty($keyword) || empty($data_file['special_editions'])) {
            return false;
        }
        
        // Check against special editions
        foreach ($data_file['special_editions'] as $edition => $variations) {
            if (strtolower($edition) === $keyword) {
                return true;
            }
            
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        // Check limited editions by year
        if (!empty($data_file['limited_editions_by_year'])) {
            foreach ($data_file['limited_editions_by_year'] as $year => $editions) {
                foreach ($editions as $edition) {
                    if (strtolower($edition) === $keyword || 
                        strtolower($edition . ' ' . $year) === $keyword ||
                        strtolower('edicion limitada ' . $year) === $keyword ||
                        strtolower('limited edition ' . $year) === $keyword) {
                        return true;
                    }
                }
            }
        }
        
        // Additional special edition keywords
        $special_edition_keywords = [
            'limited', 'limitada', 'edicion', 'edition', 'reserva', 'gran reserva',
            'coleccion', 'collection', 'seleccion', 'selection', 'especial', 'special',
            'anniversary', 'aniversario', 'release', 'exclusive', 'exclusivo'
        ];
        
        if (in_array($keyword, $special_edition_keywords)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Check if a keyword is a year
     */
    private function is_year1($keyword, $data_file) {
        // Check for year patterns
        if (preg_match('/^(\d{4})$/', $keyword)) {
            $year = (int)$keyword;
            if ($year >= 1900 && $year <= date('Y')) {
                return true;
            }
        }
        
        // Check for year with edition/anniversary
        if (preg_match('/^(\d{4})\s*(?:edition|anniversary|año|aniversario)$/i', $keyword) ||
            preg_match('/^(?:edition|anniversary|año|aniversario)\s*(\d{4})$/i', $keyword)) {
            return true;
        }
        
        // Check for zodiac years
        if (!empty($data_file['zodiac_years'])) {
            foreach ($data_file['zodiac_years'] as $zodiac => $variations) {
                // Check for "Year of the X" patterns
                if (strtolower('year of the ' . $zodiac) === $keyword || 
                    strtolower($zodiac . ' year') === $keyword) {
                    return true;
                }
                
                foreach ($variations as $variation) {
                    if (strtolower('year of the ' . $variation) === $keyword || 
                        strtolower($variation . ' year') === $keyword) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword might be dimension-related based on context
     */
    private function might_be_dimension($keyword, $product) {
        $keyword_lower = strtolower(trim($keyword));
        
        // Check if it's a single number that could be a ring gauge (20-70 range)
        if (is_numeric($keyword) && (int)$keyword >= 20 && (int)$keyword <= 70) {
            // Check if this matches product's actual ring gauge
            if (!empty($product['dimension_info']['ring_gauge']) && 
                (int)$keyword == (int)$product['dimension_info']['ring_gauge']) {
                return true;
            }
        }
        
        // Check if it's a single number that could be a length (typically 4-9 inches)
        if (is_numeric($keyword) && (int)$keyword >= 4 && (int)$keyword <= 9) {
            // Check if this matches product's actual length
            if (!empty($product['dimension_info']['length']) && 
                (int)$keyword == (int)$product['dimension_info']['length']) {
                return true;
            }
        }
        
        // Check for specific dimension terms
        $dimension_terms = ['ring', 'gauge', 'rg', 'length', 'mm', 'inches', 'inch', 
                          '环径', '口径', '长度', '长', 'cepo', 'calibre'];
        
        foreach ($dimension_terms as $term) {
            if (strpos($keyword_lower, $term) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword might represent a count based on context
     */
    private function might_be_count($keyword) {
        // Check for numbers in typical count ranges (1-50)
        if (is_numeric($keyword)) {
            $num = (int)$keyword;
            if ($num >= 1 && $num <= 50) {
                return true;
            }
        }
        
        // Check for specific count terms
        $count_terms = ['count', 'ct', 'box of', '支装', '数量', '数目', '包装数量'];
        
        foreach ($count_terms as $term) {
            if (strpos(strtolower($keyword), $term) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword is related to packaging
     */
    private function is_packaging($keyword, $data_file) {
        if (empty($keyword) || empty($data_file['packaging'])) {
            return false;
        }
        
        // Check against packaging types
        foreach ($data_file['packaging'] as $type => $variations) {
            if (strtolower($type) === $keyword) {
                return true;
            }
            
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        // Additional packaging keywords
        $packaging_keywords = [
            'box', 'pack', 'jar', 'tube', 'tubo', 'tubos', 'cabinet',
            'humidor', 'bundle', 'sampler', 'case', 'tin', 'container'
        ];
        
        if (in_array($keyword, $packaging_keywords)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Prioritize categories when multiple matches are found
     */
    private function prioritize_categories($categories, $keyword, $product) {
        // Define priority order (highest to lowest)
        $priority_order = [
            'brand',
            'model',
            'vitola',
            'special_edition',
            'year',
            'dimensions',
            'count',
            'packaging',
            'generic'
        ];
        
        // Sort categories by priority
        usort($categories, function($a, $b) use ($priority_order) {
            $pos_a = array_search($a, $priority_order);
            $pos_b = array_search($b, $priority_order);
            
            // If not found, assign lowest priority
            if ($pos_a === false) $pos_a = count($priority_order);
            if ($pos_b === false) $pos_b = count($priority_order);
            
            return $pos_a - $pos_b;
        });
        
        return $categories;
    }
    
    /**
     * Process a product title to extract relevant information - Enhanced version
     * 
     * @param string $title Product title
     * @param string $dimensions Dimensions string (optional)
     * @param string $description Product description (optional)
     * @return array Processed product data
     */
    public function process_product_title_enhanced($title, $dimensions = "", $description = "") {
        // Load data file
        $data_file = $this->load_data_file();
        
        // Normalize title and store original
        $original_title = trim($title);
$normalized_title = mb_strtolower(trim($title ?? ""));
        
        // Initialize result array
        $result = array(
            "title" => $original_title,
            "normalized_title" => $normalized_title,
            "brand" => null,
            "model" => null,
            "vitola" => null,
            "special_edition" => null,
            "year" => null,
            "count" => null,
            "dimension_info" => array(
                "ring_gauge" => null,
                "length" => null,
                "format" => null
            ),
            "packaging" => null,
            "keywords" => array(),
            "filtered_title" => $normalized_title
        );
        
        $this->log_debug("Enhanced processing for title: " . $original_title);
        
        // Step 1: First identify if this is a Chinese title - a key factor for processing logic
        $has_chinese_chars = !empty($title) && preg_match('/[\x{4e00}-\x{9fa5}]/u', $title);

		
        $this->log_debug("Title contains Chinese characters: " . ($has_chinese_chars ? "Yes" : "No"));
        
       // Step 2: Extract brand with more aggressive Chinese brand matching
// For Chinese products, brand is typically the first characters
if ($has_chinese_chars) {
    // Use brand mappings from the data file instead of hardcoded
    $data_file = $this->load_data_file();
    
    // Check both Cuban and non-Cuban brand sections
    foreach (['cuban', 'non_cuban'] as $section) {
        if (isset($data_file['brands'][$section])) {
            foreach ($data_file['brands'][$section] as $brand => $variations) {
                // Check each variation for Chinese characters
                foreach ($variations as $variation) {
                    if (preg_match('/[\x{4e00}-\x{9fa5}]/u', $variation) &&
                        mb_stripos($normalized_title, $variation) !== false) {
                        $result["brand"] = $brand;
                        $this->log_debug("Extracted brand from Chinese name in data file: " . $brand);
                        break 3;
                    }
                }
            }
        }
    }
}
        
        // Step 3: Extract dimensions - handle Chinese pattern "数字*数字" or bracketed formats
        if (!empty($dimensions)) {
            // Parse provided dimensions
            $dimension_parts = explode("/", $dimensions);
            if (count($dimension_parts) == 2) {
                $result["dimension_info"]["ring_gauge"] = trim($dimension_parts[0]);
                $result["dimension_info"]["length"] = trim($dimension_parts[1]);
                $result["dimension_info"]["format"] = trim($dimensions);
                $this->log_debug("Extracted dimensions from parameter: " . $dimensions);
            }
        } else {
            // Try to extract from title
            // Common patterns: 140*52, 140×52, [140×52], etc.
            if (preg_match('/(\d+)\s*[xX×*\/]\s*(\d+)/', $normalized_title, $matches)) {
                $first_num = intval($matches[1]);
                $second_num = intval($matches[2]);
                
                // Determine which is ring gauge and which is length
                if ($first_num > $second_num && $second_num >= 20 && $second_num <= 70) {
                    $result["dimension_info"]["length"] = $first_num;
                    $result["dimension_info"]["ring_gauge"] = $second_num;
                    $result["dimension_info"]["format"] = $second_num . "/" . $first_num;
                } else if ($second_num > $first_num && $first_num >= 20 && $first_num <= 70) {
                    $result["dimension_info"]["length"] = $second_num;
                    $result["dimension_info"]["ring_gauge"] = $first_num;
                    $result["dimension_info"]["format"] = $first_num . "/" . $second_num;
                } else {
                    // Default assumption (most common format: length*ring)
                    $result["dimension_info"]["length"] = $first_num;
                    $result["dimension_info"]["ring_gauge"] = $second_num;
                    $result["dimension_info"]["format"] = $second_num . "/" . $first_num;
                }
                
                $this->log_debug("Extracted dimensions from title: " . 
                                $result["dimension_info"]["ring_gauge"] . "/" . 
                                $result["dimension_info"]["length"]);
            }
        }
        
        // Step 4: Extract count (typically followed by "支" in Chinese titles)
        if (preg_match('/(\d+)\s*(?:支|pcs|个|count|ct|-count)/ui', $normalized_title, $count_matches)) {
            $result["count"] = $count_matches[1];
            $this->log_debug("Extracted count: " . $result["count"]);
        } else if (preg_match('/box\s+of\s+(\d+)/i', $normalized_title, $box_matches)) {
            $result["count"] = $box_matches[1];
            $this->log_debug("Extracted count from 'box of': " . $result["count"]);
        }
        
        // Step 5: Extract year (particularly for Chinese limited editions which often include year)
        if (preg_match('/(\d{4})(?:年|限量版?|LE|Limited Edition)?/iu', $normalized_title, $year_matches)) {
            $year = intval($year_matches[1]);
            $current_year = intval(date('Y'));
            
            // Validate year is reasonable
            if ($year >= 1950 && $year <= $current_year + 1) {  // Allow next year for pre-releases
                $result["year"] = $year_matches[1];
                $this->log_debug("Extracted year: " . $result["year"]);
            }
        }
        
        // Step 6: Extract special edition info - particularly important for Chinese titles
        // Common patterns: 限量版, 纪念版, 周年, etc.
        $special_edition_patterns = [
            '限量版', '纪念版', '周年', '特别版', '特制版', 
            'limited edition', 'edicion limitada', 'anniversary', 
            'special', 'regional', 'reserva'
        ];
        
        foreach ($special_edition_patterns as $pattern) {
            if (mb_stripos($normalized_title, $pattern) !== false) {
				// Extract the surrounding context for better special edition info
                $special_edition = '';
                
                if ($result["year"]) {
                    $special_edition = $result["year"] . " ";
                }
                
                $special_edition .= "Limited Edition";
                
                // Add regional info if found
                if (mb_stripos($normalized_title, '地区') !== false || 
                    mb_stripos($normalized_title, 'regional') !== false) {
                    $special_edition .= " Regional Edition";
                }
                
                $result["special_edition"] = $special_edition;
                $this->log_debug("Extracted special edition: " . $special_edition);
                break;
            }
        }
        
        // Step 7: Handle Chinese zodiac years which are common for limited editions
        $zodiac_patterns = [
            '鼠年' => 'Year of the Rat',
            '牛年' => 'Year of the Ox',
            '虎年' => 'Year of the Tiger',
            '兔年' => 'Year of the Rabbit',
            '龙年' => 'Year of the Dragon',
            '蛇年' => 'Year of the Snake',
            '马年' => 'Year of the Horse',
            '羊年' => 'Year of the Goat',
            '猴年' => 'Year of the Monkey',
            '鸡年' => 'Year of the Rooster',
            '狗年' => 'Year of the Dog',
            '猪年' => 'Year of the Pig'
        ];
        
        foreach ($zodiac_patterns as $chinese => $english) {
            if (mb_stripos($normalized_title, $chinese) !== false) {
                if (empty($result["special_edition"])) {
                    $result["special_edition"] = $english;
                } else {
                    $result["special_edition"] .= " - " . $english;
                }
                $this->log_debug("Extracted zodiac year: " . $english);
                break;
            }
        }
        
        // Step 8: Extract specific vitola/size (this should be enhanced for Chinese vitolas)
        $vitola_mapping = [
            // Common vitolas in Chinese and English
            '罗伯图' => 'Robusto',
            '托罗' => 'Toro',
            '公牛' => 'Toro',
            '大公牛' => 'Gran Toro',
            '鱼雷' => 'Torpedo',
            '丘吉尔' => 'Churchill',
            '长矛' => 'Lancero',
            '皇冠' => 'Corona',
            '小皇冠' => 'Petit Corona',
            '短号' => 'Short',
            '宽短号' => 'Wide Short'
        ];
        
        foreach ($vitola_mapping as $chinese => $english) {
            if (mb_stripos($normalized_title, $chinese) !== false) {
                $result["vitola"] = $english;
                $this->log_debug("Extracted vitola: " . $english);
                break;
            }
        }
        
        // If no specific vitola found, try standard data file matching
        if (empty($result["vitola"]) && isset($data_file['sizes'])) {
            foreach ($data_file['sizes'] as $vitola => $variations) {
                if (mb_stripos($normalized_title, mb_strtolower($vitola)) !== false) {
                    $result["vitola"] = $vitola;
                    $this->log_debug("Extracted vitola from data file: " . $vitola);
                    break;
                }
                
                foreach ($variations as $variation) {
                    if (mb_stripos($normalized_title, mb_strtolower($variation)) !== false) {
                        $result["vitola"] = $vitola;
                        $this->log_debug("Extracted vitola from variation: " . $vitola);
                        break 2;
                    }
                }
            }
        }
        
        // Step 9: Generate list of categorized keywords
        $keywords = [];
        
        // Add tagged keywords for extracted metadata
        if ($result["brand"]) {
            $keywords[] = "BRAND:" . $result["brand"];
        }
        
        if ($result["model"]) {
            $keywords[] = "SERIES:" . $result["model"];
        }
        
        if ($result["vitola"]) {
            $keywords[] = "VITOLA:" . $result["vitola"];
        }
        
        if ($result["special_edition"]) {
            $keywords[] = "SPECIAL:" . $result["special_edition"];
        }
        
        if ($result["year"]) {
            $keywords[] = "YEAR:" . $result["year"];
        }
        
        if ($result["count"]) {
            $keywords[] = "COUNT:" . $result["count"];
        }
        
        if (!empty($result["dimension_info"]["format"])) {
            $keywords[] = "DIM:" . $result["dimension_info"]["format"];
        } else if (!empty($result["dimension_info"]["ring_gauge"]) || !empty($result["dimension_info"]["length"])) {
            $dim_str = (!empty($result["dimension_info"]["ring_gauge"]) ? $result["dimension_info"]["ring_gauge"] : "?") . "/" .
                      (!empty($result["dimension_info"]["length"]) ? $result["dimension_info"]["length"] : "?");
            $keywords[] = "DIM:" . $dim_str;
        }
        
        // Extract and add additional keywords using intelligent tokenization
        // This is crucial for making the Chinese titles work well
        $remaining_title = $normalized_title;
        
        // Remove the already identified parts
        if ($result["brand"]) {
            $brand_lower = mb_strtolower($result["brand"]);
            $remaining_title = str_replace($brand_lower, '', $remaining_title);
            
            // Also remove brand in Chinese if applicable
            foreach ($chinese_brands as $chinese_name => $english_name) {
                if ($english_name == $result["brand"]) {
                    $remaining_title = str_replace(mb_strtolower($chinese_name), '', $remaining_title);
                    break;
                }
            }
        }
        
        // Remove dimensions from remaining title
        if (!empty($result["dimension_info"]["format"])) {
            $remaining_title = str_replace($result["dimension_info"]["format"], '', $remaining_title);
        } else if (preg_match('/(\d+)\s*[xX×*\/]\s*(\d+)/', $normalized_title, $matches)) {
            $remaining_title = str_replace($matches[0], '', $remaining_title);
        }
        
        // Clean remaining title
        $remaining_title = preg_replace('/\s+/', ' ', $remaining_title);
        $remaining_title = trim($remaining_title);
        
        // Extract Chinese word fragments (typically 2-3 character meaningful phrases)
        if ($has_chinese_chars) {
            preg_match_all('/[\x{4e00}-\x{9fa5}]{2,5}/u', $remaining_title, $chinese_words);
            foreach ($chinese_words[0] as $word) {
                if (mb_strlen($word) >= 2) {
                    $keywords[] = $word;
                }
            }
        }
        
        // Extract English word fragments
        preg_match_all('/[a-zA-Z]{3,}/u', $remaining_title, $english_words);
        foreach ($english_words[0] as $word) {
            if (mb_strlen($word) >= 3 && !in_array($word, ['the', 'and', 'for', 'with'])) {
                $keywords[] = $word;
            }
        }
        
        // Add full title as reference
        $keywords[] = "FULL:" . $normalized_title;
        
        // De-duplicate keywords
        $result["keywords"] = array_values(array_unique($keywords));
        
        $this->log_debug("Total keywords extracted: " . count($result["keywords"]));
        
        return $result;
    }
    
    /**
     * Process a supplier product to find matches
     * 
     * @param array $supplier_product Supplier product data
     * @param string $supplier_name Supplier name
     * @return array Processing result
     */
    private function process_supplier_product($supplier_product, $supplier_name) {
        
		
		
		// Extract product info with better error handling
$product_id = isset($supplier_product["id"]) ? $supplier_product["id"] : 
             (isset($supplier_product["ID"]) ? $supplier_product["ID"] : "unknown-".rand(1000,9999));
$product_title = isset($supplier_product["title"]) ? $supplier_product["title"] : 
                (isset($supplier_product["Title"]) ? $supplier_product["Title"] : "Untitled Product");

$this->log_debug("Processing product: $product_id - $product_title");
      
		
		
        $this->log_debug("Processing supplier product: $product_id - $product_title");
        
        // Initialize result
        $result = array(
            "product_id" => $product_id,
            "product_title" => $product_title,
            "match_status" => "no_match",
            "best_match" => null,
            "matched_terms" => array()
        );
        
        // Check if product is already mapped
        global $wpdb;
        $mapping_table = $wpdb->prefix . $this->mapping_table;
        
        $existing_mapping = $wpdb->get_row($wpdb->prepare(
            "SELECT kt_sku, match_confidence FROM $mapping_table 
            WHERE supplier_name = %s AND supplier_id = %s",
            $supplier_name, $product_id
        ));
        
        if ($existing_mapping) {
            // Get product details for existing mapping
            $master_table = $wpdb->prefix . $this->master_table;
            
            $mapped_product = $wpdb->get_row($wpdb->prepare(
                "SELECT sku, product_title FROM $master_table WHERE sku = %s",
                $existing_mapping->kt_sku
            ));
            
            if ($mapped_product) {
                $result["match_status"] = $existing_mapping->match_confidence . "_match";
                $result["best_match"] = array(
                    "sku" => $mapped_product->sku,
                    "title" => $mapped_product->product_title,
                    "score" => ($existing_mapping->match_confidence === "exact" ? 100 : 
                               ($existing_mapping->match_confidence === "close" ? 85 : 
                               ($existing_mapping->match_confidence === "possible" ? 65 : 50)))
                );
                
                // Get existing matched terms if available
                $matched_terms_raw = $wpdb->get_var($wpdb->prepare(
                    "SELECT matched_terms FROM $mapping_table WHERE supplier_name = %s AND supplier_id = %s",
                    $supplier_name, $product_id
                ));
                
                if (!empty($matched_terms_raw)) {
                    $result["matched_terms"] = explode(',', $matched_terms_raw);
                }
                
                return $result;
            }
        }
        
        // Process product title using KT_Cigar_Mappings - leverage the existing class
        if (class_exists('KT_Cigar_Mappings')) {
            $processed_product = KT_Cigar_Mappings::process_supplier_product($product_title);
        } else {
            // Fallback to our own processor if the class isn't available
            $processed_product = $this->process_product_title_enhanced($product_title);
        }
        
        // Important: Save the extracted keywords to the result
        if (!empty($processed_product["keywords"])) {
            $result["matched_terms"] = $processed_product["keywords"];
            $this->log_debug("Extracted " . count($processed_product["keywords"]) . " keywords");
        }
        
        // Get potential database matches with more flexible criteria
        $db_products = $this->get_potential_database_matches($processed_product);
        
        if (empty($db_products)) {
            $this->log_debug("No potential matches found");
            return $result;
        }
        
        // Process each database product with KT_Cigar_Mappings
        $db_processed_products = array();
        foreach ($db_products as $db_product) {
            $dimensions = "";
            if (!empty($db_product->seat_row) || !empty($db_product->seat_number)) {
                $dimensions = (!empty($db_product->seat_row) ? $db_product->seat_row : "") . "/" . 
                              (!empty($db_product->seat_number) ? $db_product->seat_number : "");
            }
            
            // Use KT_Cigar_Mappings for processing if available
            if (class_exists('KT_Cigar_Mappings')) {
                $db_processed = KT_Cigar_Mappings::process_internal_product(
                    $db_product->sku,
                    $db_product->product_title,
                    $dimensions
                );
            } else {
                // Fallback to our own processing
                $db_processed = $this->process_product_title_enhanced($db_product->product_title, $dimensions);
            }
            
            $db_processed["sku"] = $db_product->sku;
            $db_processed["id"] = $db_product->id;
            $db_processed["title"] = $db_product->product_title;
            
            $db_processed_products[] = $db_processed;
    
		}
      
		$this->log_debug("DB Product keywords: " . json_encode($db_processed["keywords"] ?? []));
		
		
        // Find best matches using our enhanced comparison
        $matches = $this->find_best_matches($processed_product, $db_processed_products, 3, true);
        
        if (empty($matches)) {
            $this->log_debug("No matches found after comparison");
            return $result;
        }
        
        // Get best match
        $best_match = $matches[0];
        
        // Extract matched terms if available
        $matched_terms = array();
        if (isset($best_match["matched_terms"]) && is_array($best_match["matched_terms"])) {
            $matched_terms = $best_match["matched_terms"];
        }
        
        // Get keywords from processed product if no match terms found
        if (empty($matched_terms) && !empty($processed_product["keywords"])) {
            $matched_terms = $processed_product["keywords"];
        }
        
        // Determine match status based on score
        $match_status = "no_match";
        $match_confidence = "none";
        
        if ($best_match["match_type"] === "Exact Match") {
            $match_status = "exact_match";
            $match_confidence = "exact";
        } else if ($best_match["match_type"] === "Close Match") {
            $match_status = "close_match";
            $match_confidence = "close";
        } else if ($best_match["match_type"] === "Possible Match") {
            $match_status = "possible_match";
            $match_confidence = "possible";
        }
        
        $result["match_status"] = $match_status;
        $result["best_match"] = array(
            "sku" => $best_match["product"]["sku"],
            "title" => $best_match["product"]["title"],
            "score" => round($best_match["score"])
        );
       // Add database keywords to the result if available
if (isset($best_match["product"]) && isset($best_match["product"]["keywords"])) {
    $result["best_match"]["db_keywords"] = $best_match["product"]["keywords"];
    $this->log_debug("DB keywords from product: " . count($best_match["product"]["keywords"]) . " keywords");
} else if (isset($best_match["keywords"])) {
    // Alternative location for keywords
    $result["best_match"]["db_keywords"] = $best_match["keywords"];
    $this->log_debug("DB keywords from best_match: " . count($best_match["keywords"]) . " keywords");
} else {
    // Default to empty array if no keywords found
    $result["best_match"]["db_keywords"] = array();
    $this->log_debug("No DB keywords found in match");
}

// Log the final result structure
$this->log_debug("Final match result for product " . $product_id . ": " . 
                json_encode(array(
                    'match_status' => $result["match_status"],
                    'has_db_keywords' => isset($result["best_match"]["db_keywords"]),
                    'db_keywords_count' => count($result["best_match"]["db_keywords"] ?? [])
                )));
        
        $result["matched_terms"] = $matched_terms;
        
        return $result;
    }
    
    /**
     * Find best matches between a supplier product and database products
     * 
     * @param array $supplier_product Processed supplier product data
     * @param array $db_products Array of processed database products
     * @param int $limit Maximum number of matches to return
     * @param bool $include_debug Whether to include debug information in results
     * @return array Best matches with their scores
     */
    private function find_best_matches($supplier_product, $db_products, $limit = 3, $include_debug = false) {
        if (empty($supplier_product) || empty($db_products)) {
            return array();
        }
        
        $matches = array();
        
        // Get the basic info from the supplier product
        $supplier_brand = strtolower(trim($supplier_product["brand"] ?? ""));
        $supplier_model = strtolower(trim($supplier_product["model"] ?? ""));
        $supplier_vitola = strtolower(trim($supplier_product["vitola"] ?? ""));
        $supplier_special = strtolower(trim($supplier_product["special_edition"] ?? ""));
        $supplier_year = $supplier_product["year"] ?? "";
        $supplier_ring = $supplier_product["dimension_info"]["ring_gauge"] ?? "";
        $supplier_length = $supplier_product["dimension_info"]["length"] ?? "";
        $supplier_keywords = is_array($supplier_product["keywords"]) ? $supplier_product["keywords"] : array();
        
        // Calculate scores for each database product
        foreach ($db_products as $db_product) {
            // Skip products with different product types if specified
            if (isset($db_product["product_type"]) && 
                isset($supplier_product["product_type"]) && 
                $db_product["product_type"] !== $supplier_product["product_type"] &&
                !empty($supplier_product["product_type"])) {
                continue;
            }
            
            // Get the basic info from the database product
            $db_brand = strtolower(trim($db_product["brand"] ?? ""));
            $db_model = strtolower(trim($db_product["model"] ?? ""));
            $db_vitola = strtolower(trim($db_product["vitola"] ?? ""));
            $db_special = strtolower(trim($db_product["special_edition"] ?? ""));
            $db_year = $db_product["year"] ?? "";
            $db_ring = $db_product["dimension_info"]["ring_gauge"] ?? "";
            $db_length = $db_product["dimension_info"]["length"] ?? "";
            $db_keywords = is_array($db_product["keywords"]) ? $db_product["keywords"] : array();
            
            // Calculate score components
            $brand_score = 0;
            $model_score = 0;
            $vitola_score = 0;
            $special_score = 0;
            $year_score = 0;
            $dimension_score = 0;
            $keyword_score = 0;
            
            // Calculate brand score (highest weight)
            // Brand is a HARD requirement for a valid match
            if (!empty($supplier_brand) && !empty($db_brand)) {
                if ($supplier_brand === $db_brand) {
                    $brand_score = 5.0; // Perfect brand match
                } else {
                    // Check for brand aliases in data file
                    $data_file = $this->load_data_file();
                    $is_alias_match = false;
                    
                    if (!empty($data_file["brand_aliases"])) {
                        foreach ($data_file["brand_aliases"] as $alias => $brand_name) {
                            if ((strtolower($alias) === $supplier_brand && strtolower($brand_name) === $db_brand) ||
                                (strtolower($alias) === $db_brand && strtolower($brand_name) === $supplier_brand)) {
                                $is_alias_match = true;
                                break;
                            }
                        }
                    }
                    
                    if ($is_alias_match) {
                        $brand_score = 4.0; // Brand alias match
                    } else if (strpos($db_brand, $supplier_brand) !== false || 
                              strpos($supplier_brand, $db_brand) !== false) {
                        $brand_score = 3.0; // Partial brand match
                    } else {
                        $brand_score = 0.0; // Different brands - zero score - brand mismatch is critical
                    }
                }
            } else {
                // If supplier doesn't have a brand, we need to be more permissive
                if (empty($supplier_brand) && !empty($db_brand)) {
                    // Check if database brand appears in supplier title
                    if (strpos($supplier_product["normalized_title"], $db_brand) !== false) {
                        $brand_score = 3.0; // Brand appears in title
                    } else {
                        $brand_score = 0.5; // Title doesn't contain brand
                    }
                } else if (!empty($supplier_brand) && empty($db_brand)) {
                    // Check if supplier brand appears in database title
                    if (strpos($db_product["normalized_title"], $supplier_brand) !== false) {
                        $brand_score = 3.0; // Brand appears in title
                    } else {
                        $brand_score = 0.5; // Title doesn't contain brand
                    }
                } else {
                    $brand_score = 0.5; // Both missing brand
                }
            }
            
            // If brands don't match at all, skip this product completely
            if ($brand_score <= 0.0) {
                continue;
            }
            
            // Calculate model/series score
            if (!empty($supplier_model) && !empty($db_model)) {
                if ($supplier_model === $db_model) {
                    $model_score = 4.0; // Perfect model match
                } else if (strpos($db_model, $supplier_model) !== false || 
                          strpos($supplier_model, $db_model) !== false) {
                    $model_score = 2.5; // Partial model match
                } else {
                    $model_score = 0.5; // Different models
                }
            } else {
                // If one is missing model, check if the other appears in the title
                if (empty($supplier_model) && !empty($db_model)) {
                    if (strpos($supplier_product["normalized_title"], $db_model) !== false) {
                        $model_score = 2.0; // Model appears in title
                    } else {
                        $model_score = 0.0; // No match
                    }
                } else if (!empty($supplier_model) && empty($db_model)) {
                    if (strpos($db_product["normalized_title"], $supplier_model) !== false) {
                        $model_score = 2.0; // Model appears in title
                    } else {
                        $model_score = 0.0; // No match
                    }
                } else {
                    $model_score = 0.0; // Both missing model
                }
            }
            
            // Calculate vitola score
            if (!empty($supplier_vitola) && !empty($db_vitola)) {
                if ($supplier_vitola === $db_vitola) {
                    $vitola_score = 3.0; // Perfect vitola match
                } else if (strpos($db_vitola, $supplier_vitola) !== false || 
                          strpos($supplier_vitola, $db_vitola) !== false) {
                    $vitola_score = 2.0; // Partial vitola match
                } else {
                    // Check if vitolas are related using data file
                    $data_file = $this->load_data_file();
                    $vitola_match = false;
                    
                    if (!empty($data_file["vitola_mappings"])) {
                        foreach ($data_file["vitola_mappings"] as $vitola => $variations) {
                            if ((strtolower($vitola) === $supplier_vitola || in_array($supplier_vitola, array_map('strtolower', $variations))) &&
                                (strtolower($vitola) === $db_vitola || in_array($db_vitola, array_map('strtolower', $variations)))) {
                                $vitola_match = true;
                                break;
                            }
                        }
                    }
                    
                    if ($vitola_match) {
                        $vitola_score = 2.5; // Related vitolas
                    } else {
                        $vitola_score = 0.5; // Different vitolas
                    }
                }
            } else {
                // If one is missing vitola, check dimensions instead
                if (empty($supplier_vitola) || empty($db_vitola)) {
                    $vitola_score = 0.0; // Handle in dimension score
                }
            }
            
            // Calculate special edition score
            if (!empty($supplier_special) && !empty($db_special)) {
                if ($supplier_special === $db_special) {
                    $special_score = 3.0; // Perfect special edition match
                } else if (strpos($db_special, $supplier_special) !== false || 
                          strpos($supplier_special, $db_special) !== false) {
                    $special_score = 2.0; // Partial special edition match
                } else if ((strpos($supplier_special, 'limited') !== false && 
                           strpos($db_special, 'limited') !== false) ||
                          (strpos($supplier_special, 'regional') !== false && 
                           strpos($db_special, 'regional') !== false)) {
                    $special_score = 1.5; // Both have limited or regional edition
                } else {
                    $special_score = 0.5; // Different special editions
                }
            } else {
                // If one is missing special edition, it's neutral
                $special_score = 0.0;
            }
            
            // Calculate year score
            if (!empty($supplier_year) && !empty($db_year)) {
                if ($supplier_year === $db_year) {
                    $year_score = 3.0; // Perfect year match
                } else {
                    // Check how close the years are
                    $year_diff = abs((int)$supplier_year - (int)$db_year);
                    if ($year_diff <= 1) {
                        $year_score = 2.0; // Off by 1 year
                    } else if ($year_diff <= 3) {
                        $year_score = 1.0; // Off by 2-3 years
                    } else {
                        $year_score = 0.0; // Significant year difference
                    }
                }
            } else {
                // If one is missing year, it's neutral
                $year_score = 0.0;
            }
            
            // Calculate dimension score
            if ((!empty($supplier_ring) || !empty($supplier_length)) && 
                (!empty($db_ring) || !empty($db_length))) {
                
                $ring_match = false;
                $length_match = false;
                
                // Check ring gauge match
                if (!empty($supplier_ring) && !empty($db_ring)) {
                    $ring_diff = abs((float)$supplier_ring - (float)$db_ring);
                    $max_diff = max(1, (float)$supplier_ring * 0.05); // 5% tolerance or 1 unit
                    
                    if ($ring_diff <= $max_diff) {
                        $ring_match = true;
                    }
                }
                
                // Check length match
                if (!empty($supplier_length) && !empty($db_length)) {
                    $length_diff = abs((float)$supplier_length - (float)$db_length);
                    $max_diff = max(5, (float)$supplier_length * 0.05); // 5% tolerance or 5 units
                    
                    if ($length_diff <= $max_diff) {
                        $length_match = true;
                    }
                }
                
                // Score based on matches
                if ($ring_match && $length_match) {
                    $dimension_score = 3.0; // Both dimensions match
                } else if ($ring_match || $length_match) {
                    $dimension_score = 1.5; // One dimension matches
                } else {
                    // Calculate how close the dimensions are
                    $dimension_score = 0.0;
                    
                    if (!empty($supplier_ring) && !empty($db_ring)) {
                        $ring_diff = abs((float)$supplier_ring - (float)$db_ring);
                        $ring_pct = min(1.0, max(0.0, 1.0 - ($ring_diff / (float)$supplier_ring)));
                        $dimension_score += $ring_pct * 1.5;
                    }
                    
                    if (!empty($supplier_length) && !empty($db_length)) {
                        $length_diff = abs((float)$supplier_length - (float)$db_length);
                        $length_pct = min(1.0, max(0.0, 1.0 - ($length_diff / (float)$supplier_length)));
                        $dimension_score += $length_pct * 1.5;
                    }
                }
            } else {
                // If dimensions are missing, it's neutral
                $dimension_score = 0.0;
            }
            
            // Calculate keyword score
            $matched_keywords = array();
            $category_matches = array(
                'brand' => 0,
                'model' => 0,
                'vitola' => 0,
                'special_edition' => 0,
                'year' => 0,
                'dimensions' => 0,
                'count' => 0,
                'packaging' => 0,
                'generic' => 0
            );
            
            foreach ($supplier_keywords as $supplier_keyword) {
                // Skip the FULL: keyword which is just for reference
                if (strpos($supplier_keyword, 'FULL:') === 0) {
                    continue;
                }
                
                foreach ($db_keywords as $db_keyword) {
                    // Skip the FULL: keyword which is just for reference
                    if (strpos($db_keyword, 'FULL:') === 0) {
                        continue;
                    }
                    
                    // Extract tag and value if present
                    $supplier_tag = '';
                    $supplier_value = '';
                    if (preg_match('/^([A-Z_]+):(.+)$/i', $supplier_keyword, $s_matches)) {
                        $supplier_tag = strtoupper($s_matches[1]);
                        $supplier_value = strtolower(trim($s_matches[2]));
                    } else {
                        $supplier_value = strtolower(trim($supplier_keyword));
                    }
                    
                    $db_tag = '';
                    $db_value = '';
                    if (preg_match('/^([A-Z_]+):(.+)$/i', $db_keyword, $d_matches)) {
                        $db_tag = strtoupper($d_matches[1]);
                        $db_value = strtolower(trim($d_matches[2]));
                    } else {
                        $db_value = strtolower(trim($db_keyword));
                    }
                    
                    // Check for matches
                    if (!empty($supplier_tag) && !empty($db_tag) && $supplier_tag === $db_tag) {
                        // Tags match, check values
                        if ($supplier_value === $db_value) {
                            $keyword_score += 1.5;
                            $matched_keywords[] = $supplier_tag . ":" . $supplier_value;
                            
                            // Track category match
                            switch ($supplier_tag) {
                                case 'BRAND': $category_matches['brand']++; break;
                                case 'SERIES': $category_matches['model']++; break;
                                case 'VITOLA': $category_matches['vitola']++; break;
                                case 'SPECIAL': $category_matches['special_edition']++; break;
                               case 'YEAR': $category_matches['year']++; break;
                                case 'COUNT': $category_matches['count']++; break;
                                case 'DIM': $category_matches['dimensions']++; break;
                                case 'PACK': $category_matches['packaging']++; break;
                                default: $category_matches['generic']++; break;
                            }
                        } else if (strpos($db_value, $supplier_value) !== false || 
                                  strpos($supplier_value, $db_value) !== false) {
                            $keyword_score += 0.75;
                            $matched_keywords[] = $supplier_tag . ":" . $supplier_value;
                            
                            // Track category match (partial)
                            switch ($supplier_tag) {
                                case 'BRAND': $category_matches['brand'] += 0.5; break;
                                case 'SERIES': $category_matches['model'] += 0.5; break;
                                case 'VITOLA': $category_matches['vitola'] += 0.5; break;
                                case 'SPECIAL': $category_matches['special_edition'] += 0.5; break;
                                case 'YEAR': $category_matches['year'] += 0.5; break;
                                case 'COUNT': $category_matches['count'] += 0.5; break;
                                case 'DIM': $category_matches['dimensions'] += 0.5; break;
                                case 'PACK': $category_matches['packaging'] += 0.5; break;
                                default: $category_matches['generic'] += 0.5; break;
                            }
                        }
                    } else if (empty($supplier_tag) && empty($db_tag)) {
                        // Both untagged
                        if ($supplier_value === $db_value) {
                            $keyword_score += 0.5;
                            $matched_keywords[] = $supplier_value;
                            $category_matches['generic']++;
                        } else if (strlen($supplier_value) > 3 && strlen($db_value) > 3 &&
                                  (strpos($db_value, $supplier_value) !== false || 
                                   strpos($supplier_value, $db_value) !== false)) {
                            $keyword_score += 0.25;
                            $matched_keywords[] = $supplier_value;
                            $category_matches['generic'] += 0.5;
                        }
                    } else if (!empty($supplier_value) && !empty($db_value)) {
                        // One tagged, one untagged - compare values only
                        if ($supplier_value === $db_value) {
                            $keyword_score += 0.5;
                            $matched_keywords[] = $supplier_value;
                            $category_matches['generic']++;
                        } else if (strlen($supplier_value) > 3 && strlen($db_value) > 3 &&
                                  (strpos($db_value, $supplier_value) !== false || 
                                   strpos($supplier_value, $db_value) !== false)) {
                            $keyword_score += 0.25;
                            $matched_keywords[] = $supplier_value;
                            $category_matches['generic'] += 0.5;
                        }
                    }
                }
            }
            
            // Chinese-specific keyword boost for CJK characters
            $has_chinese_chars = false;
            foreach ($supplier_keywords as $keyword) {
                if (preg_match('/[\x{4e00}-\x{9fa5}]/u', $keyword)) {
                    $has_chinese_chars = true;
                    break;
                }
            }
            
            if ($has_chinese_chars) {
                // For Chinese products, give extra weight to chinese character matches
                foreach ($supplier_keywords as $supplier_keyword) {
                    if (preg_match('/[\x{4e00}-\x{9fa5}]{2,}/u', $supplier_keyword)) {
                        foreach ($db_keywords as $db_keyword) {
                            if (strpos($db_keyword, $supplier_keyword) !== false || 
                                strpos($supplier_keyword, $db_keyword) !== false) {
                                $keyword_score += 0.3;
                                $matched_keywords[] = $supplier_keyword;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Calculate final score with appropriate weights
            $score = ($brand_score * 6.0) + // Brand is even more important
                    ($model_score * 4.0) + 
                    ($vitola_score * 3.5) + 
                    ($special_score * 3.0) + 
                    ($year_score * 2.5) + 
                    ($dimension_score * 3.0) + 
                    ($keyword_score * 2.0);
            
            // Boost for category matches (reinforces the categorization)
            if ($category_matches['brand'] > 0) $score += (2.0 * $category_matches['brand']);
            if ($category_matches['model'] > 0) $score += (1.5 * $category_matches['model']);
            if ($category_matches['vitola'] > 0) $score += (1.5 * $category_matches['vitola']);
            if ($category_matches['special_edition'] > 0) $score += (1.0 * $category_matches['special_edition']);
            if ($category_matches['year'] > 0) $score += (1.0 * $category_matches['year']);
            if ($category_matches['dimensions'] > 0) $score += (1.0 * $category_matches['dimensions']);
            if ($category_matches['count'] > 0) $score += (0.5 * $category_matches['count']);
            if ($category_matches['packaging'] > 0) $score += (0.5 * $category_matches['packaging']);
            
            // Normalize score to a 0-100 scale
            $max_possible_score = (6.0 * 5.0) + (4.0 * 4.0) + (3.5 * 3.5) + (3.0 * 3.0) + 
                                 (2.5 * 3.0) + (3.0 * 3.0) + (2.0 * 15.0) + 
                                 (2.0 * 3) + (1.5 * 3) + (1.5 * 3) + (1.0 * 3) + (1.0 * 3) + 
                                 (1.0 * 3) + (0.5 * 3) + (0.5 * 3);
            
            $normalized_score = min(100, round(($score / $max_possible_score) * 100, 1));
            
            // Determine match type based on score and brand matching
            $match_type = "No Match";
            
            // Brand is a HARD requirement - if brands don't match, it's automatically no match
            if ($brand_score < 3.0) {
                $match_type = "No Match";
            } else if ($normalized_score >= 85) {
                // Must have matching brand and at least one other major attribute for exact match
                if ($brand_score >= 4.5 && ($model_score >= 3.0 || $vitola_score >= 2.5 || $dimension_score >= 2.5)) {
                    $match_type = "Exact Match";
                } else {
                    $match_type = "Close Match";
                }
            } else if ($normalized_score >= 70) {
                $match_type = "Close Match";
            } else if ($normalized_score >= 50) {
                $match_type = "Possible Match";
            } else {
                $match_type = "No Match";
            }
     // Add to matches array
$match_data = array(
    "product" => $db_product,
    "score" => $normalized_score,
    "match_type" => $match_type
);

// Make sure keywords are included in the match data
if (isset($db_product["keywords"])) {
    // Ensure keywords are explicitly accessible 
    $match_data["keywords"] = $db_product["keywords"];
    $this->log_debug("Added " . count($db_product["keywords"]) . " keywords to match data");
}
            
            // If debug is enabled, add detailed score breakdown
            if ($include_debug) {
                $match_data["scores"] = array(
                    "brand" => round($brand_score * 6.0, 1),
                    "model" => round($model_score * 4.0, 1),
                    "vitola" => round($vitola_score * 3.5, 1),
                    "special" => round($special_score * 3.0, 1),
                    "year" => round($year_score * 2.5, 1),
                    "dimension" => round($dimension_score * 3.0, 1),
                    "keyword" => round($keyword_score * 2.0, 1),
                    "category_boosts" => array_map(function($value) { return round($value, 1); }, $category_matches),
                    "total" => round($score, 1),
                    "normalized" => $normalized_score
                );
                $match_data["matched_terms"] = array_unique($matched_keywords);
            }
            
            $matches[] = $match_data;
        }
        
        // Sort matches by score (descending)
        usort($matches, function($a, $b) {
            return $b["score"] <=> $a["score"];
        });
        
        // Return top matches
        return array_slice($matches, 0, $limit);
    }
    
    /**
     * Get potential database matches based on product info
     * 
     * @param array $processed_product Processed product data
     * @return array Array of potential database matches
     */
    private function get_potential_database_matches($processed_product) {
        global $wpdb;
        $master_table = $wpdb->prefix . $this->master_table;
      // Starting with an empty query and parameters
$where_clauses = ["(product_type = 'cigar' OR product_type = '')"];
$params = [];

// Get brand for filtering - key part for better matching
if (!empty($processed_product["brand"])) {
    // Use the original brand for precise matching
    $brand = $processed_product["brand"];
    
    // Create a brand condition group with OR logic
    $brand_conditions = [];
    $brand_conditions[] = "brand = %s";
    $brand_conditions[] = "brand LIKE %s";
    $brand_conditions[] = "product_title LIKE %s";
    $params[] = $brand;
    $params[] = "%" . $wpdb->esc_like($brand) . "%";
    $params[] = "%" . $wpdb->esc_like($brand) . "%";
    
    // Add brand variations from data file
    $data_file = $this->load_data_file();
    
    // Check for variations in both Cuban and non-Cuban brands
    $checked_sections = ['cuban', 'non_cuban'];
    foreach ($checked_sections as $section) {
        if (isset($data_file['brands'][$section])) {
            // Look for this brand in the section
            foreach ($data_file['brands'][$section] as $master_brand => $variations) {
                if (strtolower($master_brand) === strtolower($brand)) {
                    // We found the brand, now add all its variations to the search
                    foreach ($variations as $variation) {
                        $brand_conditions[] = "brand LIKE %s";
                        $brand_conditions[] = "product_title LIKE %s";
                        $params[] = "%" . $wpdb->esc_like($variation) . "%";
                        $params[] = "%" . $wpdb->esc_like($variation) . "%";
                    }
                    break;
                }
                
                // Also check if the brand is one of the variations
                foreach ($variations as $variation) {
                    if (strtolower($variation) === strtolower($brand)) {
                        // We found the brand as a variation, add the master brand and other variations
                        $brand_conditions[] = "brand LIKE %s";
                        $brand_conditions[] = "product_title LIKE %s";
                        $params[] = "%" . $wpdb->esc_like($master_brand) . "%";
                        $params[] = "%" . $wpdb->esc_like($master_brand) . "%";
                        
                        foreach ($variations as $other_variation) {
                            if ($other_variation !== $variation) {
                                $brand_conditions[] = "brand LIKE %s";
                                $brand_conditions[] = "product_title LIKE %s";
                                $params[] = "%" . $wpdb->esc_like($other_variation) . "%";
                                $params[] = "%" . $wpdb->esc_like($other_variation) . "%";
                            }
                        }
                        break 2;
                    }
                }
            }
        }
    }
    
    // Also check brand aliases
    if (isset($data_file['brand_aliases'])) {
        foreach ($data_file['brand_aliases'] as $alias => $original) {
            if (strtolower($alias) === strtolower($brand) || strtolower($original) === strtolower($brand)) {
                // Add this alias/original to the search
                $search_term = (strtolower($alias) === strtolower($brand)) ? $original : $alias;
                $brand_conditions[] = "brand LIKE %s";
                $brand_conditions[] = "product_title LIKE %s";
                $params[] = "%" . $wpdb->esc_like($search_term) . "%";
                $params[] = "%" . $wpdb->esc_like($search_term) . "%";
            }
        }
    }
    
    // Add the brand conditions as a group
    if (!empty($brand_conditions)) {
        $where_clauses[] = "AND (" . implode(" OR ", $brand_conditions) . ")";
    }
}

// Add additional filters as their own condition groups
$additional_filters = [];

// Add vitola filter with flexible matching
if (!empty($processed_product["vitola"])) {
    $vitola = $processed_product["vitola"];
    $additional_filters[] = "product_title LIKE %s";
    $params[] = "%" . $wpdb->esc_like($vitola) . "%";
}

// Add dimension filter if available
if (!empty($processed_product["dimension_info"]["ring_gauge"]) && 
    !empty($processed_product["dimension_info"]["length"])) {
    
    $ring = $processed_product["dimension_info"]["ring_gauge"];
    $length = $processed_product["dimension_info"]["length"];
    
    // Allow for some variance in dimensions
    $ring_min = $ring - 2;
    $ring_max = $ring + 2;
    $length_min = $length - 10;
    $length_max = $length + 10;
    
    $additional_filters[] = "((seat_row BETWEEN %d AND %d) OR (seat_number BETWEEN %d AND %d))";
    $params[] = $ring_min;
    $params[] = $ring_max;
    $params[] = $length_min;
    $params[] = $length_max;
}

// Special handling for Chinese titles with year
if (!empty($processed_product["year"])) {
    $additional_filters[] = "product_title LIKE %s";
    $params[] = "%" . $wpdb->esc_like($processed_product["year"]) . "%";
}

// Add additional filters if any exist
if (!empty($additional_filters)) {
    // Use AND between the additional filters to ensure all conditions are met
    $where_clauses[] = "AND (" . implode(" AND ", $additional_filters) . ")";
}
        
        // Build the full WHERE clause
        $where_clause = implode(" ", $where_clauses);
        
        // Build query
        $query = "SELECT id, sku, product_title, brand, seat_row, seat_number 
                 FROM $master_table 
                 WHERE $where_clause
                 ORDER BY brand ASC, sku ASC
                 LIMIT 150";
        
        // Prepare query if we have parameters
        if (!empty($params)) {
            $query = $wpdb->prepare($query, $params);
        }
        
        $this->log_debug("Enhanced database query: " . $query);
        
        return $wpdb->get_results($query);
    }
    
    /**
     * Get database products for display or processing
     * 
     * @param int $page Page number
     * @param int $per_page Items per page
     * @param string $brand_filter Optional brand filter
     * @param string $sku_filter Optional SKU filter
     * @param string $title_filter Optional title filter
     * @return array Array of product objects
     */
    public function get_database_products($page = 1, $per_page = 50, $brand_filter = "", $sku_filter = "", $title_filter = "") {
        global $wpdb;
        
        $offset = ($page - 1) * $per_page;
        
        // Build where clause
        $where = array("1=1");
        $params = array();
        
        if (!empty($brand_filter)) {
            $where[] = "brand = %s";
            $params[] = $brand_filter;
        }
        
        if (!empty($sku_filter)) {
            $where[] = "sku LIKE %s";
            $params[] = '%' . $wpdb->esc_like($sku_filter) . '%';
        }
        
        if (!empty($title_filter)) {
            $where[] = "product_title LIKE %s";
            $params[] = '%' . $wpdb->esc_like($title_filter) . '%';
        }
        
        // Add product type filter
        $where[] = "(product_type = 'cigar' OR product_type = '')";
        
        // Build query
        $query = "SELECT id, sku, product_title, brand, seat_row, seat_number 
                 FROM {$wpdb->prefix}{$this->master_table} 
                 WHERE " . implode(" AND ", $where) . " 
                 ORDER BY brand ASC, sku ASC 
                 LIMIT %d OFFSET %d";
        
        // Add pagination parameters
        $params[] = $per_page;
        $params[] = $offset;
        
        // Prepare and execute query
        $query = $wpdb->prepare($query, $params);
        
        return $wpdb->get_results($query);
    }
    
    /**
     * Count database products
     * 
     * @param string $brand_filter Optional brand filter
     * @param string $sku_filter Optional SKU filter
     * @param string $title_filter Optional title filter
     * @return int Total count
     */
    public function count_database_products($brand_filter = "", $sku_filter = "", $title_filter = "") {
        global $wpdb;
        
        // Build where clause
        $where = array("1=1");
        $params = array();
        
        if (!empty($brand_filter)) {
            $where[] = "brand = %s";
            $params[] = $brand_filter;
        }
        
        if (!empty($sku_filter)) {
            $where[] = "sku LIKE %s";
            $params[] = '%' . $wpdb->esc_like($sku_filter) . '%';
        }
        
        if (!empty($title_filter)) {
            $where[] = "product_title LIKE %s";
            $params[] = '%' . $wpdb->esc_like($title_filter) . '%';
        }
        
        // Add product type filter
        $where[] = "(product_type = 'cigar' OR product_type = '')";
        
        // Build query
        $query = "SELECT COUNT(*) 
                 FROM {$wpdb->prefix}{$this->master_table} 
                 WHERE " . implode(" AND ", $where);
        
        // Prepare and execute query
        if (!empty($params)) {
            $query = $wpdb->prepare($query, $params);
        }
        
        return (int)$wpdb->get_var($query);
    }
    
    /**
     * Get unique brands from database
     * 
     * @return array Array of brand names
     */
    public function get_unique_brands() {
        global $wpdb;
        
        $query = "SELECT DISTINCT brand 
                 FROM {$wpdb->prefix}{$this->master_table} 
                 WHERE brand != '' AND (product_type = 'cigar' OR product_type = '') 
                 ORDER BY brand ASC";
        
        return $wpdb->get_col($query);
    }
    
    /**
     * Get mappings for display
     * 
     * @param int $page Page number
     * @param int $per_page Items per page
     * @param string $supplier_filter Optional supplier filter
     * @param string $confidence_filter Optional confidence filter
     * @param string $search_filter Optional search filter
     * @return array Array of mapping objects
     */
    public function get_mappings($current_page = 1, $per_page = 30, $supplier_filter = "", $confidence_filter = "", $search_filter = "") {
        global $wpdb;
        
        $offset = ($current_page - 1) * $per_page;
        
        // Build where clause
        $where = array("1=1");
        $params = array();
        
        if (!empty($supplier_filter)) {
            $where[] = "supplier_name = %s";
            $params[] = $supplier_filter;
        }
        
        if (!empty($confidence_filter)) {
            $where[] = "match_confidence = %s";
            $params[] = $confidence_filter;
        }
        
        if (!empty($search_filter)) {
            $where[] = "(supplier_title LIKE %s OR kt_sku LIKE %s OR matched_terms LIKE %s)";
            $search_like = '%' . $wpdb->esc_like($search_filter) . '%';
            $params[] = $search_like;
            $params[] = $search_like;
            $params[] = $search_like;
        }
        
        // Build query
        $query = "SELECT * 
                 FROM {$wpdb->prefix}{$this->mapping_table} 
                 WHERE " . implode(" AND ", $where) . " 
                 ORDER BY supplier_name ASC, kt_sku ASC 
                 LIMIT %d OFFSET %d";
        
        // Add pagination parameters
        $params[] = $per_page;
        $params[] = $offset;
        
        // Prepare and execute query
        $query = $wpdb->prepare($query, $params);
        
        return $wpdb->get_results($query);
    }
    
    /**
     * Count mappings
     * 
     * @param string $supplier_filter Optional supplier filter
     * @param string $confidence_filter Optional confidence filter
     * @param string $search_filter Optional search filter
     * @return int Total count
     */
    public function count_mappings($supplier_filter = "", $confidence_filter = "", $search_filter = "") {
        global $wpdb;
        
        // Build where clause
        $where = array("1=1");
        $params = array();
        
        if (!empty($supplier_filter)) {
            $where[] = "supplier_name = %s";
            $params[] = $supplier_filter;
        }
        
        if (!empty($confidence_filter)) {
            $where[] = "match_confidence = %s";
            $params[] = $confidence_filter;
        }
        
        if (!empty($search_filter)) {
            $where[] = "(supplier_title LIKE %s OR kt_sku LIKE %s OR matched_terms LIKE %s)";
            $search_like = '%' . $wpdb->esc_like($search_filter) . '%';
            $params[] = $search_like;
            $params[] = $search_like;
            $params[] = $search_like;
        }
        
        // Build query
        $query = "SELECT COUNT(*) 
                 FROM {$wpdb->prefix}{$this->mapping_table} 
                 WHERE " . implode(" AND ", $where);
        
        // Prepare and execute query
        if (!empty($params)) {
            $query = $wpdb->prepare($query, $params);
        }
        
        return (int)$wpdb->get_var($query);
    }
    
    /**
     * Save a mapping
     * 
     * @param string $supplier_id Supplier product ID
     * @param string $supplier_title Supplier product title
     * @param string $supplier_name Supplier name
     * @param string $kt_sku KT SKU
     * @param string $match_confidence Match confidence
     * @param string $matched_terms Matched terms
     * @return bool Success
     */
    public function save_mapping($supplier_id, $supplier_title, $supplier_name, $kt_sku, $match_confidence, $matched_terms = "") {
        global $wpdb;
        
        // Check if mapping already exists
        $existing = $wpdb->get_var($wpdb->prepare(
            "SELECT id FROM {$wpdb->prefix}{$this->mapping_table} 
            WHERE supplier_name = %s AND supplier_id = %s",
            $supplier_name, $supplier_id
        ));
        
        if ($existing) {
            // Update existing mapping
            $result = $wpdb->update(
                $wpdb->prefix . $this->mapping_table,
                array(
                    "kt_sku" => $kt_sku,
                    "match_confidence" => $match_confidence,
                    "matched_terms" => $matched_terms
                ),
                array(
                    "supplier_name" => $supplier_name,
                    "supplier_id" => $supplier_id
                )
            );
        } else {
            // Insert new mapping
            $result = $wpdb->insert(
                $wpdb->prefix . $this->mapping_table,
                array(
                    "supplier_id" => $supplier_id,
                    "supplier_name" => $supplier_name,
                    "supplier_title" => $supplier_title,
                    "kt_sku" => $kt_sku,
                    "match_confidence" => $match_confidence,
                    "matched_terms" => $matched_terms
                )
            );
            
            // Update supplier count
            $this->update_supplier_count($supplier_name);
        }
        
        return $result !== false;
    }
    
    /**
     * Update supplier mapping count
     * 
     * @param string $supplier_name Supplier name
     */
    private function update_supplier_count($supplier_name) {
        global $wpdb;
        
        // Get mapping count
        $count = $wpdb->get_var($wpdb->prepare(
            "SELECT COUNT(*) FROM {$wpdb->prefix}{$this->mapping_table} WHERE supplier_name = %s",
            $supplier_name
        ));
        
        // Check if supplier exists
        $supplier_id = $wpdb->get_var($wpdb->prepare(
            "SELECT id FROM {$wpdb->prefix}{$this->suppliers_table} WHERE supplier_name = %s",
            $supplier_name
        ));
        
        if ($supplier_id) {
            // Update existing supplier
            $wpdb->update(
                $wpdb->prefix . $this->suppliers_table,
                array("mapping_count" => $count),
                array("id" => $supplier_id)
            );
        } else {
            // Insert new supplier
            $wpdb->insert(
                $wpdb->prefix . $this->suppliers_table,
                array(
                    "supplier_name" => $supplier_name,
                    "supplier_description" => "",
                    "mapping_count" => $count
                )
            );
        }
    }
  /**
 * Clean up expired sessions
 */
private function cleanup_expired_sessions() {
    $active_sessions = get_option('kt_cigar_matcher_active_sessions', array());
    $valid_sessions = array();
    
    foreach ($active_sessions as $session_key) {
        $session_data = get_transient($session_key);
        if ($session_data) {
            $valid_sessions[] = $session_key;
        }
    }
    
    update_option('kt_cigar_matcher_active_sessions', $valid_sessions);
    $this->log_debug("Cleaned up sessions. Valid sessions: " . implode(", ", $valid_sessions));
}
	
	
	
	
	
    /**
     * Process CSV header
     * 
     * @param array $header CSV header row
     * @param array $mapping Column mapping
     * @return array Processed header with mapping
     */
    private function process_csv_header($header, $mapping = null) {
        $processed_header = array();
        
        // Check if we have a mapping
        if (!empty($mapping) && is_array($mapping)) {
            foreach ($header as $index => $field) {
                // Clean field name
                $field = trim($field);
                
                // Find mapping for this field
                $mapped_field = "skip";
                foreach ($mapping as $map) {
                    if (isset($map["csv_column"]) && $map["csv_column"] === $field) {
                        $mapped_field = $map["kt_field"];
                        break;
                    }
                }
                
                $processed_header[$index] = array(
                    "original" => $field,
                    "mapped" => $mapped_field
                );
            }
        } else {
            // Auto-detect field mapping
            foreach ($header as $index => $field) {
                // Clean field name
                $field = trim($field);
                
                // Determine field type
                $mapped_field = "skip";
                $field_lower = strtolower($field);
                
                // ID field detection
                if ($field_lower === "id" || $field_lower === "product_id" || $field_lower === "item_id") {
                    $mapped_field = "id";
                }
                // Title field detection
                else if ($field_lower === "title" || $field_lower === "product_title" || $field_lower === "name" || $field_lower === "product_name") {
                    $mapped_field = "title";
                }
                // Brand field detection
                else if ($field_lower === "brand" || $field_lower === "manufacturer" || $field_lower === "maker") {
                    $mapped_field = "brand";
                }
                // Model field detection
                else if ($field_lower === "model" || $field_lower === "series" || $field_lower === "line") {
                    $mapped_field = "model";
                }
                // Ring gauge field detection
                else if ($field_lower === "ring" || $field_lower === "ring_gauge" || $field_lower === "gauge" || $field_lower === "rg") {
                    $mapped_field = "ring_gauge";
                }
                // Length field detection
                else if ($field_lower === "length" || $field_lower === "len") {
                    $mapped_field = "length";
                }
                // Price field detection
                else if ($field_lower === "price" || $field_lower === "cost" || $field_lower === "unit_price") {
                    $mapped_field = "price";
                }
                // Description field detection
                else if ($field_lower === "description" || $field_lower === "desc" || $field_lower === "product_description") {
                    $mapped_field = "description";
                }
                // Stock field detection
                else if ($field_lower === "stock" || $field_lower === "quantity" || $field_lower === "qty" || $field_lower === "inventory") {
                    $mapped_field = "stock";
                }
                
                $processed_header[$index] = array(
                    "original" => $field,
                    "mapped" => $mapped_field
                );
            }
        }
        
        return $processed_header;
    }
    
    /* AJAX HANDLERS */
    
    /**
     * AJAX handler for uploading supplier CSV
     */
    public function ajax_upload_supplier_csv() {
     // Clean up expired sessions before creating a new one
$this->cleanup_expired_sessions();
		
		
		
		check_ajax_referer("kt-cigar-matcher-nonce", "kt_cigar_matcher_nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get supplier name
        $supplier_name = isset($_POST["supplier_name"]) ? sanitize_text_field($_POST["supplier_name"]) : "";
        
        if (empty($supplier_name)) {
            wp_send_json_error(array("message" => "Supplier name is required"));
        }
        
        $this->log_debug("Processing CSV upload for supplier: " . $supplier_name);
        
        // Check if a file was uploaded
        if (!isset($_FILES["supplier_csv"]) || $_FILES["supplier_csv"]["error"] !== UPLOAD_ERR_OK) {
            $this->log_debug("No file uploaded or error: " . ($_FILES["supplier_csv"]["error"] ?? "unknown"));
            wp_send_json_error(array("message" => "No file uploaded or error"));
        }
       // Validate file type
        $file_type = wp_check_filetype(basename($_FILES["supplier_csv"]["name"]), array("csv" => "text/csv"));
        
        if ($file_type["type"] !== "text/csv") {
            $this->log_debug("Invalid file type: " . ($file_type["type"] ?? "unknown"));
            wp_send_json_error(array("message" => "Invalid file type. Please upload a CSV file."));
        }
        
        // Create upload directory if it doesn't exist
        $upload_dir = wp_upload_dir();
        $supplier_dir = $upload_dir["basedir"] . "/cigar-supplier-csv";
        
        if (!file_exists($supplier_dir)) {
            if (!wp_mkdir_p($supplier_dir)) {
                $this->log_debug("Failed to create directory: " . $supplier_dir);
                wp_send_json_error(array("message" => "Failed to create upload directory"));
            }
        }
        
        // Generate unique filename
        $filename = sanitize_file_name($supplier_name . "-" . date("Y-m-d-H-i-s") . ".csv");
        $file_path = $supplier_dir . "/" . $filename;
        
        // Move uploaded file
        if (!move_uploaded_file($_FILES["supplier_csv"]["tmp_name"], $file_path)) {
            $this->log_debug("Failed to move uploaded file to: " . $file_path);
            wp_send_json_error(array("message" => "Failed to upload file"));
        }
        
        // Process CSV file
        $csv_data = array();
        
        // Open file
        $handle = fopen($file_path, "r");
        
        if ($handle === false) {
            $this->log_debug("Failed to open file: " . $file_path);
            wp_send_json_error(array("message" => "Failed to read CSV file"));
        }
        
        // Read header row
        $header = fgetcsv($handle);
        
        if ($header === false) {
            $this->log_debug("Failed to read CSV header");
            fclose($handle);
            wp_send_json_error(array("message" => "Failed to read CSV header"));
        }
        
        // Try to load a template for this supplier
        global $wpdb;
        $template = $wpdb->get_row($wpdb->prepare(
            "SELECT column_mappings FROM {$wpdb->prefix}{$this->template_table} WHERE supplier_name = %s ORDER BY updated_at DESC LIMIT 1",
            $supplier_name
        ));
        
        $column_mapping = null;
        
        if ($template && !empty($template->column_mappings)) {
            $column_mapping = json_decode($template->column_mappings, true);
        }
        
        // Process header
        $processed_header = $this->process_csv_header($header, $column_mapping);
        
        // Setup session variable for storing data
        $session_key = "kt_cigar_matcher_" . md5($supplier_name . time());
        
        // Check if we have the necessary columns
        $has_id = false;
        $has_title = false;
        
        foreach ($processed_header as $field) {
            if ($field["mapped"] === "id") {
                $has_id = true;
            } else if ($field["mapped"] === "title") {
                $has_title = true;
            }
        }
        
        if (!$has_id || !$has_title) {
            $this->log_debug("Missing required columns: ID and/or Title");
            fclose($handle);
            wp_send_json_error(array("message" => "CSV file must contain ID and Title columns"));
        }
        
        // Read data rows
        $row_count = 0;
        $data_rows = array();
        
        while (($row = fgetcsv($handle)) !== false) {
            $row_data = array();
            
            // Process each field according to mapping
            foreach ($processed_header as $index => $field) {
                if (isset($row[$index])) {
                    $value = trim($row[$index]);
                    
                    // Only add fields that are mapped
                    if ($field["mapped"] !== "skip") {
                        $row_data[$field["mapped"]] = $value;
                    }
                }
            }
            
            // Only add rows with ID and Title
            if (!empty($row_data["id"]) && !empty($row_data["title"])) {
                $data_rows[] = $row_data;
                $row_count++;
            }
        }
        
        fclose($handle);
        
        // Store data in session
        set_transient($session_key, array(
            "supplier_name" => $supplier_name,
            "file_path" => $file_path,
            "header" => $processed_header,
            "data" => $data_rows,
            "total_rows" => $row_count,
            "processed_rows" => 0
        ), 60 * 60 * 2); // 2 hour expiration
        
        $this->log_debug("CSV file processed with $row_count products. Session key: $session_key");
        // Store session key in active sessions
$active_sessions = get_option('kt_cigar_matcher_active_sessions', array());
$active_sessions[] = $session_key;
update_option('kt_cigar_matcher_active_sessions', $active_sessions);

$this->log_debug("Added session key to active sessions: $session_key");
		
		
		
		
        // Return success with session key
        wp_send_json_success(array(
            "message" => "CSV file uploaded successfully with $row_count products",
            "session_key" => $session_key,
            "total_rows" => $row_count
        ));
    }
    
    /**
     * AJAX handler for checking session status
     */
    public function ajax_check_status() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Check for errors
        $errors = array();
        
        // Check required tables
        global $wpdb;
        $master_table = $wpdb->prefix . $this->master_table;
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$master_table'") != $master_table) {
            $errors[] = "Master products table does not exist";
        }
        
        // Check data file
        $data_file = $this->load_data_file();
        
        if (empty($data_file)) {
            $errors[] = "Data file is missing or empty";
        }
        
        // Return status
        wp_send_json_success(array(
            "has_errors" => !empty($errors),
            "message" => implode(", ", $errors),
            "debug_log" => array_slice($this->debug_log, -10)
        ));
    }
    
    /**
     * AJAX handler for processing a batch of products
     */
    public function ajax_process_batch_products() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $position = isset($_POST["position"]) ? intval($_POST["position"]) : 0;
        $batch_size = isset($_POST["batch_size"]) ? intval($_POST["batch_size"]) : 10;
        
        // Get session data
        $session_keys = get_option('kt_cigar_matcher_active_sessions', array());
        $session_key = end($session_keys);
        
        if (!$session_key) {
            $this->log_debug("No active session found");
            wp_send_json_error(array("message" => "No active session found"));
        }
        
        $session_data = get_transient($session_key);
        
        if (!$session_data) {
            $this->log_debug("Session expired or not found: $session_key");
            wp_send_json_error(array("message" => "Session expired or not found"));
        }
        
        // Get batch of products
        $start = $position;
        $end = min($position + $batch_size, count($session_data["data"]));
        
        $this->log_debug("Processing batch from $start to $end of {$session_data["total_rows"]} products");
        
        if ($start >= $end) {
            // All products processed
            wp_send_json_success(array(
                "completed" => true,
                "position" => $end,
                "total" => $session_data["total_rows"],
                "percentage" => 100
            ));
        }
        
        // Process batch
        $batch_results = array();
        $match_counts = array(
            "exact" => 0,
            "close" => 0,
            "possible" => 0,
            "manual" => 0,
            "none" => 0
        );
        
        for ($i = $start; $i < $end; $i++) {
            $product = $session_data["data"][$i];
            
            // Process the product
            $process_result = $this->process_supplier_product($product, $session_data["supplier_name"]);
            
            // Save mapping if we have a match
            if ($process_result["match_status"] !== "no_match" && !empty($process_result["best_match"])) {
                $match_confidence = "none";
                
                switch ($process_result["match_status"]) {
                    case "exact_match":
                        $match_confidence = "exact";
                        break;
                    case "close_match":
                        $match_confidence = "close";
                        break;
                    case "possible_match":
                        $match_confidence = "possible";
                        break;
                    case "manual_match":
                        $match_confidence = "manual";
                        break;
                }
                
                // Save the mapping
                $matched_terms = is_array($process_result["matched_terms"]) ? 
                                implode(',', $process_result["matched_terms"]) : 
                                $process_result["matched_terms"];
                
                $this->save_mapping(
                    $process_result["product_id"],
                    $process_result["product_title"],
                    $session_data["supplier_name"],
                    $process_result["best_match"]["sku"],
                    $match_confidence,
                    $matched_terms
                );
            }
            
            // Update match counts
            switch ($process_result["match_status"]) {
                case "exact_match":
                    $match_counts["exact"]++;
                    break;
                case "close_match":
                    $match_counts["close"]++;
                    break;
                case "possible_match":
                    $match_counts["possible"]++;
                    break;
                case "manual_match":
                    $match_counts["manual"]++;
                    break;
                default:
                    $match_counts["none"]++;
            }
            
            // Add to batch results
            $batch_results[] = $process_result;
        }
        
        // Update session data
        $session_data["processed_rows"] = $end;
        set_transient($session_key, $session_data, 60 * 60 * 2); // 2 hour expiration
        
        // Calculate percentage
        $percentage = round(($end / $session_data["total_rows"]) * 100);
        
        $this->log_debug("Batch processing complete. Match counts: " . json_encode($match_counts));
        
        // Return results
        wp_send_json_success(array(
            "completed" => $end >= $session_data["total_rows"],
            "position" => $end,
            "total" => $session_data["total_rows"],
            "percentage" => $percentage,
            "batch_results" => $batch_results,
            "match_counts" => $match_counts
        ));
    }
    
    /**
     * AJAX handler for saving a mapping
     */
    public function ajax_save_mapping() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $supplier_id = isset($_POST["supplier_id"]) ? sanitize_text_field($_POST["supplier_id"]) : "";
        $supplier_title = isset($_POST["supplier_title"]) ? sanitize_text_field($_POST["supplier_title"]) : "";
        $supplier_name = isset($_POST["supplier_name"]) ? sanitize_text_field($_POST["supplier_name"]) : "";
        $kt_sku = isset($_POST["kt_sku"]) ? sanitize_text_field($_POST["kt_sku"]) : "";
        
        if (empty($supplier_id) || empty($supplier_name) || empty($kt_sku)) {
            wp_send_json_error(array("message" => "Missing required parameters"));
        }
        
        // Save the mapping
        $result = $this->save_mapping(
            $supplier_id,
            $supplier_title,
            $supplier_name,
            $kt_sku,
            "manual",
            ""
        );
        
        if ($result) {
            $this->log_debug("Manual mapping saved: $supplier_id -> $kt_sku");
            wp_send_json_success(array("message" => "Mapping saved successfully"));
        } else {
            $this->log_debug("Failed to save manual mapping: $supplier_id -> $kt_sku");
            wp_send_json_error(array("message" => "Failed to save mapping"));
        }
    }
    
    /**
     * AJAX handler for deleting a mapping
     */
    public function ajax_delete_mapping() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $mapping_id = isset($_POST["mapping_id"]) ? intval($_POST["mapping_id"]) : 0;
        
        if ($mapping_id <= 0) {
            wp_send_json_error(array("message" => "Invalid mapping ID"));
        }
        
        // Delete the mapping
        global $wpdb;
        $result = $wpdb->delete(
            $wpdb->prefix . $this->mapping_table,
            array("id" => $mapping_id)
        );
        
        if ($result) {
            $this->log_debug("Mapping deleted: $mapping_id");
            wp_send_json_success(array("message" => "Mapping deleted successfully"));
        } else {
            $this->log_debug("Failed to delete mapping: $mapping_id");
            wp_send_json_error(array("message" => "Failed to delete mapping"));
        }
    }
    
    /**
     * AJAX handler for exporting mappings
     */
    public function ajax_export_mappings() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $supplier = isset($_POST["supplier"]) ? sanitize_text_field($_POST["supplier"]) : "";
        
        if (empty($supplier)) {
            wp_send_json_error(array("message" => "Supplier name is required"));
        }
        
        // Get mappings
        global $wpdb;
        $mappings = $wpdb->get_results($wpdb->prepare(
            "SELECT m.supplier_id, m.supplier_title, m.kt_sku, m.match_confidence, p.product_title 
            FROM {$wpdb->prefix}{$this->mapping_table} m 
            LEFT JOIN {$wpdb->prefix}{$this->master_table} p ON m.kt_sku = p.sku 
            WHERE m.supplier_name = %s 
            ORDER BY m.supplier_id ASC",
            $supplier
        ));
        
        if (empty($mappings)) {
            wp_send_json_error(array("message" => "No mappings found for this supplier"));
        }
        
        // Generate CSV
        $csv = "Supplier ID,Supplier Title,KT SKU,KT Title,Match Confidence\n";
        
        foreach ($mappings as $mapping) {
            $csv .= '"' . str_replace('"', '""', $mapping->supplier_id) . '",';
            $csv .= '"' . str_replace('"', '""', $mapping->supplier_title) . '",';
            $csv .= '"' . str_replace('"', '""', $mapping->kt_sku) . '",';
            $csv .= '"' . str_replace('"', '""', $mapping->product_title ?? "") . '",';
            $csv .= '"' . str_replace('"', '""', ucfirst($mapping->match_confidence)) . '"' . "\n";
        }
        
        // Generate filename
        $filename = sanitize_file_name($supplier . "-mappings-" . date("Y-m-d") . ".csv");
        
        $this->log_debug("Exported " . count($mappings) . " mappings for $supplier");
        
        // Return CSV data
        wp_send_json_success(array(
            "csv" => $csv,
            "filename" => $filename
        ));
    }
    
    /**
     * AJAX handler for saving a template
     */
    public function ajax_save_template() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $template_id = isset($_POST["template_id"]) ? intval($_POST["template_id"]) : 0;
        $template_name = isset($_POST["template_name"]) ? sanitize_text_field($_POST["template_name"]) : "";
        $supplier_name = isset($_POST["supplier_name"]) ? sanitize_text_field($_POST["supplier_name"]) : "";
        $column_mappings = isset($_POST["column_mappings"]) ? $_POST["column_mappings"] : "";
        
        if (empty($template_name) || empty($supplier_name) || empty($column_mappings)) {
            wp_send_json_error(array("message" => "Missing required parameters"));
        }
        
        // Parse column mappings
        $column_mappings_json = json_decode($column_mappings, true);
        
        if (!is_array($column_mappings_json)) {
            wp_send_json_error(array("message" => "Invalid column mappings format"));
        }
        
        // Save template
        global $wpdb;
        
        if ($template_id > 0) {
            // Update existing template
            $result = $wpdb->update(
                $wpdb->prefix . $this->template_table,
                array(
                    "template_name" => $template_name,
                    "supplier_name" => $supplier_name,
                    "column_mappings" => $column_mappings
                ),
                array("id" => $template_id)
            );
        } else {
            // Check if template name already exists
            $exists = $wpdb->get_var($wpdb->prepare(
                "SELECT id FROM {$wpdb->prefix}{$this->template_table} WHERE template_name = %s",
                $template_name
            ));
            
            if ($exists) {
                wp_send_json_error(array("message" => "Template name already exists"));
            }
            
            // Insert new template
            $result = $wpdb->insert(
                $wpdb->prefix . $this->template_table,
                array(
                    "template_name" => $template_name,
                    "supplier_name" => $supplier_name,
                    "column_mappings" => $column_mappings
                )
            );
        }
        
        if ($result) {
            $this->log_debug("Template saved: $template_name for $supplier_name");
            wp_send_json_success(array("message" => "Template saved successfully"));
        } else {
            $this->log_debug("Failed to save template: $template_name");
            wp_send_json_error(array("message" => "Failed to save template"));
        }
    }
    
    /**
     * AJAX handler for loading a template
     */
    public function ajax_load_template() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $template_id = isset($_POST["template_id"]) ? intval($_POST["template_id"]) : 0;
        
        if ($template_id <= 0) {
            wp_send_json_error(array("message" => "Invalid template ID"));
        }
        
        // Get template
        global $wpdb;
        $template = $wpdb->get_row($wpdb->prepare(
            "SELECT * FROM {$wpdb->prefix}{$this->template_table} WHERE id = %d",
            $template_id
        ));
        
        if (!$template) {
            wp_send_json_error(array("message" => "Template not found"));
        }
        
        // Return template data
        wp_send_json_success(array(
            "id" => $template->id,
            "template_name" => $template->template_name,
            "supplier_name" => $template->supplier_name,
            "column_mappings" => $template->column_mappings
        ));
    }
    
    /**
     * AJAX handler for deleting a template
     */
    public function ajax_delete_template() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $template_id = isset($_POST["template_id"]) ? intval($_POST["template_id"]) : 0;
        
        if ($template_id <= 0) {
            wp_send_json_error(array("message" => "Invalid template ID"));
        }
        
        // Delete template
        global $wpdb;
        $result = $wpdb->delete(
            $wpdb->prefix . $this->template_table,
            array("id" => $template_id)
        );
        
        if ($result) {
            $this->log_debug("Template deleted: $template_id");
            wp_send_json_success(array("message" => "Template deleted successfully"));
        } else {
            $this->log_debug("Failed to delete template: $template_id");
            wp_send_json_error(array("message" => "Failed to delete template"));
        }
    }
    
    /**
     * AJAX handler for listing templates
     */
    public function ajax_list_templates() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get templates
        global $wpdb;
        $templates = $wpdb->get_results(
            "SELECT id, template_name, supplier_name FROM {$wpdb->prefix}{$this->template_table} ORDER BY template_name ASC"
        );
        
        // Return templates
        wp_send_json_success(array("templates" => $templates));
    }
    
    /**
     * AJAX handler for searching by SKU
     */
    public function ajax_search_sku() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $search = isset($_POST["search"]) ? sanitize_text_field($_POST["search"]) : "";
        
        if (empty($search)) {
            wp_send_json_error(array("message" => "Search term is required"));
        }
        
        // Search products
        global $wpdb;
        $products = $wpdb->get_results($wpdb->prepare(
            "SELECT sku, product_title FROM {$wpdb->prefix}{$this->master_table} 
            WHERE (sku LIKE %s OR product_title LIKE %s) 
            AND (product_type = 'cigar' OR product_type = '') 
            ORDER BY brand ASC, sku ASC 
            LIMIT 50",
            "%" . $wpdb->esc_like($search) . "%",
            "%" . $wpdb->esc_like($search) . "%"
        ));
        
        $this->log_debug("SKU search for '$search' returned " . count($products) . " results");
        
        // Return products
        wp_send_json_success(array("products" => $products));
    }
    
    /**
     * AJAX handler for searching by brand
     */
    public function ajax_search_by_brand() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $brand = isset($_POST["brand"]) ? sanitize_text_field($_POST["brand"]) : "";
        
        if (empty($brand)) {
            wp_send_json_error(array("message" => "Brand is required"));
        }
        
        // Search products
        global $wpdb;
        $products = $wpdb->get_results($wpdb->prepare(
            "SELECT sku, product_title FROM {$wpdb->prefix}{$this->master_table} 
            WHERE (brand LIKE %s OR product_title LIKE %s) 
            AND (product_type = 'cigar' OR product_type = '') 
            ORDER BY sku ASC 
            LIMIT 50",
            "%" . $wpdb->esc_like($brand) . "%",
            "%" . $wpdb->esc_like($brand) . "%"
        ));
        
        $this->log_debug("Brand search for '$brand' returned " . count($products) . " results");
        
        // Return products
        wp_send_json_success(array("products" => $products));
    }
    
    /**
     * AJAX handler for quick mapping
     */
    public function ajax_quick_map() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $supplier_id = isset($_POST["supplier_id"]) ? sanitize_text_field($_POST["supplier_id"]) : "";
        $kt_sku = isset($_POST["kt_sku"]) ? sanitize_text_field($_POST["kt_sku"]) : "";
        
        if (empty($supplier_id) || empty($kt_sku)) {
            wp_send_json_error(array("message" => "Missing required parameters"));
        }
        
        // Get session data
        $session_keys = get_option('kt_cigar_matcher_active_sessions', array());
        $session_key = end($session_keys);
        
        if (!$session_key) {
            $this->log_debug("No active session found for quick map");
            wp_send_json_error(array("message" => "No active session found"));
        }
        
        $session_data = get_transient($session_key);
        
        if (!$session_data) {
            $this->log_debug("Session expired or not found for quick map: $session_key");
            wp_send_json_error(array("message" => "Session expired or not found"));
        }
        
        // Find supplier product
        $supplier_product = null;
        
        foreach ($session_data["data"] as $product) {
            if ($product["id"] === $supplier_id) {
                $supplier_product = $product;
                break;
            }
        }
        
        if (!$supplier_product) {
            $this->log_debug("Supplier product not found for ID: $supplier_id");
            wp_send_json_error(array("message" => "Supplier product not found"));
        }
        
        // Get KT product title
        global $wpdb;
        $kt_product = $wpdb->get_row($wpdb->prepare(
            "SELECT product_title FROM {$wpdb->prefix}{$this->master_table} WHERE sku = %s",
            $kt_sku
        ));
        
        if (!$kt_product) {
            $this->log_debug("KT product not found for SKU: $kt_sku");
            wp_send_json_error(array("message" => "KT product not found"));
        }
        
        // Save the mapping
        $result = $this->save_mapping(
            $supplier_id,
            $supplier_product["title"],
            $session_data["supplier_name"],
            $kt_sku,
            "manual"
        );
        
        if ($result) {
            $this->log_debug("Quick map saved: $supplier_id -> $kt_sku");
            wp_send_json_success(array(
                "message" => "Mapping saved successfully",
                "kt_title" => $kt_product->product_title
            ));
        } else {
            $this->log_debug("Failed to save quick map: $supplier_id -> $kt_sku");
            wp_send_json_error(array("message" => "Failed to save mapping"));
        }
    }
}

// Initialize the plugin
$kt_cigar_enhanced_matcher = new KT_Cigar_Enhanced_Matcher();
